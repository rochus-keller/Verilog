

// This file was automatically generated by Coco/R; don't modify it.
#include "VlParser.h"
#include "VlErrors.h"
#include <QtDebug>
#include <QFileInfo>

namespace Vl {


static QString coco_string_create( const wchar_t* str )
{
    return QString::fromStdWString(str);
}

int Parser::peek( quint8 la )
{
	if( la == 0 )
		return d_cur.d_type;
	else if( la == 1 )
		return d_next.d_type;
	else
		return scanner->peekToken( la - 1 ).d_type;
}


void Parser::SynErr(int n, const char* ctx) {
    if (errDist >= minErrDist)
    {
        if( d_next.d_substituted )
        {
            QFileInfo info(d_next.d_sourcePath);
            QString str = QString(": included from here: %1:%2:%3")
                    .arg(info.fileName()).arg(d_next.d_lineNr).arg(d_next.d_colNr);
            SynErr(scanner->getMainSource(),scanner->getMainLineNr(), scanner->getMainColNr(),
                           n, errors, ctx, str );
        }else
            SynErr(d_next.d_sourcePath,d_next.d_lineNr, d_next.d_colNr, n, errors, ctx);
    }
	errDist = 0;
}

void Parser::SemErr(const char* msg) {
	if (errDist >= minErrDist) errors->error(Vl::Errors::Semantics,d_cur.d_sourcePath,d_cur.d_lineNr, d_cur.d_colNr, msg);
	errDist = 0;
}

void Parser::Get() {
	for (;;) {
		d_cur = d_next;
		d_next = scanner->nextToken();
        bool deliverToParser = false;
        switch( d_next.d_type )
        {
        case Vl::Tok_Invalid:
        	if( !d_next.d_val.isEmpty() )
            	SynErr( d_next.d_type, d_next.d_val );
            // else errors already handeled in lexer
            break;
        case Vl::Tok_MacroUsage:
            {
                Vl::SynTree* n = new Vl::SynTree( Vl::Tok_MacroUsage, d_next );
                d_stack.top()->d_children.append(n);
                for(;;)
                {
                    Vl::Token t = scanner->nextToken();
                    if( t.d_prePp )
                    {
                        if( t.d_type == Vl::Tok_Ident || t.d_type == Vl::Tok_CoDi )
                            n->d_children.append( new Vl::SynTree( t ) );
                        // else ignore
                    }else
                    {
                        // regular end
                        d_next = t;
                        deliverToParser = true;
                        break;
                    }
                }
            }
            break;
        case Vl::Tok_Attribute:
            {
                Vl::SynTree* n = new Vl::SynTree( Vl::Tok_Attribute, d_next );
                d_stack.top()->d_children.append(n);
            }
            break;
        case Vl::Tok_Latt:
            {
                Vl::SynTree* n = new Vl::SynTree( Vl::Tok_Attribute, d_next );
                d_stack.top()->d_children.append(n);
                for(;;)
                {
                    Vl::Token t = scanner->nextToken();
                    if( t.d_type == Vl::Tok_Ratt )
                    {
                        // regular end
                        break;
                    }else if( t.d_type == Vl::Tok_Eof || t.d_type == Vl::Tok_Latt )
                    {
                        // irregular end
                        d_cur = d_next;
                        SemErr("non-terminated attribute");
                        break;
                    }else
                    {
                        if( t.d_type == Vl::Tok_Ident || t.d_type == Vl::Tok_CoDi )
                            n->d_children.append( new Vl::SynTree( t ) );
                        // else ignore
                    }
                }
            }
            break;
        case Vl::Tok_Comment:
            // ignorieren
            break;
        case Vl::Tok_Section:
        case Vl::Tok_SectionEnd:
            d_sections.append(d_next);
            break;
        default:
            deliverToParser = true;
            break;
        }

        if( deliverToParser )
        {
            if( d_next.d_type == Vl::Tok_Eof )
                d_next.d_type = _EOF;

            la->kind = d_next.d_type;
            if (la->kind <= maxT)
            {
                ++errDist;
                break;
            }
        }

		d_next = d_cur;
	}
}

void Parser::Expect(int n, const char* ctx ) {
	if (la->kind==n) Get(); else { SynErr(n, ctx); }
}

void Parser::ExpectWeak(int n, int follow) {
	if (la->kind == n) Get();
	else {
		SynErr(n);
		while (!StartOf(follow)) Get();
	}
}

bool Parser::WeakSeparator(int n, int syFol, int repFol) {
	if (la->kind == n) {Get(); return true;}
	else if (StartOf(repFol)) {return false;}
	else {
		SynErr(n);
		while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
			Get();
		}
		return StartOf(syFol);
	}
}

void Parser::Verilog() {
		d_stack.push(&d_root); 
		while (StartOf(1)) {
			if (la->kind == _T_macromodule || la->kind == _T_module) {
				module_declaration();
			} else if (la->kind == _T_primitive) {
				udp_declaration();
			} else if (la->kind == _T_config) {
				config_declaration();
			} else if (la->kind == _T_library) {
				library_declaration();
			} else {
				include_statement();
			}
		}
		d_stack.pop(); 
}

void Parser::module_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		module_keyword();
		module_identifier();
		if (la->kind == _T_Hash) {
			module_parameter_port_list();
		}
		if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			if (StartOf(2)) {
				list_of_ports();
			} else if (la->kind == _T_inout || la->kind == _T_input || la->kind == _T_output) {
				list_of_port_declarations();
			} else SynErr(260,__FUNCTION__);
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		}
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		while (StartOf(3)) {
			if (la->kind == _T_inout || la->kind == _T_input || la->kind == _T_output) {
				port_declaration();
				Expect(_T_Semi,__FUNCTION__);
				addTerminal(); 
			} else {
				non_port_module_item();
			}
		}
		Expect(_T_endmodule,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::udp_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_primitive,__FUNCTION__);
		addTerminal(); 
		udp_identifier();
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Ident) {
			udp_port_list();
		} else if (la->kind == _T_output) {
			udp_declaration_port_list();
		} else SynErr(261,__FUNCTION__);
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		if (StartOf(4)) {
			udp_port_declaration();
			while (StartOf(4)) {
				udp_port_declaration();
			}
		}
		udp_body();
		Expect(_T_endprimitive,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::config_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_config_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_config,__FUNCTION__);
		addTerminal(); 
		config_identifier();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		design_statement();
		while (la->kind == _T_cell || la->kind == _T_default || la->kind == _T_instance) {
			config_rule_statement();
		}
		Expect(_T_endconfig,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::library_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_library_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_library,__FUNCTION__);
		addTerminal(); 
		library_identifier();
		file_path_spec();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			file_path_spec();
		}
		if (la->kind == _T_Minus) {
			Get();
			addTerminal(); 
			Expect(_T_incdir,__FUNCTION__);
			addTerminal(); 
			file_path_spec();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				file_path_spec();
			}
		}
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::include_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_include_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_include,__FUNCTION__);
		addTerminal(); 
		file_path_spec();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::library_identifier() {
		identifier();
}

void Parser::file_path_spec() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_file_path_spec, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Str) {
			string();
		} else if (StartOf(5)) {
			file_path_glyph_();
			while (StartOf(5)) {
				file_path_glyph_();
			}
		} else SynErr(262,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::string() {
		Expect(_T_Str,__FUNCTION__);
		addTerminal(); 
}

void Parser::file_path_glyph_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_file_path_glyph_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Ident: {
			identifier();
			break;
		}
		case _T_Slash: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Star: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Qmark: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Dot: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_2Dot: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_3Dot: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(263,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::identifier() {
		Expect(_T_Ident,__FUNCTION__);
		addTerminal(); 
}

void Parser::module_keyword() {
		if (la->kind == _T_module) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_macromodule) {
			Get();
			addTerminal(); 
		} else SynErr(264,__FUNCTION__);
}

void Parser::module_identifier() {
		identifier();
}

void Parser::module_parameter_port_list() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_parameter_port_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Hash,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		parameter_declaration();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			parameter_declaration();
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::list_of_ports() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_ports, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		port();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			port();
		}
		d_stack.pop(); 
}

void Parser::list_of_port_declarations() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_port_declarations, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		port_declaration();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			port_declaration();
		}
		d_stack.pop(); 
}

void Parser::port_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_port_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_inout) {
			inout_declaration();
		} else if (la->kind == _T_input) {
			input_declaration();
		} else if (la->kind == _T_output) {
			output_declaration();
		} else SynErr(265,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::non_port_module_item() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_non_port_module_item, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(6)) {
			module_or_generate_item();
		} else if (la->kind == _T_generate) {
			generate_region();
		} else if (la->kind == _T_specify) {
			specify_block();
		} else if (la->kind == _T_parameter) {
			parameter_declaration();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_specparam) {
			specparam_declaration();
		} else SynErr(266,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::parameter_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_parameter_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_parameter,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Lbrack || la->kind == _T_signed || la->kind == _T_Ident) {
			if (la->kind == _T_signed) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _T_Lbrack) {
				range();
			}
			list_of_param_assignments();
		} else if (StartOf(7)) {
			parameter_type();
			list_of_param_assignments();
		} else SynErr(267,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::port() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_port, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(8)) {
			if (la->kind == _T_Lbrace || la->kind == _T_Ident) {
				port_expression();
			}
		} else if (la->kind == _T_Dot) {
			Get();
			addTerminal(); 
			port_identifier();
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
			if (la->kind == _T_Lbrace || la->kind == _T_Ident) {
				port_expression();
			}
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		} else SynErr(268,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::port_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_port_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Ident) {
			port_reference();
		} else if (la->kind == _T_Lbrace) {
			Get();
			addTerminal(); 
			port_reference();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				port_reference();
			}
			Expect(_T_Rbrace,__FUNCTION__);
			addTerminal(); 
		} else SynErr(269,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::port_identifier() {
		identifier();
}

void Parser::port_reference() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_port_reference, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		port_identifier();
		if (la->kind == _T_Lbrack) {
			Get();
			addTerminal(); 
			constant_range_expression();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::constant_range_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_constant_range_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		range_expression();
		d_stack.pop(); 
}

void Parser::inout_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_inout_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_inout,__FUNCTION__);
		addTerminal(); 
		if (StartOf(9)) {
			net_type();
		}
		if (la->kind == _T_signed) {
			Get();
			addTerminal(); 
		}
		if (la->kind == _T_Lbrack) {
			range();
		}
		list_of_port_identifiers();
		d_stack.pop(); 
}

void Parser::input_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_input_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_input,__FUNCTION__);
		addTerminal(); 
		if (StartOf(10)) {
			if (StartOf(9)) {
				net_type();
			}
			if (la->kind == _T_signed) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _T_Lbrack) {
				range();
			}
			list_of_port_identifiers();
		} else if (la->kind == _T_logic || la->kind == _T_reg) {
			reg_();
			if (la->kind == _T_signed) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _T_Lbrack) {
				range();
			}
			list_of_variable_port_identifiers();
		} else SynErr(270,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::output_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_output_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_output,__FUNCTION__);
		addTerminal(); 
		if (StartOf(10)) {
			if (StartOf(9)) {
				net_type();
			}
			if (la->kind == _T_signed) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _T_Lbrack) {
				range();
			}
			list_of_port_identifiers();
		} else if (la->kind == _T_logic || la->kind == _T_reg) {
			reg_();
			if (la->kind == _T_signed) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _T_Lbrack) {
				range();
			}
			list_of_variable_port_identifiers();
		} else if (la->kind == _T_integer || la->kind == _T_time) {
			output_variable_type();
			list_of_variable_port_identifiers();
		} else SynErr(271,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::module_or_generate_item() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_or_generate_item, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(11)) {
			module_or_generate_item_declaration();
		} else if (la->kind == _T_localparam) {
			local_parameter_declaration();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_defparam) {
			parameter_override();
		} else if (la->kind == _T_assign) {
			continuous_assign();
		} else if (StartOf(12)) {
			gate_instantiation();
		} else if (peek(1) == _T_Ident && peek(2) == _T_Colon ) {
			block_identifier();
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
			concurrent_assertion_statement();
		} else if (la->kind == _T_Ident) {
			module_or_udp_instantiation_();
		} else if (la->kind == _T_initial) {
			initial_construct();
		} else if (la->kind == _T_always) {
			always_construct();
		} else if (la->kind == _T_for) {
			loop_generate_construct();
		} else if (la->kind == _T_case || la->kind == _T_if) {
			conditional_generate_construct();
		} else if (StartOf(13)) {
			concurrent_assertion_statement();
		} else SynErr(272,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::module_or_generate_item_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_or_generate_item_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_supply0: case _T_supply1: case _T_tri: case _T_tri0: case _T_tri1: case _T_triand: case _T_trior: case _T_trireg: case _T_uwire: case _T_wand: case _T_wire: case _T_wor: {
			net_declaration();
			break;
		}
		case _T_logic: case _T_reg: {
			reg_declaration();
			break;
		}
		case _T_integer: {
			integer_declaration();
			break;
		}
		case _T_real: {
			real_declaration();
			break;
		}
		case _T_time: {
			time_declaration();
			break;
		}
		case _T_realtime: {
			realtime_declaration();
			break;
		}
		case _T_event: {
			event_declaration();
			break;
		}
		case _T_genvar: {
			genvar_declaration();
			break;
		}
		case _T_task: {
			task_declaration();
			break;
		}
		case _T_function: {
			function_declaration();
			break;
		}
		default: SynErr(273,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::local_parameter_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_local_parameter_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_localparam,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Lbrack || la->kind == _T_signed || la->kind == _T_Ident) {
			if (la->kind == _T_signed) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _T_Lbrack) {
				range();
			}
			list_of_param_assignments();
		} else if (StartOf(7)) {
			parameter_type();
			list_of_param_assignments();
		} else SynErr(274,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::parameter_override() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_parameter_override, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_defparam,__FUNCTION__);
		addTerminal(); 
		list_of_defparam_assignments();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::continuous_assign() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_continuous_assign, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_assign,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Lpar) {
			drive_strength();
		}
		if (la->kind == _T_Hash) {
			delay3();
		}
		list_of_net_assignments();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::gate_instantiation() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_gate_instantiation, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_cmos: case _T_rcmos: {
			cmos_switchtype();
			if (la->kind == _T_Hash) {
				delay3();
			}
			cmos_switch_instance();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				cmos_switch_instance();
			}
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_bufif0: case _T_bufif1: case _T_notif0: case _T_notif1: {
			enable_gatetype();
			if (peek(1) == _T_Lpar && ( peek(2) == _T_strong1 || peek(2) == _T_highz0 || peek(2) == _T_weak0 || peek(2) == _T_pull1 || peek(2) == _T_weak1 || peek(2) == _T_supply0 || peek(2) == _T_pull0 || peek(2) == _T_supply1 || peek(2) == _T_highz1 || peek(2) == _T_strong0 ) ) {
				drive_strength();
			}
			if (la->kind == _T_Hash) {
				delay3();
			}
			enable_gate_instance();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				enable_gate_instance();
			}
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_nmos: case _T_pmos: case _T_rnmos: case _T_rpmos: {
			mos_switchtype();
			if (la->kind == _T_Hash) {
				delay3();
			}
			mos_switch_instance();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				mos_switch_instance();
			}
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_and: case _T_nand: case _T_nor: case _T_or: case _T_xnor: case _T_xor: {
			n_input_gatetype();
			if (peek(1) == _T_Lpar && ( peek(2) == _T_strong1 || peek(2) == _T_highz0 || peek(2) == _T_weak0 || peek(2) == _T_pull1 || peek(2) == _T_weak1 || peek(2) == _T_supply0 || peek(2) == _T_pull0 || peek(2) == _T_supply1 || peek(2) == _T_highz1 || peek(2) == _T_strong0 ) ) {
				drive_strength();
			}
			if (la->kind == _T_Hash) {
				delay2();
			}
			n_input_gate_instance();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				n_input_gate_instance();
			}
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_buf: case _T_not: {
			n_output_gatetype();
			if (peek(1) == _T_Lpar && ( peek(2) == _T_strong1 || peek(2) == _T_highz0 || peek(2) == _T_weak0 || peek(2) == _T_pull1 || peek(2) == _T_weak1 || peek(2) == _T_supply0 || peek(2) == _T_pull0 || peek(2) == _T_supply1 || peek(2) == _T_highz1 || peek(2) == _T_strong0 ) ) {
				drive_strength();
			}
			if (la->kind == _T_Hash) {
				delay2();
			}
			n_output_gate_instance();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				n_output_gate_instance();
			}
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_rtranif0: case _T_rtranif1: case _T_tranif0: case _T_tranif1: {
			pass_en_switchtype();
			if (la->kind == _T_Hash) {
				delay2();
			}
			pass_enable_switch_instance();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				pass_enable_switch_instance();
			}
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_rtran: case _T_tran: {
			pass_switchtype();
			pass_switch_instance();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				pass_switch_instance();
			}
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_pulldown: {
			Get();
			addTerminal(); 
			if (peek(1) == _T_Lpar && ( peek(2) == _T_strong1 || peek(2) == _T_weak0 || peek(2) == _T_pull1 || peek(2) == _T_weak1 || peek(2) == _T_supply0 || peek(2) == _T_pull0 || peek(2) == _T_supply1 || peek(2) == _T_strong0 ) ) {
				pulldown_strength();
			}
			pull_gate_instance();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				pull_gate_instance();
			}
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_pullup: {
			Get();
			addTerminal(); 
			if (peek(1) == _T_Lpar && ( peek(2) == _T_strong1 || peek(2) == _T_weak0 || peek(2) == _T_pull1 || peek(2) == _T_weak1 || peek(2) == _T_supply0 || peek(2) == _T_pull0 || peek(2) == _T_supply1 || peek(2) == _T_strong0 ) ) {
				pullup_strength();
			}
			pull_gate_instance();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				pull_gate_instance();
			}
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		default: SynErr(275,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::block_identifier() {
		identifier();
}

void Parser::concurrent_assertion_statement() {
		if (peek(1) == _T_cover && peek(2) == _T_sequence ) {
			cover_sequence_statement();
		} else if (la->kind == _T_assert || la->kind == _T_assume || la->kind == _T_cover) {
			immediate_assertion_statement_();
		} else if (la->kind == _T_restrict) {
			restrict_property_statement();
		} else SynErr(276,__FUNCTION__);
}

void Parser::module_or_udp_instantiation_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_or_udp_instantiation_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		if (peek(1) == _T_Lpar && ( peek(2) == _T_strong1 || peek(2) == _T_highz0 || peek(2) == _T_weak0 || peek(2) == _T_pull1 || peek(2) == _T_weak1 || peek(2) == _T_supply0 || peek(2) == _T_pull0 || peek(2) == _T_supply1 || peek(2) == _T_highz1 || peek(2) == _T_strong0 ) ) {
			drive_strength();
		}
		if (la->kind == _T_Hash) {
			parameter_value_assignment_or_delay2_();
		}
		module_or_udp_instance_();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			module_or_udp_instance_();
		}
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::initial_construct() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_initial_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_initial,__FUNCTION__);
		addTerminal(); 
		statement();
		d_stack.pop(); 
}

void Parser::always_construct() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_always_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_always,__FUNCTION__);
		addTerminal(); 
		statement();
		d_stack.pop(); 
}

void Parser::loop_generate_construct() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_loop_generate_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_for,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		genvar_initialization();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		genvar_expression();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		genvar_iteration();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_begin) {
			generate_block();
		} else if (StartOf(6)) {
			module_or_generate_item();
		} else SynErr(277,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::conditional_generate_construct() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_conditional_generate_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_if) {
			if_generate_construct();
		} else if (la->kind == _T_case) {
			case_generate_construct();
		} else SynErr(278,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::net_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_net_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(9)) {
			net_type();
			if (peek(1) == _T_Lpar && ( peek(2) == _T_strong1 || peek(2) == _T_highz0 || peek(2) == _T_weak0 || peek(2) == _T_pull1 || peek(2) == _T_weak1 || peek(2) == _T_supply0 || peek(2) == _T_pull0 || peek(2) == _T_supply1 || peek(2) == _T_highz1 || peek(2) == _T_strong0 ) ) {
				drive_strength();
			}
			if (la->kind == _T_scalared || la->kind == _T_vectored) {
				if (la->kind == _T_vectored) {
					Get();
					addTerminal(); 
				} else {
					Get();
					addTerminal(); 
				}
			}
			if (la->kind == _T_signed) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _T_Lbrack) {
				range();
			}
			if (la->kind == _T_Hash) {
				delay3();
			}
			list_of_net_identifiers_of_decl_assignments_();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_trireg) {
			Get();
			addTerminal(); 
			if (peek(1) == _T_Lpar && ( peek(2) == _T_large || peek(2) == _T_small || peek(2) == _T_medium ) ) {
				charge_strength();
			}
			if (la->kind == _T_scalared || la->kind == _T_vectored) {
				if (la->kind == _T_vectored) {
					Get();
					addTerminal(); 
				} else {
					Get();
					addTerminal(); 
				}
			}
			if (la->kind == _T_signed) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _T_Lbrack) {
				range();
			}
			if (la->kind == _T_Hash) {
				delay3();
			}
			list_of_net_identifiers_of_decl_assignments_();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		} else SynErr(279,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::reg_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_reg_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		reg_();
		if (la->kind == _T_signed) {
			Get();
			addTerminal(); 
		}
		if (la->kind == _T_Lbrack) {
			range();
		}
		list_of_variable_identifiers();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::integer_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_integer_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_integer,__FUNCTION__);
		addTerminal(); 
		list_of_variable_identifiers();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::real_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_real_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_real,__FUNCTION__);
		addTerminal(); 
		list_of_real_identifiers();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::time_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_time_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_time,__FUNCTION__);
		addTerminal(); 
		list_of_variable_identifiers();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::realtime_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_realtime_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_realtime,__FUNCTION__);
		addTerminal(); 
		list_of_real_identifiers();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::event_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_event_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_event,__FUNCTION__);
		addTerminal(); 
		list_of_event_identifiers();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::genvar_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_genvar_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_genvar,__FUNCTION__);
		addTerminal(); 
		list_of_genvar_identifiers();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::task_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_task_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_task,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_automatic) {
			Get();
			addTerminal(); 
		}
		task_identifier();
		if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			if (la->kind == _T_inout || la->kind == _T_input || la->kind == _T_output) {
				task_port_list();
			}
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		}
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		while (StartOf(14)) {
			task_item_declaration();
		}
		statement_or_null();
		Expect(_T_endtask,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::function_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_function_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_function,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_automatic) {
			Get();
			addTerminal(); 
		}
		if (StartOf(15)) {
			function_range_or_type();
		}
		function_identifier();
		if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			function_port_list();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		}
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		while (StartOf(16)) {
			if (StartOf(17)) {
				block_item_declaration();
			} else {
				tf_input_declaration();
				Expect(_T_Semi,__FUNCTION__);
				addTerminal(); 
			}
		}
		function_statement();
		Expect(_T_endfunction,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::generate_region() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_generate_region, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_generate,__FUNCTION__);
		addTerminal(); 
		while (StartOf(6)) {
			module_or_generate_item();
		}
		Expect(_T_endgenerate,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::specify_block() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specify_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_specify,__FUNCTION__);
		addTerminal(); 
		while (StartOf(18)) {
			specify_item();
		}
		Expect(_T_endspecify,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::specparam_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specparam_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_specparam,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Lbrack) {
			range();
		}
		list_of_specparam_assignments();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::list_of_defparam_assignments() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_defparam_assignments, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		defparam_assignment();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			defparam_assignment();
		}
		d_stack.pop(); 
}

void Parser::config_identifier() {
		identifier();
}

void Parser::design_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_design_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_design,__FUNCTION__);
		addTerminal(); 
		while (la->kind == _T_Ident) {
			if (peek(1) == _T_Ident && peek(2) == _T_Dot ) {
				library_identifier();
				Expect(_T_Dot,__FUNCTION__);
				addTerminal(); 
			}
			cell_identifier();
		}
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::config_rule_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_config_rule_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_default) {
			default_clause();
			liblist_clause();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_instance) {
			inst_clause();
			if (la->kind == _T_liblist) {
				liblist_clause();
			} else if (la->kind == _T_use) {
				use_clause();
			} else SynErr(280,__FUNCTION__);
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_cell) {
			cell_clause();
			if (la->kind == _T_liblist) {
				liblist_clause();
			} else if (la->kind == _T_use) {
				use_clause();
			} else SynErr(281,__FUNCTION__);
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		} else SynErr(282,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::cell_identifier() {
		identifier();
}

void Parser::default_clause() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_default_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_default,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::liblist_clause() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_liblist_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_liblist,__FUNCTION__);
		addTerminal(); 
		while (la->kind == _T_Ident) {
			library_identifier();
		}
		d_stack.pop(); 
}

void Parser::inst_clause() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_inst_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_instance,__FUNCTION__);
		addTerminal(); 
		inst_name();
		d_stack.pop(); 
}

void Parser::use_clause() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_use_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_use,__FUNCTION__);
		addTerminal(); 
		if (peek(1) == _T_Ident && peek(2) == _T_Dot ) {
			library_identifier();
			Expect(_T_Dot,__FUNCTION__);
			addTerminal(); 
		}
		cell_identifier();
		if (la->kind == _T_Colon) {
			Get();
			addTerminal(); 
			Expect(_T_config,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::cell_clause() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_cell_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_cell,__FUNCTION__);
		addTerminal(); 
		if (peek(1) == _T_Ident && peek(2) == _T_Dot ) {
			library_identifier();
			Expect(_T_Dot,__FUNCTION__);
			addTerminal(); 
		}
		cell_identifier();
		d_stack.pop(); 
}

void Parser::inst_name() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_inst_name, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		topmodule_identifier();
		while (la->kind == _T_Dot) {
			Get();
			addTerminal(); 
			instance_identifier();
		}
		d_stack.pop(); 
}

void Parser::topmodule_identifier() {
		identifier();
}

void Parser::instance_identifier() {
		identifier();
}

void Parser::range() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_range, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lbrack,__FUNCTION__);
		addTerminal(); 
		msb_constant_expression();
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		lsb_constant_expression();
		Expect(_T_Rbrack,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::list_of_param_assignments() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_param_assignments, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		param_assignment();
		while (peek(1) == _T_Comma && peek(2) == _T_Ident ) {
			Expect(_T_Comma,__FUNCTION__);
			addTerminal(); 
			param_assignment();
		}
		d_stack.pop(); 
}

void Parser::parameter_type() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_parameter_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_integer) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_real) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_realtime) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_time) {
			Get();
			addTerminal(); 
		} else SynErr(283,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::list_of_specparam_assignments() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_specparam_assignments, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		specparam_assignment();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			specparam_assignment();
		}
		d_stack.pop(); 
}

void Parser::net_type() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_net_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_supply0: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_supply1: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_tri: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_triand: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_trior: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_tri0: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_tri1: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_uwire: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_wire: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_wand: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_wor: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(284,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::list_of_port_identifiers() {
		port_identifier();
		while (peek(1) == _T_Comma && peek(2) == _T_Ident ) {
			Expect(_T_Comma,__FUNCTION__);
			addTerminal(); 
			port_identifier();
		}
}

void Parser::reg_() {
		if (la->kind == _T_reg) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_logic) {
			Get();
			addTerminal(); 
		} else SynErr(285,__FUNCTION__);
}

void Parser::list_of_variable_port_identifiers() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_variable_port_identifiers, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		port_identifier();
		if (la->kind == _T_Eq) {
			Get();
			addTerminal(); 
			constant_expression();
		}
		while (peek(1) == _T_Comma && peek(2) == _T_Ident ) {
			Expect(_T_Comma,__FUNCTION__);
			addTerminal(); 
			port_identifier();
			if (la->kind == _T_Eq) {
				Get();
				addTerminal(); 
				constant_expression();
			}
		}
		d_stack.pop(); 
}

void Parser::output_variable_type() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_output_variable_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_integer) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_time) {
			Get();
			addTerminal(); 
		} else SynErr(286,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::list_of_event_identifiers() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_event_identifiers, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		event_identifier();
		while (la->kind == _T_Lbrack) {
			dimension();
		}
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			event_identifier();
			while (la->kind == _T_Lbrack) {
				dimension();
			}
		}
		d_stack.pop(); 
}

void Parser::list_of_variable_identifiers() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_variable_identifiers, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		variable_type();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			variable_type();
		}
		d_stack.pop(); 
}

void Parser::drive_strength() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_drive_strength, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (StartOf(19)) {
			strength0();
		} else if (StartOf(20)) {
			strength1();
		} else if (la->kind == _T_highz0) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_highz1) {
			Get();
			addTerminal(); 
		} else SynErr(287,__FUNCTION__);
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		if (StartOf(20)) {
			strength1();
		} else if (StartOf(19)) {
			strength0();
		} else if (la->kind == _T_highz1) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_highz0) {
			Get();
			addTerminal(); 
		} else SynErr(288,__FUNCTION__);
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::delay3() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_delay3, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Hash,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Realnum || la->kind == _T_Natural || la->kind == _T_Ident) {
			delay_value();
		} else if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			mintypmax_expression();
			if (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				mintypmax_expression();
				if (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					mintypmax_expression();
				}
			}
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		} else SynErr(289,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::list_of_net_identifiers_of_decl_assignments_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_net_identifiers_of_decl_assignments_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		net_identifier();
		if (la->kind == _T_Comma || la->kind == _T_Semi || la->kind == _T_Lbrack) {
			while (la->kind == _T_Lbrack) {
				dimension();
			}
		} else if (la->kind == _T_Eq) {
			Get();
			addTerminal(); 
			expression();
		} else SynErr(290,__FUNCTION__);
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			net_identifier();
			if (la->kind == _T_Comma || la->kind == _T_Semi || la->kind == _T_Lbrack) {
				while (la->kind == _T_Lbrack) {
					dimension();
				}
			} else if (la->kind == _T_Eq) {
				Get();
				addTerminal(); 
				expression();
			} else SynErr(291,__FUNCTION__);
		}
		d_stack.pop(); 
}

void Parser::charge_strength() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_charge_strength, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_small) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_medium) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_large) {
			Get();
			addTerminal(); 
		} else SynErr(292,__FUNCTION__);
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::net_identifier() {
		identifier();
}

void Parser::dimension() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dimension, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lbrack,__FUNCTION__);
		addTerminal(); 
		dimension_constant_expression();
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		dimension_constant_expression();
		Expect(_T_Rbrack,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(21)) {
			primary();
			expression_nlr_();
		} else if (StartOf(22)) {
			unary_operator();
			primary();
			expression_nlr_();
		} else SynErr(293,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::list_of_real_identifiers() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_real_identifiers, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		real_type();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			real_type();
		}
		d_stack.pop(); 
}

void Parser::real_type() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_real_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		real_identifier();
		if (la->kind == _T_Comma || la->kind == _T_Semi || la->kind == _T_Lbrack) {
			while (la->kind == _T_Lbrack) {
				dimension();
			}
		} else if (la->kind == _T_Eq) {
			Get();
			addTerminal(); 
			constant_expression();
		} else SynErr(294,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::real_identifier() {
		identifier();
}

void Parser::constant_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_constant_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}

void Parser::variable_type() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_variable_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		variable_identifier();
		if (la->kind == _T_Comma || la->kind == _T_Semi || la->kind == _T_Lbrack) {
			while (la->kind == _T_Lbrack) {
				dimension();
			}
		} else if (la->kind == _T_Eq) {
			Get();
			addTerminal(); 
			constant_expression();
		} else SynErr(295,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::variable_identifier() {
		identifier();
}

void Parser::strength0() {
		if (la->kind == _T_supply0) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_strong0) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_pull0) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_weak0) {
			Get();
			addTerminal(); 
		} else SynErr(296,__FUNCTION__);
}

void Parser::strength1() {
		if (la->kind == _T_supply1) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_strong1) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_pull1) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_weak1) {
			Get();
			addTerminal(); 
		} else SynErr(297,__FUNCTION__);
}

void Parser::delay_value() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_delay_value, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Natural) {
			unsigned_number();
		} else if (la->kind == _T_Realnum) {
			real_number();
		} else if (la->kind == _T_Ident) {
			identifier();
		} else SynErr(298,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::mintypmax_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_mintypmax_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		if (la->kind == _T_Colon) {
			Get();
			addTerminal(); 
			expression();
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
			expression();
		}
		d_stack.pop(); 
}

void Parser::delay2() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_delay2, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Hash,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Realnum || la->kind == _T_Natural || la->kind == _T_Ident) {
			delay_value();
		} else if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			mintypmax_expression();
			if (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				mintypmax_expression();
			}
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		} else SynErr(299,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::unsigned_number() {
		Expect(_T_Natural,__FUNCTION__);
		addTerminal(); 
}

void Parser::real_number() {
		Expect(_T_Realnum,__FUNCTION__);
		addTerminal(); 
}

void Parser::defparam_assignment() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_defparam_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		hierarchical_parameter_identifier();
		Expect(_T_Eq,__FUNCTION__);
		addTerminal(); 
		constant_mintypmax_expression();
		d_stack.pop(); 
}

void Parser::event_identifier() {
		identifier();
}

void Parser::param_assignment() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_param_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		parameter_identifier();
		Expect(_T_Eq,__FUNCTION__);
		addTerminal(); 
		constant_mintypmax_expression();
		d_stack.pop(); 
}

void Parser::specparam_assignment() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specparam_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Ident) {
			specparam_identifier();
			Expect(_T_Eq,__FUNCTION__);
			addTerminal(); 
			constant_mintypmax_expression();
		} else if (la->kind == _T_PATHPULSE_dlr) {
			pulse_control_specparam();
		} else SynErr(300,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::hierarchical_parameter_identifier() {
		hierarchical_identifier();
}

void Parser::constant_mintypmax_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_constant_mintypmax_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		mintypmax_expression();
		d_stack.pop(); 
}

void Parser::parameter_identifier() {
		identifier();
}

void Parser::specparam_identifier() {
		identifier();
}

void Parser::pulse_control_specparam() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pulse_control_specparam, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_PATHPULSE_dlr,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Eq,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		reject_limit_value();
		if (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			error_limit_value();
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Eq,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		reject_limit_value();
		if (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			error_limit_value();
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::reject_limit_value() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_reject_limit_value, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		limit_value();
		d_stack.pop(); 
}

void Parser::error_limit_value() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_error_limit_value, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		limit_value();
		d_stack.pop(); 
}

void Parser::limit_value() {
		constant_mintypmax_expression();
}

void Parser::dimension_constant_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dimension_constant_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		constant_expression();
		d_stack.pop(); 
}

void Parser::msb_constant_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_msb_constant_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		constant_expression();
		d_stack.pop(); 
}

void Parser::lsb_constant_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_lsb_constant_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		constant_expression();
		d_stack.pop(); 
}

void Parser::function_range_or_type() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_function_range_or_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Lbrack || la->kind == _T_signed || la->kind == _T_Ident) {
			if (la->kind == _T_signed) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _T_Lbrack) {
				range();
			}
		} else if (la->kind == _T_integer) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_real) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_realtime) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_time) {
			Get();
			addTerminal(); 
		} else SynErr(301,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::function_identifier() {
		identifier();
}

void Parser::function_port_list() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_function_port_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		tf_input_declaration();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			tf_input_declaration();
		}
		d_stack.pop(); 
}

void Parser::block_item_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_item_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_logic: case _T_reg: {
			reg_();
			if (la->kind == _T_signed) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _T_Lbrack) {
				range();
			}
			list_of_block_variable_identifiers();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_integer: {
			Get();
			addTerminal(); 
			list_of_block_variable_identifiers();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_time: {
			Get();
			addTerminal(); 
			list_of_block_variable_identifiers();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_real: {
			Get();
			addTerminal(); 
			list_of_block_real_identifiers();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_realtime: {
			Get();
			addTerminal(); 
			list_of_block_real_identifiers();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_event: {
			event_declaration();
			break;
		}
		case _T_localparam: {
			local_parameter_declaration();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_parameter: {
			parameter_declaration();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		default: SynErr(302,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::tf_input_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_tf_input_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_input,__FUNCTION__);
		addTerminal(); 
		if (StartOf(23)) {
			if (la->kind == _T_logic || la->kind == _T_reg) {
				reg_();
			}
			if (la->kind == _T_signed) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _T_Lbrack) {
				range();
			}
			list_of_port_identifiers();
		} else if (StartOf(7)) {
			task_port_type();
			list_of_port_identifiers();
		} else SynErr(303,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::function_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_function_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		statement();
		d_stack.pop(); 
}

void Parser::task_identifier() {
		identifier();
}

void Parser::task_port_list() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_task_port_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		task_port_item();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			task_port_item();
		}
		d_stack.pop(); 
}

void Parser::task_item_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_task_item_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(17)) {
			block_item_declaration();
		} else if (la->kind == _T_input) {
			tf_input_declaration();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_output) {
			tf_output_declaration();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_inout) {
			tf_inout_declaration();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		} else SynErr(304,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::statement_or_null() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_statement_or_null, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(24)) {
			statement();
		} else if (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
		} else SynErr(305,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::tf_output_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_tf_output_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_output,__FUNCTION__);
		addTerminal(); 
		if (StartOf(23)) {
			if (la->kind == _T_logic || la->kind == _T_reg) {
				reg_();
			}
			if (la->kind == _T_signed) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _T_Lbrack) {
				range();
			}
			list_of_port_identifiers();
		} else if (StartOf(7)) {
			task_port_type();
			list_of_port_identifiers();
		} else SynErr(306,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::tf_inout_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_tf_inout_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_inout,__FUNCTION__);
		addTerminal(); 
		if (StartOf(23)) {
			if (la->kind == _T_logic || la->kind == _T_reg) {
				reg_();
			}
			if (la->kind == _T_signed) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _T_Lbrack) {
				range();
			}
			list_of_port_identifiers();
		} else if (StartOf(7)) {
			task_port_type();
			list_of_port_identifiers();
		} else SynErr(307,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::task_port_item() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_task_port_item, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_input) {
			tf_input_declaration();
		} else if (la->kind == _T_output) {
			tf_output_declaration();
		} else if (la->kind == _T_inout) {
			tf_inout_declaration();
		} else SynErr(308,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::task_port_type() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_task_port_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_integer) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_real) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_realtime) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_time) {
			Get();
			addTerminal(); 
		} else SynErr(309,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::list_of_block_variable_identifiers() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_block_variable_identifiers, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		block_variable_type();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			block_variable_type();
		}
		d_stack.pop(); 
}

void Parser::list_of_block_real_identifiers() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_block_real_identifiers, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		block_real_type();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			block_real_type();
		}
		d_stack.pop(); 
}

void Parser::block_variable_type() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_variable_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		variable_identifier();
		while (la->kind == _T_Lbrack) {
			dimension();
		}
		d_stack.pop(); 
}

void Parser::block_real_type() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_real_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		real_identifier();
		while (la->kind == _T_Lbrack) {
			dimension();
		}
		d_stack.pop(); 
}

void Parser::cmos_switchtype() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_cmos_switchtype, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_cmos) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_rcmos) {
			Get();
			addTerminal(); 
		} else SynErr(310,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::cmos_switch_instance() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_cmos_switch_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Ident) {
			name_of_gate_instance();
		}
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		output_terminal();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		input_terminal();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		ncontrol_terminal();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		pcontrol_terminal();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::enable_gatetype() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_enable_gatetype, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_bufif0) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_bufif1) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_notif0) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_notif1) {
			Get();
			addTerminal(); 
		} else SynErr(311,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::enable_gate_instance() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_enable_gate_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Ident) {
			name_of_gate_instance();
		}
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		output_terminal();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		input_terminal();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		enable_terminal();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::mos_switchtype() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_mos_switchtype, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_nmos) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_pmos) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_rnmos) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_rpmos) {
			Get();
			addTerminal(); 
		} else SynErr(312,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::mos_switch_instance() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_mos_switch_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Ident) {
			name_of_gate_instance();
		}
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		output_terminal();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		input_terminal();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		enable_terminal();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::n_input_gatetype() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_n_input_gatetype, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_and: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_nand: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_or: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_nor: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_xor: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_xnor: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(313,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::n_input_gate_instance() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_n_input_gate_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Ident) {
			name_of_gate_instance();
		}
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		output_terminal();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		input_terminal();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			input_terminal();
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::n_output_gatetype() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_n_output_gatetype, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_buf) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_not) {
			Get();
			addTerminal(); 
		} else SynErr(314,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::n_output_gate_instance() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_n_output_gate_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Ident) {
			name_of_gate_instance();
		}
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		expression();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		expression();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			expression();
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::pass_en_switchtype() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pass_en_switchtype, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_tranif0) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_tranif1) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_rtranif1) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_rtranif0) {
			Get();
			addTerminal(); 
		} else SynErr(315,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::pass_enable_switch_instance() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pass_enable_switch_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Ident) {
			name_of_gate_instance();
		}
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		inout_terminal();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		inout_terminal();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		enable_terminal();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::pass_switchtype() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pass_switchtype, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_tran) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_rtran) {
			Get();
			addTerminal(); 
		} else SynErr(316,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::pass_switch_instance() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pass_switch_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Ident) {
			name_of_gate_instance();
		}
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		inout_terminal();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		inout_terminal();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::pulldown_strength() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pulldown_strength, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (StartOf(19)) {
			strength0();
		} else if (StartOf(20)) {
			strength1();
		} else SynErr(317,__FUNCTION__);
		if (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			if (StartOf(20)) {
				strength1();
			} else if (StartOf(19)) {
				strength0();
			} else SynErr(318,__FUNCTION__);
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::pull_gate_instance() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pull_gate_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Ident) {
			name_of_gate_instance();
		}
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		output_terminal();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::pullup_strength() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pullup_strength, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (StartOf(19)) {
			strength0();
		} else if (StartOf(20)) {
			strength1();
		} else SynErr(319,__FUNCTION__);
		if (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			if (StartOf(20)) {
				strength1();
			} else if (StartOf(19)) {
				strength0();
			} else SynErr(320,__FUNCTION__);
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::name_of_gate_instance() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_name_of_gate_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		gate_instance_identifier();
		if (la->kind == _T_Lbrack) {
			range();
		}
		d_stack.pop(); 
}

void Parser::output_terminal() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_output_terminal, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		net_lvalue();
		d_stack.pop(); 
}

void Parser::input_terminal() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_input_terminal, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}

void Parser::ncontrol_terminal() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_ncontrol_terminal, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}

void Parser::pcontrol_terminal() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pcontrol_terminal, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}

void Parser::enable_terminal() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_enable_terminal, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}

void Parser::inout_terminal() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_inout_terminal, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		net_lvalue();
		d_stack.pop(); 
}

void Parser::gate_instance_identifier() {
		identifier();
}

void Parser::net_lvalue() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_net_lvalue, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Ident) {
			hierarchical_net_identifier();
			while (la->kind == _T_Lbrack) {
				Get();
				addTerminal(); 
				constant_range_expression();
				Expect(_T_Rbrack,__FUNCTION__);
				addTerminal(); 
			}
		} else if (la->kind == _T_Lbrace) {
			Get();
			addTerminal(); 
			net_lvalue();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				net_lvalue();
			}
			Expect(_T_Rbrace,__FUNCTION__);
			addTerminal(); 
		} else SynErr(321,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::named_parameter_assignment() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_named_parameter_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Dot,__FUNCTION__);
		addTerminal(); 
		parameter_identifier();
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (StartOf(25)) {
			mintypmax_expression();
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::parameter_value_assignment_or_delay2_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_parameter_value_assignment_or_delay2_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Hash,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Realnum || la->kind == _T_Natural || la->kind == _T_Ident) {
			delay_value();
		}
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (StartOf(25)) {
			mintypmax_expression();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				mintypmax_expression();
			}
		} else if (la->kind == _T_Dot) {
			named_parameter_assignment();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				named_parameter_assignment();
			}
		} else SynErr(322,__FUNCTION__);
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::module_or_udp_instance_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_or_udp_instance_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Ident) {
			identifier();
		}
		if (la->kind == _T_Lbrack) {
			range();
		}
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (StartOf(26)) {
			port_connection_or_output_terminal_();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				port_connection_or_output_terminal_();
			}
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::port_connection_or_output_terminal_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_port_connection_or_output_terminal_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Dot) {
			Get();
			addTerminal(); 
			port_identifier();
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
			if (StartOf(25)) {
				expression();
			}
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		} else if (StartOf(27)) {
			if (StartOf(25)) {
				expression();
			}
		} else SynErr(323,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::list_of_genvar_identifiers() {
		genvar_identifier();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			genvar_identifier();
		}
}

void Parser::genvar_identifier() {
		identifier();
}

void Parser::genvar_initialization() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_genvar_initialization, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		genvar_identifier();
		Expect(_T_Eq,__FUNCTION__);
		addTerminal(); 
		constant_expression();
		d_stack.pop(); 
}

void Parser::genvar_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_genvar_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(21)) {
			genvar_primary();
			genvar_expression_nlr_();
		} else if (StartOf(22)) {
			unary_operator();
			genvar_primary();
			genvar_expression_nlr_();
		} else SynErr(324,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::genvar_iteration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_genvar_iteration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		genvar_identifier();
		Expect(_T_Eq,__FUNCTION__);
		addTerminal(); 
		genvar_expression();
		d_stack.pop(); 
}

void Parser::generate_block() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_generate_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_begin,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Colon) {
			Get();
			addTerminal(); 
			generate_block_identifier();
		}
		while (StartOf(6)) {
			module_or_generate_item();
		}
		Expect(_T_end,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::genvar_primary() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_genvar_primary, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		primary();
		d_stack.pop(); 
}

void Parser::genvar_expression_nlr_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_genvar_expression_nlr_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(28)) {
			if (StartOf(29)) {
				binary_operator();
				genvar_expression();
				genvar_expression_nlr_();
			} else {
				Get();
				addTerminal(); 
				genvar_expression();
				Expect(_T_Colon,__FUNCTION__);
				addTerminal(); 
				genvar_expression();
				genvar_expression_nlr_();
			}
		}
		d_stack.pop(); 
}

void Parser::unary_operator() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_unary_operator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Plus: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Minus: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Bang: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Tilde: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Amp: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_TildeAmp: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Bar: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_TildeBar: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Hat: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_TildeHat: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_HatTilde: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(325,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::binary_operator() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_binary_operator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Plus: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Minus: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Star: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Slash: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Percent: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_2Eq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_BangEq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_3Eq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Bang2Eq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_2Amp: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_2Bar: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_2Star: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Lt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Leq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Gt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Geq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Amp: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Bar: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Hat: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_HatTilde: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_TildeHat: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_2Gt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_2Lt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_3Gt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_3Lt: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(326,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::primary() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_primary, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Realnum: case _T_Natural: case _T_SizedBased: case _T_BasedInt: case _T_BaseFormat: {
			number();
			break;
		}
		case _T_Ident: {
			rvalue_or_function_call_();
			break;
		}
		case _T_Lbrace: {
			single_or_multiple_concatenation_();
			break;
		}
		case _T_SysName: {
			system_function_call();
			break;
		}
		case _T_Lpar: {
			Get();
			addTerminal(); 
			mintypmax_expression();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				path_delay_expression();
			}
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_Str: {
			string();
			break;
		}
		default: SynErr(327,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::if_generate_construct() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_if_generate_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_if,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		constant_expression();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		generate_block_or_null();
		if (la->kind == _T_else) {
			Get();
			addTerminal(); 
			generate_block_or_null();
		}
		d_stack.pop(); 
}

void Parser::case_generate_construct() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_case_generate_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_case,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		constant_expression();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		case_generate_item();
		while (StartOf(30)) {
			case_generate_item();
		}
		Expect(_T_endcase,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::generate_block_or_null() {
		if (la->kind == _T_begin) {
			generate_block();
		} else if (StartOf(6)) {
			module_or_generate_item();
		} else if (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
		} else SynErr(328,__FUNCTION__);
}

void Parser::case_generate_item() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_case_generate_item, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(25)) {
			constant_expression();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				constant_expression();
			}
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
			generate_block_or_null();
		} else if (la->kind == _T_default) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Colon) {
				Get();
				addTerminal(); 
			}
			generate_block_or_null();
		} else SynErr(329,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::generate_block_identifier() {
		identifier();
}

void Parser::udp_identifier() {
		identifier();
}

void Parser::udp_port_list() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_port_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		output_port_identifier();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		input_port_identifier();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			input_port_identifier();
		}
		d_stack.pop(); 
}

void Parser::udp_declaration_port_list() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_declaration_port_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		udp_output_declaration();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		udp_input_declaration();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			udp_input_declaration();
		}
		d_stack.pop(); 
}

void Parser::udp_port_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_port_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_output) {
			udp_output_declaration();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_input) {
			udp_input_declaration();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_logic || la->kind == _T_reg) {
			udp_reg_declaration();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		} else SynErr(330,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::udp_body() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_body, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_initial) {
			udp_initial_statement();
		}
		Expect(_T_table,__FUNCTION__);
		addTerminal(); 
		udp_body_entry_();
		while (StartOf(31)) {
			udp_body_entry_();
		}
		Expect(_T_endtable,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::output_port_identifier() {
		identifier();
}

void Parser::input_port_identifier() {
		identifier();
}

void Parser::udp_output_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_output_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_output,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_logic || la->kind == _T_reg) {
			reg_();
		}
		port_identifier();
		if (la->kind == _T_Eq) {
			Get();
			addTerminal(); 
			constant_expression();
		}
		d_stack.pop(); 
}

void Parser::udp_input_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_input_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_input,__FUNCTION__);
		addTerminal(); 
		list_of_port_identifiers();
		d_stack.pop(); 
}

void Parser::udp_reg_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_reg_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		reg_();
		variable_identifier();
		d_stack.pop(); 
}

void Parser::udp_initial_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_initial_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_initial,__FUNCTION__);
		addTerminal(); 
		output_port_identifier();
		Expect(_T_Eq,__FUNCTION__);
		addTerminal(); 
		init_val();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::udp_body_entry_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_body_entry_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		while (StartOf(32)) {
			if (StartOf(33)) {
				entry_symbol_();
			} else {
				Get();
				addTerminal(); 
				entry_symbol_();
				if (StartOf(33)) {
					entry_symbol_();
				}
				Expect(_T_Rpar,__FUNCTION__);
				addTerminal(); 
			}
		}
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		if (StartOf(33)) {
			entry_symbol_();
		} else if (la->kind == _T_Minus) {
			Get();
			addTerminal(); 
		} else SynErr(331,__FUNCTION__);
		if (la->kind == _T_Colon) {
			Get();
			addTerminal(); 
			if (StartOf(33)) {
				entry_symbol_();
			} else if (la->kind == _T_Minus) {
				Get();
				addTerminal(); 
			} else SynErr(332,__FUNCTION__);
		}
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::entry_symbol_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_entry_symbol_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(34)) {
			number();
		} else if (la->kind == _T_Ident) {
			identifier();
		} else if (la->kind == _T_Qmark) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Star) {
			Get();
			addTerminal(); 
		} else SynErr(333,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::number() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_number, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Realnum) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Natural) {
			Get();
			addTerminal(); 
			if (la->kind == _T_BasedInt || la->kind == _T_BaseFormat) {
				if (la->kind == _T_BasedInt) {
					Get();
					addTerminal(); 
				} else {
					Get();
					addTerminal(); 
					if (la->kind == _T_BaseValue) {
						Get();
						addTerminal(); 
					} else if (la->kind == _T_Natural) {
						Get();
						addTerminal(); 
					} else SynErr(334,__FUNCTION__);
				}
			}
		} else if (la->kind == _T_SizedBased) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_BasedInt) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_BaseFormat) {
			Get();
			addTerminal(); 
			if (la->kind == _T_BaseValue) {
				Get();
				addTerminal(); 
			} else if (la->kind == _T_Natural) {
				Get();
				addTerminal(); 
			} else SynErr(335,__FUNCTION__);
		} else SynErr(336,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::init_val() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_init_val, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		number();
		d_stack.pop(); 
}

void Parser::list_of_net_assignments() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_net_assignments, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		net_assignment();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			net_assignment();
		}
		d_stack.pop(); 
}

void Parser::net_assignment() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_net_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		net_lvalue();
		Expect(_T_Eq,__FUNCTION__);
		addTerminal(); 
		expression();
		d_stack.pop(); 
}

void Parser::statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Lbrace: case _T_Ident: {
			assignment_or_task_enable_();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_case: case _T_casex: case _T_casez: {
			case_statement();
			break;
		}
		case _T_if: {
			conditional_statement();
			break;
		}
		case _T_disable: {
			disable_statement();
			break;
		}
		case _T_MinusGt: {
			event_trigger();
			break;
		}
		case _T_for: case _T_forever: case _T_repeat: case _T_while: {
			loop_statement();
			break;
		}
		case _T_fork: {
			par_block();
			break;
		}
		case _T_assign: case _T_deassign: case _T_force: case _T_release: {
			procedural_continuous_assignments();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_Hash: case _T_At: {
			procedural_timing_control_statement();
			break;
		}
		case _T_begin: {
			seq_block();
			break;
		}
		case _T_SysName: {
			system_task_enable();
			break;
		}
		case _T_wait: {
			wait_statement();
			break;
		}
		case _T_assert: case _T_assume: case _T_cover: case _T_restrict: {
			procedural_assertion_statement();
			break;
		}
		default: SynErr(337,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::assignment_or_task_enable_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_assignment_or_task_enable_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		variable_lvalue();
		if (la->kind == _T_Leq || la->kind == _T_Eq) {
			if (la->kind == _T_Eq) {
				Get();
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
			}
			if (la->kind == _T_Hash || la->kind == _T_At || la->kind == _T_repeat) {
				delay_or_event_control();
			}
			expression();
		} else if (la->kind == _T_Lpar || la->kind == _T_Semi) {
			if (la->kind == _T_Lpar) {
				Get();
				addTerminal(); 
				expression();
				while (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					expression();
				}
				Expect(_T_Rpar,__FUNCTION__);
				addTerminal(); 
			}
		} else SynErr(338,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::variable_lvalue() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_variable_lvalue, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Ident) {
			hierarchical_variable_identifier();
			while (la->kind == _T_Lbrack) {
				Get();
				addTerminal(); 
				range_expression();
				Expect(_T_Rbrack,__FUNCTION__);
				addTerminal(); 
			}
		} else if (la->kind == _T_Lbrace) {
			Get();
			addTerminal(); 
			variable_lvalue();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				variable_lvalue();
			}
			Expect(_T_Rbrace,__FUNCTION__);
			addTerminal(); 
		} else SynErr(339,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::delay_or_event_control() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_delay_or_event_control, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Hash) {
			delay_control();
		} else if (la->kind == _T_At) {
			event_control();
		} else if (la->kind == _T_repeat) {
			Get();
			addTerminal(); 
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
			expression();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			event_control();
		} else SynErr(340,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::procedural_continuous_assignments() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_procedural_continuous_assignments, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_assign) {
			Get();
			addTerminal(); 
			assignment_();
		} else if (la->kind == _T_deassign) {
			Get();
			addTerminal(); 
			lvalue_();
		} else if (la->kind == _T_force) {
			Get();
			addTerminal(); 
			assignment_();
		} else if (la->kind == _T_release) {
			Get();
			addTerminal(); 
			lvalue_();
		} else SynErr(341,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::assignment_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_assignment_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		lvalue_();
		Expect(_T_Eq,__FUNCTION__);
		addTerminal(); 
		expression();
		d_stack.pop(); 
}

void Parser::lvalue_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_lvalue_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Ident) {
			hierarchical_identifier();
			while (la->kind == _T_Lbrack) {
				Get();
				addTerminal(); 
				range_expression();
				Expect(_T_Rbrack,__FUNCTION__);
				addTerminal(); 
			}
		} else if (la->kind == _T_Lbrace) {
			Get();
			addTerminal(); 
			lvalue_();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				lvalue_();
			}
			Expect(_T_Rbrace,__FUNCTION__);
			addTerminal(); 
		} else SynErr(342,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::variable_assignment() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_variable_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		variable_lvalue();
		Expect(_T_Eq,__FUNCTION__);
		addTerminal(); 
		expression();
		d_stack.pop(); 
}

void Parser::par_block() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_par_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_fork,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Colon) {
			Get();
			addTerminal(); 
			block_identifier();
			while (StartOf(17)) {
				block_item_declaration();
			}
		}
		while (StartOf(24)) {
			statement();
		}
		Expect(_T_join,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::seq_block() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_seq_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_begin,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Colon) {
			Get();
			addTerminal(); 
			block_identifier();
			while (StartOf(17)) {
				block_item_declaration();
			}
		}
		while (StartOf(35)) {
			statement_or_null();
		}
		Expect(_T_end,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::case_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_case_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_case) {
			Get();
			addTerminal(); 
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
			expression();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			case_item();
			while (StartOf(30)) {
				case_item();
			}
			Expect(_T_endcase,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_casez) {
			Get();
			addTerminal(); 
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
			expression();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			case_item();
			while (StartOf(30)) {
				case_item();
			}
			Expect(_T_endcase,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_casex) {
			Get();
			addTerminal(); 
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
			expression();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			case_item();
			while (StartOf(30)) {
				case_item();
			}
			Expect(_T_endcase,__FUNCTION__);
			addTerminal(); 
		} else SynErr(343,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::conditional_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_conditional_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_if,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		expression();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		statement_or_null();
		while (peek(1) == _T_else && peek(2) == _T_if ) {
			Expect(_T_else,__FUNCTION__);
			addTerminal(); 
			Expect(_T_if,__FUNCTION__);
			addTerminal(); 
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
			expression();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			statement_or_null();
		}
		if (la->kind == _T_else) {
			Get();
			addTerminal(); 
			statement_or_null();
		}
		d_stack.pop(); 
}

void Parser::disable_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_disable_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_disable,__FUNCTION__);
		addTerminal(); 
		hierarchical_identifier();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::event_trigger() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_event_trigger, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_MinusGt,__FUNCTION__);
		addTerminal(); 
		hierarchical_event_identifier();
		while (la->kind == _T_Lbrack) {
			Get();
			addTerminal(); 
			expression();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
		}
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::loop_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_loop_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_forever) {
			Get();
			addTerminal(); 
			statement();
		} else if (la->kind == _T_repeat) {
			Get();
			addTerminal(); 
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
			expression();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			statement();
		} else if (la->kind == _T_while) {
			Get();
			addTerminal(); 
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
			expression();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			statement();
		} else if (la->kind == _T_for) {
			Get();
			addTerminal(); 
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
			variable_assignment();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			expression();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			variable_assignment();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			statement();
		} else SynErr(344,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::procedural_timing_control_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_procedural_timing_control_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		procedural_timing_control();
		statement_or_null();
		d_stack.pop(); 
}

void Parser::system_task_enable() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_system_task_enable, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		system_task_identifier();
		if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			if (StartOf(25)) {
				expression();
			}
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				if (StartOf(25)) {
					expression();
				}
			}
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		}
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::wait_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_wait_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_wait,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		expression();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		statement_or_null();
		d_stack.pop(); 
}

void Parser::procedural_assertion_statement() {
		concurrent_assertion_statement();
}

void Parser::delay_control() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_delay_control, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Hash,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Realnum || la->kind == _T_Natural || la->kind == _T_Ident) {
			delay_value();
		} else if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			mintypmax_expression();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		} else SynErr(345,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::event_control() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_event_control, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_At,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Ident) {
			hierarchical_event_identifier();
		} else if (la->kind == _T_LparStarRpar) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Star) {
				Get();
				addTerminal(); 
			} else if (StartOf(36)) {
				event_expression();
			} else SynErr(346,__FUNCTION__);
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_Star) {
			Get();
			addTerminal(); 
		} else SynErr(347,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::hierarchical_identifier() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_hierarchical_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		if (la->kind == _T_Lbrack) {
			Get();
			addTerminal(); 
			range_expression();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
		}
		while (la->kind == _T_Dot) {
			Get();
			addTerminal(); 
			identifier();
			if (la->kind == _T_Lbrack) {
				Get();
				addTerminal(); 
				range_expression();
				Expect(_T_Rbrack,__FUNCTION__);
				addTerminal(); 
			}
		}
		d_stack.pop(); 
}

void Parser::hierarchical_event_identifier() {
		hierarchical_identifier();
}

void Parser::event_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_event_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(25)) {
			expression();
			event_expression_nlr_();
		} else if (la->kind == _T_posedge) {
			Get();
			addTerminal(); 
			expression();
			event_expression_nlr_();
		} else if (la->kind == _T_negedge) {
			Get();
			addTerminal(); 
			expression();
			event_expression_nlr_();
		} else SynErr(348,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::event_expression_nlr_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_event_expression_nlr_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Comma || la->kind == _T_or) {
			if (la->kind == _T_or) {
				Get();
				addTerminal(); 
				event_expression();
			} else {
				Get();
				addTerminal(); 
				event_expression();
			}
		}
		d_stack.pop(); 
}

void Parser::procedural_timing_control() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_procedural_timing_control, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Hash) {
			delay_control();
		} else if (la->kind == _T_At) {
			event_control();
		} else SynErr(349,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::case_item() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_case_item, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(25)) {
			expression();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				expression();
			}
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
			statement_or_null();
		} else if (la->kind == _T_default) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Colon) {
				Get();
				addTerminal(); 
			}
			statement_or_null();
		} else SynErr(350,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::system_task_identifier() {
		system_identifier_();
}

void Parser::specify_item() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specify_item, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_specparam) {
			specparam_declaration();
		} else if (la->kind == _T_pulsestyle_ondetect || la->kind == _T_pulsestyle_onevent) {
			pulsestyle_declaration();
		} else if (la->kind == _T_noshowcancelled || la->kind == _T_showcancelled) {
			showcancelled_declaration();
		} else if (la->kind == _T_Lpar || la->kind == _T_if || la->kind == _T_ifnone) {
			path_declaration();
		} else if (StartOf(37)) {
			system_timing_check();
		} else SynErr(351,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::pulsestyle_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pulsestyle_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_pulsestyle_onevent) {
			Get();
			addTerminal(); 
			list_of_path_outputs();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_pulsestyle_ondetect) {
			Get();
			addTerminal(); 
			list_of_path_outputs();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		} else SynErr(352,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::showcancelled_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_showcancelled_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_showcancelled) {
			Get();
			addTerminal(); 
			list_of_path_outputs();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_noshowcancelled) {
			Get();
			addTerminal(); 
			list_of_path_outputs();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		} else SynErr(353,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::path_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_path_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Lpar) {
			path_description_();
			Expect(_T_Eq,__FUNCTION__);
			addTerminal(); 
			path_delay_value();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_if || la->kind == _T_ifnone) {
			state_dependent_path_declaration();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		} else SynErr(354,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::system_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_system_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_dlr_setup: {
			dlr_setup_timing_check();
			break;
		}
		case _T_dlr_hold: {
			dlr_hold_timing_check();
			break;
		}
		case _T_dlr_setuphold: {
			dlr_setuphold_timing_check();
			break;
		}
		case _T_dlr_recovery: {
			dlr_recovery_timing_check();
			break;
		}
		case _T_dlr_removal: {
			dlr_removal_timing_check();
			break;
		}
		case _T_dlr_recrem: {
			dlr_recrem_timing_check();
			break;
		}
		case _T_dlr_skew: {
			dlr_skew_timing_check();
			break;
		}
		case _T_dlr_timeskew: {
			dlr_timeskew_timing_check();
			break;
		}
		case _T_dlr_fullskew: {
			dlr_fullskew_timing_check();
			break;
		}
		case _T_dlr_period: {
			dlr_period_timing_check();
			break;
		}
		case _T_dlr_width: {
			dlr_width_timing_check();
			break;
		}
		case _T_dlr_nochange: {
			dlr_nochange_timing_check();
			break;
		}
		default: SynErr(355,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::list_of_path_outputs() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_path_outputs, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		specify_output_terminal_descriptor();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			specify_output_terminal_descriptor();
		}
		d_stack.pop(); 
}

void Parser::path_description_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_path_description_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_negedge || la->kind == _T_posedge) {
			edge_identifier();
		}
		list_of_path_inouts_();
		if (la->kind == _T_Plus || la->kind == _T_Minus) {
			polarity_operator();
		}
		if (la->kind == _T_StarGt) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_EqGt) {
			Get();
			addTerminal(); 
		} else SynErr(356,__FUNCTION__);
		if (la->kind == _T_Ident) {
			list_of_path_inouts_();
		} else if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			list_of_path_inouts_();
			if (la->kind == _T_Plus || la->kind == _T_Minus || la->kind == _T_Colon) {
				if (la->kind == _T_Plus || la->kind == _T_Minus) {
					polarity_operator();
				}
				Expect(_T_Colon,__FUNCTION__);
				addTerminal(); 
			} else if (la->kind == _T_PlusColon || la->kind == _T_MinusColon) {
				if (la->kind == _T_PlusColon) {
					Get();
					addTerminal(); 
				} else {
					Get();
					addTerminal(); 
				}
			} else SynErr(357,__FUNCTION__);
			data_source_expression();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		} else SynErr(358,__FUNCTION__);
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::path_delay_value() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_path_delay_value, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		list_of_path_delay_expressions();
		d_stack.pop(); 
}

void Parser::state_dependent_path_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_state_dependent_path_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_if) {
			Get();
			addTerminal(); 
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
			module_path_expression();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			path_description_();
			Expect(_T_Eq,__FUNCTION__);
			addTerminal(); 
			path_delay_value();
		} else if (la->kind == _T_ifnone) {
			Get();
			addTerminal(); 
			simple_path_declaration();
		} else SynErr(359,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::simple_path_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_simple_path_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		path_description_();
		Expect(_T_Eq,__FUNCTION__);
		addTerminal(); 
		path_delay_value();
		d_stack.pop(); 
}

void Parser::edge_identifier() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_edge_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_posedge) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_negedge) {
			Get();
			addTerminal(); 
		} else SynErr(360,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::list_of_path_inouts_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_path_inouts_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		specify_terminal_descriptor();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			specify_terminal_descriptor();
		}
		d_stack.pop(); 
}

void Parser::polarity_operator() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_polarity_operator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Plus) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Minus) {
			Get();
			addTerminal(); 
		} else SynErr(361,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::data_source_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_data_source_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}

void Parser::specify_terminal_descriptor() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specify_terminal_descriptor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		if (la->kind == _T_Lbrack) {
			Get();
			addTerminal(); 
			constant_range_expression();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::specify_output_terminal_descriptor() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specify_output_terminal_descriptor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		output_identifier();
		if (la->kind == _T_Lbrack) {
			Get();
			addTerminal(); 
			constant_range_expression();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::output_identifier() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_output_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		d_stack.pop(); 
}

void Parser::list_of_path_delay_expressions() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_path_delay_expressions, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		path_delay_expression();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			path_delay_expression();
		}
		d_stack.pop(); 
}

void Parser::path_delay_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_path_delay_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		constant_mintypmax_expression();
		d_stack.pop(); 
}

void Parser::module_path_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_path_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(38)) {
			module_path_primary();
			module_path_expression_nlr_();
		} else if (StartOf(39)) {
			unary_module_path_operator();
			module_path_primary();
			module_path_expression_nlr_();
		} else SynErr(362,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::dlr_setup_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_setup_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_dlr_setup,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		data_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		reference_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Ident) {
				notifier();
			}
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_hold_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_hold_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_dlr_hold,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		reference_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		data_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Ident) {
				notifier();
			}
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_setuphold_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_setuphold_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_dlr_setuphold,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		reference_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		data_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Ident) {
				notifier();
			}
			if (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				if (StartOf(25)) {
					stamptime_condition();
				}
				if (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					if (StartOf(25)) {
						checktime_condition();
					}
					if (la->kind == _T_Comma) {
						Get();
						addTerminal(); 
						if (la->kind == _T_Ident) {
							delayed_reference();
						}
						if (la->kind == _T_Comma) {
							Get();
							addTerminal(); 
							if (la->kind == _T_Ident) {
								delayed_data();
							}
						}
					}
				}
			}
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_recovery_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_recovery_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_dlr_recovery,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		reference_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		data_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Ident) {
				notifier();
			}
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_removal_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_removal_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_dlr_removal,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		reference_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		data_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Ident) {
				notifier();
			}
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_recrem_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_recrem_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_dlr_recrem,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		reference_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		data_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Ident) {
				notifier();
			}
			if (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				if (StartOf(25)) {
					stamptime_condition();
				}
				if (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					if (StartOf(25)) {
						checktime_condition();
					}
					if (la->kind == _T_Comma) {
						Get();
						addTerminal(); 
						if (la->kind == _T_Ident) {
							delayed_reference();
						}
						if (la->kind == _T_Comma) {
							Get();
							addTerminal(); 
							if (la->kind == _T_Ident) {
								delayed_data();
							}
						}
					}
				}
			}
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_skew_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_skew_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_dlr_skew,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		reference_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		data_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Ident) {
				notifier();
			}
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_timeskew_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_timeskew_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_dlr_timeskew,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		reference_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		data_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Ident) {
				notifier();
			}
			if (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				if (StartOf(25)) {
					event_based_flag();
				}
				if (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					if (StartOf(25)) {
						remain_active_flag();
					}
				}
			}
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_fullskew_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_fullskew_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_dlr_fullskew,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		reference_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		data_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Ident) {
				notifier();
			}
			if (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				if (StartOf(25)) {
					event_based_flag();
				}
				if (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					if (StartOf(25)) {
						remain_active_flag();
					}
				}
			}
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_period_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_period_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_dlr_period,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		controlled_reference_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Ident) {
				notifier();
			}
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_width_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_width_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_dlr_width,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		controlled_reference_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			threshold();
			if (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				notifier();
			}
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_nochange_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_nochange_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_dlr_nochange,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		reference_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		data_event();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		start_edge_offset();
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		end_edge_offset();
		if (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Ident) {
				notifier();
			}
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::data_event() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_data_event, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		timing_check_event();
		d_stack.pop(); 
}

void Parser::reference_event() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_reference_event, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		timing_check_event();
		d_stack.pop(); 
}

void Parser::timing_check_limit() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_timing_check_limit, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}

void Parser::notifier() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_notifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		variable_identifier();
		d_stack.pop(); 
}

void Parser::stamptime_condition() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_stamptime_condition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		mintypmax_expression();
		d_stack.pop(); 
}

void Parser::checktime_condition() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_checktime_condition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		mintypmax_expression();
		d_stack.pop(); 
}

void Parser::delayed_reference() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_delayed_reference, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		terminal_identifier();
		if (la->kind == _T_Lbrack) {
			Get();
			addTerminal(); 
			constant_mintypmax_expression();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::delayed_data() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_delayed_data, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		terminal_identifier();
		if (la->kind == _T_Lbrack) {
			Get();
			addTerminal(); 
			constant_mintypmax_expression();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::event_based_flag() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_event_based_flag, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		constant_expression();
		d_stack.pop(); 
}

void Parser::remain_active_flag() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_remain_active_flag, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		constant_expression();
		d_stack.pop(); 
}

void Parser::controlled_reference_event() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_controlled_reference_event, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		controlled_timing_check_event();
		d_stack.pop(); 
}

void Parser::threshold() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_threshold, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		constant_expression();
		d_stack.pop(); 
}

void Parser::start_edge_offset() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_start_edge_offset, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		mintypmax_expression();
		d_stack.pop(); 
}

void Parser::end_edge_offset() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_end_edge_offset, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		mintypmax_expression();
		d_stack.pop(); 
}

void Parser::controlled_timing_check_event() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_controlled_timing_check_event, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		timing_check_event_control();
		specify_terminal_descriptor();
		if (la->kind == _T_3Amp) {
			Get();
			addTerminal(); 
			timing_check_condition();
		}
		d_stack.pop(); 
}

void Parser::timing_check_event() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_timing_check_event, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_edge || la->kind == _T_negedge || la->kind == _T_posedge) {
			timing_check_event_control();
		}
		specify_terminal_descriptor();
		if (la->kind == _T_3Amp) {
			Get();
			addTerminal(); 
			timing_check_condition();
		}
		d_stack.pop(); 
}

void Parser::terminal_identifier() {
		identifier();
}

void Parser::timing_check_event_control() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_timing_check_event_control, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_posedge) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_negedge) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_edge) {
			edge_control_specifier();
		} else SynErr(363,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::timing_check_condition() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_timing_check_condition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		scalar_timing_check_condition();
		d_stack.pop(); 
}

void Parser::edge_control_specifier() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_edge_control_specifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_edge,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lbrack,__FUNCTION__);
		addTerminal(); 
		edge_descriptor();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			edge_descriptor();
		}
		Expect(_T_Rbrack,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::edge_descriptor() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_edge_descriptor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		number();
		d_stack.pop(); 
}

void Parser::scalar_timing_check_condition() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_scalar_timing_check_condition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		if (StartOf(40)) {
			if (la->kind == _T_2Eq) {
				Get();
				addTerminal(); 
				scalar_constant();
			} else if (la->kind == _T_3Eq) {
				Get();
				addTerminal(); 
				scalar_constant();
			} else if (la->kind == _T_BangEq) {
				Get();
				addTerminal(); 
				scalar_constant();
			} else {
				Get();
				addTerminal(); 
				scalar_constant();
			}
		}
		d_stack.pop(); 
}

void Parser::scalar_constant() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_scalar_constant, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		number();
		d_stack.pop(); 
}

void Parser::single_or_multiple_concatenation_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_single_or_multiple_concatenation_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lbrace,__FUNCTION__);
		addTerminal(); 
		expression();
		if (la->kind == _T_Comma || la->kind == _T_Rbrace) {
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				expression();
			}
		} else if (la->kind == _T_Lbrace) {
			Get();
			addTerminal(); 
			expression();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				expression();
			}
			Expect(_T_Rbrace,__FUNCTION__);
			addTerminal(); 
		} else SynErr(364,__FUNCTION__);
		Expect(_T_Rbrace,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::mod_path_single_or_multi_concat_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_mod_path_single_or_multi_concat_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lbrace,__FUNCTION__);
		addTerminal(); 
		constant_expression();
		if (la->kind == _T_Comma || la->kind == _T_Rbrace) {
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				module_path_expression();
			}
		} else if (la->kind == _T_Lbrace) {
			Get();
			addTerminal(); 
			module_path_expression();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				module_path_expression();
			}
			Expect(_T_Rbrace,__FUNCTION__);
			addTerminal(); 
		} else SynErr(365,__FUNCTION__);
		Expect(_T_Rbrace,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::system_function_call() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_system_function_call, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		system_function_identifier();
		if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			expression();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				expression();
			}
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::system_function_identifier() {
		system_identifier_();
}

void Parser::range_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_range_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		if (la->kind == _T_PlusColon || la->kind == _T_MinusColon || la->kind == _T_Colon) {
			if (la->kind == _T_Colon) {
				Get();
				addTerminal(); 
			} else if (la->kind == _T_PlusColon) {
				Get();
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
			}
			constant_expression();
		}
		d_stack.pop(); 
}

void Parser::expression_nlr_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_expression_nlr_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(28)) {
			if (StartOf(29)) {
				binary_operator();
				expression();
				expression_nlr_();
			} else {
				Get();
				addTerminal(); 
				expression2();
				Expect(_T_Colon,__FUNCTION__);
				addTerminal(); 
				expression3();
				expression_nlr_();
			}
		}
		d_stack.pop(); 
}

void Parser::expression2() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_expression2, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}

void Parser::expression3() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_expression3, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}

void Parser::module_path_primary() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_path_primary, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(34)) {
			number();
		} else if (la->kind == _T_Ident) {
			rvalue_or_function_call_();
		} else if (la->kind == _T_Lbrace) {
			mod_path_single_or_multi_concat_();
		} else if (la->kind == _T_SysName) {
			system_function_call();
		} else if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			module_path_mintypmax_expression();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		} else SynErr(366,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::module_path_expression_nlr_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_path_expression_nlr_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(41)) {
			if (StartOf(42)) {
				binary_module_path_operator();
				module_path_expression();
				module_path_expression_nlr_();
			} else {
				Get();
				addTerminal(); 
				module_path_expression();
				Expect(_T_Colon,__FUNCTION__);
				addTerminal(); 
				module_path_expression();
				module_path_expression_nlr_();
			}
		}
		d_stack.pop(); 
}

void Parser::unary_module_path_operator() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_unary_module_path_operator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Bang: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Tilde: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Amp: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_TildeAmp: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Bar: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_TildeBar: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Hat: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_TildeHat: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_HatTilde: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(367,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::binary_module_path_operator() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_binary_module_path_operator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_2Eq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_BangEq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_2Amp: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_2Bar: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Amp: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Bar: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Hat: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_HatTilde: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_TildeHat: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(368,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::module_path_mintypmax_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_path_mintypmax_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		module_path_expression();
		if (la->kind == _T_Colon) {
			Get();
			addTerminal(); 
			module_path_expression();
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
			module_path_expression();
		}
		d_stack.pop(); 
}

void Parser::rvalue_or_function_call_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_rvalue_or_function_call_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		hierarchical_identifier();
		if (la->kind == _T_Lpar || la->kind == _T_Lbrack) {
			if (la->kind == _T_Lbrack) {
				Get();
				addTerminal(); 
				range_expression();
				Expect(_T_Rbrack,__FUNCTION__);
				addTerminal(); 
				while (la->kind == _T_Lbrack) {
					Get();
					addTerminal(); 
					range_expression();
					Expect(_T_Rbrack,__FUNCTION__);
					addTerminal(); 
				}
			} else {
				Get();
				addTerminal(); 
				expression();
				while (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					expression();
				}
				Expect(_T_Rpar,__FUNCTION__);
				addTerminal(); 
			}
		}
		d_stack.pop(); 
}

void Parser::hierarchical_net_identifier() {
		hierarchical_identifier();
}

void Parser::hierarchical_variable_identifier() {
		hierarchical_identifier();
}

void Parser::system_identifier_() {
		Expect(_T_SysName,__FUNCTION__);
		addTerminal(); 
}

void Parser::assert_statement_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_assert_statement_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_assert,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Hash || la->kind == _T_final || la->kind == _T_property) {
			if (la->kind == _T_Hash) {
				Get();
				addTerminal(); 
				Expect(_T_Natural,__FUNCTION__);
				addTerminal(); 
			} else if (la->kind == _T_final) {
				Get();
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
			}
		}
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		property_spec();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		action_block();
		d_stack.pop(); 
}

void Parser::property_spec() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_property_spec, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_At) {
			clocking_event();
		}
		if (la->kind == _T_disable) {
			Get();
			addTerminal(); 
			Expect(_T_iff,__FUNCTION__);
			addTerminal(); 
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
			expression_or_dist();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		}
		property_expr();
		d_stack.pop(); 
}

void Parser::action_block() {
		statement_or_null();
		if (la->kind == _T_else) {
			Get();
			addTerminal(); 
			statement_or_null();
		}
}

void Parser::assume_statement_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_assume_statement_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_assume,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Hash || la->kind == _T_final || la->kind == _T_property) {
			if (la->kind == _T_Hash) {
				Get();
				addTerminal(); 
				Expect(_T_Natural,__FUNCTION__);
				addTerminal(); 
			} else if (la->kind == _T_final) {
				Get();
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
			}
		}
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		property_spec();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		action_block();
		d_stack.pop(); 
}

void Parser::cover_statement_() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_cover_statement_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_cover,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Hash || la->kind == _T_final || la->kind == _T_property) {
			if (la->kind == _T_Hash) {
				Get();
				addTerminal(); 
				Expect(_T_Natural,__FUNCTION__);
				addTerminal(); 
			} else if (la->kind == _T_final) {
				Get();
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
			}
		}
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		property_spec();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		statement_or_null();
		d_stack.pop(); 
}

void Parser::cover_sequence_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_cover_sequence_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_cover,__FUNCTION__);
		addTerminal(); 
		Expect(_T_sequence,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_At) {
			clocking_event();
		}
		if (la->kind == _T_disable) {
			Get();
			addTerminal(); 
			Expect(_T_iff,__FUNCTION__);
			addTerminal(); 
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
			expression_or_dist();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		}
		sequence_expr();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		statement_or_null();
		d_stack.pop(); 
}

void Parser::clocking_event() {
		Expect(_T_At,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Ident) {
			identifier();
		} else if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			event_expression();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		} else SynErr(369,__FUNCTION__);
}

void Parser::expression_or_dist() {
		expression();
		if (la->kind == _T_dist) {
			Get();
			addTerminal(); 
			Expect(_T_Lbrace,__FUNCTION__);
			addTerminal(); 
			dist_list();
			Expect(_T_Rbrace,__FUNCTION__);
			addTerminal(); 
		}
}

void Parser::sequence_expr() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_sequence_expr, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_2Hash || la->kind == _T_2HashLbrackStarRbrack || la->kind == _T_2HashLbrackPlusRbrack) {
			cycle_delay_range();
			sequence_expr();
			while (la->kind == _T_2Hash || la->kind == _T_2HashLbrackStarRbrack || la->kind == _T_2HashLbrackPlusRbrack) {
				cycle_delay_range();
				sequence_expr();
			}
			sequence_expr_nlr_();
		} else if (StartOf(25)) {
			expression_or_dist();
			if (StartOf(43)) {
				if (StartOf(44)) {
					boolean_abbrev();
				}
			} else if (la->kind == _T_throughout) {
				Get();
				addTerminal(); 
				sequence_expr();
			} else SynErr(370,__FUNCTION__);
			sequence_expr_nlr_();
		} else SynErr(371,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::restrict_property_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_restrict_property_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_restrict,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_property) {
			Get();
			addTerminal(); 
		}
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		property_spec();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::immediate_assertion_statement_() {
		if (la->kind == _T_assert) {
			assert_statement_();
		} else if (la->kind == _T_assume) {
			assume_statement_();
		} else if (la->kind == _T_cover) {
			cover_statement_();
		} else SynErr(372,__FUNCTION__);
}

void Parser::property_expr() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_property_expr, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Bang: case _T_2Hash: case _T_2HashLbrackStarRbrack: case _T_2HashLbrackPlusRbrack: case _T_Amp: case _T_Lpar: case _T_Plus: case _T_Minus: case _T_Hat: case _T_HatTilde: case _T_Lbrace: case _T_Bar: case _T_Tilde: case _T_TildeAmp: case _T_TildeHat: case _T_TildeBar: case _T_Realnum: case _T_Natural: case _T_SizedBased: case _T_BasedInt: case _T_BaseFormat: case _T_SysName: case _T_Ident: case _T_Str: {
			sequence_expr();
			if (StartOf(45)) {
				if (StartOf(46)) {
					if (la->kind == _T_BarMinusGt) {
						Get();
						addTerminal(); 
					} else if (la->kind == _T_BarEqGt) {
						Get();
						addTerminal(); 
					} else if (la->kind == _T_HashMinusHash) {
						Get();
						addTerminal(); 
					} else {
						Get();
						addTerminal(); 
					}
					property_expr();
				} else {
					Get();
					addTerminal(); 
					property_expr();
					Expect(_T_Rpar,__FUNCTION__);
					addTerminal(); 
				}
			}
			property_expr_nlr_();
			break;
		}
		case _T_strong: {
			Get();
			addTerminal(); 
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
			sequence_expr();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			property_expr_nlr_();
			break;
		}
		case _T_weak: {
			Get();
			addTerminal(); 
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
			sequence_expr();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			property_expr_nlr_();
			break;
		}
		case _T_not: {
			Get();
			addTerminal(); 
			property_expr();
			property_expr_nlr_();
			break;
		}
		case _T_if: {
			Get();
			addTerminal(); 
			expression_or_dist();
			property_expr();
			if (la->kind == _T_else) {
				Get();
				addTerminal(); 
				property_expr();
			}
			property_expr_nlr_();
			break;
		}
		case _T_case: {
			Get();
			addTerminal(); 
			expression_or_dist();
			property_case_item();
			while (StartOf(30)) {
				property_case_item();
			}
			Expect(_T_endcase,__FUNCTION__);
			addTerminal(); 
			property_expr_nlr_();
			break;
		}
		case _T_nexttime: {
			Get();
			addTerminal(); 
			if (la->kind == _T_Lbrack) {
				Get();
				addTerminal(); 
				constant_expression();
				Expect(_T_Rbrack,__FUNCTION__);
				addTerminal(); 
			}
			property_expr();
			property_expr_nlr_();
			break;
		}
		case _T_s_nexttime: {
			Get();
			addTerminal(); 
			if (la->kind == _T_Lbrack) {
				Get();
				addTerminal(); 
				constant_expression();
				Expect(_T_Rbrack,__FUNCTION__);
				addTerminal(); 
			}
			property_expr();
			property_expr_nlr_();
			break;
		}
		case _T_always: {
			Get();
			addTerminal(); 
			if (la->kind == _T_Lbrack) {
				Get();
				addTerminal(); 
				cycle_delay_const_range_expression();
				Expect(_T_Rbrack,__FUNCTION__);
				addTerminal(); 
			}
			property_expr();
			property_expr_nlr_();
			break;
		}
		case _T_s_always: {
			Get();
			addTerminal(); 
			Expect(_T_Lbrack,__FUNCTION__);
			addTerminal(); 
			constant_range();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
			property_expr();
			property_expr_nlr_();
			break;
		}
		case _T_s_eventually: {
			Get();
			addTerminal(); 
			if (la->kind == _T_Lbrack) {
				Get();
				addTerminal(); 
				cycle_delay_const_range_expression();
				Expect(_T_Rbrack,__FUNCTION__);
				addTerminal(); 
			}
			property_expr();
			property_expr_nlr_();
			break;
		}
		case _T_eventually: {
			Get();
			addTerminal(); 
			Expect(_T_Lbrack,__FUNCTION__);
			addTerminal(); 
			constant_range();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
			property_expr();
			property_expr_nlr_();
			break;
		}
		case _T_accept_on: {
			Get();
			addTerminal(); 
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
			expression_or_dist();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			property_expr();
			property_expr_nlr_();
			break;
		}
		case _T_reject_on: {
			Get();
			addTerminal(); 
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
			expression_or_dist();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			property_expr();
			property_expr_nlr_();
			break;
		}
		case _T_sync_accept_on: {
			Get();
			addTerminal(); 
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
			expression_or_dist();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			property_expr();
			property_expr_nlr_();
			break;
		}
		case _T_sync_reject_on: {
			Get();
			addTerminal(); 
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
			expression_or_dist();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			property_expr();
			property_expr_nlr_();
			break;
		}
		case _T_At: {
			clocking_event();
			property_expr();
			property_expr_nlr_();
			break;
		}
		default: SynErr(373,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::dist_list() {
		dist_item();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			dist_item();
		}
}

void Parser::dist_item() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dist_item, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		value_range();
		if (la->kind == _T_ColonSlash || la->kind == _T_ColonEq) {
			dist_weight();
		}
		d_stack.pop(); 
}

void Parser::value_range() {
		if (StartOf(25)) {
			expression();
		} else if (la->kind == _T_Lbrack) {
			Get();
			addTerminal(); 
			expression();
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
			expression();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
		} else SynErr(374,__FUNCTION__);
}

void Parser::dist_weight() {
		if (la->kind == _T_ColonEq) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_ColonSlash) {
			Get();
			addTerminal(); 
		} else SynErr(375,__FUNCTION__);
		expression();
}

void Parser::property_expr_nlr_() {
		if (StartOf(47)) {
			switch (la->kind) {
			case _T_or: {
				Get();
				addTerminal(); 
				property_expr();
				property_expr_nlr_();
				break;
			}
			case _T_and: {
				Get();
				addTerminal(); 
				property_expr();
				property_expr_nlr_();
				break;
			}
			case _T_until: {
				Get();
				addTerminal(); 
				property_expr();
				property_expr_nlr_();
				break;
			}
			case _T_s_until: {
				Get();
				addTerminal(); 
				property_expr();
				property_expr_nlr_();
				break;
			}
			case _T_until_with: {
				Get();
				addTerminal(); 
				property_expr();
				property_expr_nlr_();
				break;
			}
			case _T_s_until_with: {
				Get();
				addTerminal(); 
				property_expr();
				property_expr_nlr_();
				break;
			}
			case _T_implies: {
				Get();
				addTerminal(); 
				property_expr();
				property_expr_nlr_();
				break;
			}
			case _T_iff: {
				Get();
				addTerminal(); 
				property_expr();
				property_expr_nlr_();
				break;
			}
			}
		}
}

void Parser::property_case_item() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_property_case_item, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(25)) {
			expression_or_dist();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				expression_or_dist();
			}
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
			property_expr();
			if (la->kind == _T_Semi) {
				Get();
				addTerminal(); 
			}
		} else if (la->kind == _T_default) {
			Get();
			addTerminal(); 
			if (la->kind == _T_Colon) {
				Get();
				addTerminal(); 
			}
			property_expr();
			if (la->kind == _T_Semi) {
				Get();
				addTerminal(); 
			}
		} else SynErr(376,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::cycle_delay_const_range_expression() {
		constant_expression();
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		if (StartOf(25)) {
			constant_expression();
		} else if (la->kind == _T_Dlr) {
			Get();
			addTerminal(); 
		} else SynErr(377,__FUNCTION__);
}

void Parser::constant_range() {
		constant_expression();
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		constant_expression();
}

void Parser::cycle_delay_range() {
		if (la->kind == _T_2Hash) {
			Get();
			addTerminal(); 
			if (StartOf(25)) {
				cycle_delay_const_range_expression();
			}
		} else if (la->kind == _T_2HashLbrackStarRbrack) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_2HashLbrackPlusRbrack) {
			Get();
			addTerminal(); 
		} else SynErr(378,__FUNCTION__);
}

void Parser::sequence_expr_nlr_() {
		if (StartOf(48)) {
			if (la->kind == _T_and) {
				Get();
				addTerminal(); 
				sequence_expr();
				sequence_expr_nlr_();
			} else if (la->kind == _T_intersect) {
				Get();
				addTerminal(); 
				sequence_expr();
				sequence_expr_nlr_();
			} else if (la->kind == _T_or) {
				Get();
				addTerminal(); 
				sequence_expr();
				sequence_expr_nlr_();
			} else {
				Get();
				addTerminal(); 
				sequence_expr();
				sequence_expr_nlr_();
			}
		}
}

void Parser::boolean_abbrev() {
		if (la->kind == _T_LbrackStar || la->kind == _T_LbrackStarRbrack || la->kind == _T_LbrackPlusRbrack) {
			consecutive_repetition();
		} else if (la->kind == _T_LbrackEq) {
			non_consecutive_repetition();
		} else if (la->kind == _T_LbrackMinusGt) {
			goto_repetition();
		} else SynErr(379,__FUNCTION__);
}

void Parser::consecutive_repetition() {
		if (la->kind == _T_LbrackStar) {
			Get();
			addTerminal(); 
			const_or_range_expression();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_LbrackStarRbrack) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_LbrackPlusRbrack) {
			Get();
			addTerminal(); 
		} else SynErr(380,__FUNCTION__);
}

void Parser::non_consecutive_repetition() {
		Expect(_T_LbrackEq,__FUNCTION__);
		addTerminal(); 
		const_or_range_expression();
		Expect(_T_Rbrack,__FUNCTION__);
		addTerminal(); 
}

void Parser::goto_repetition() {
		Expect(_T_LbrackMinusGt,__FUNCTION__);
		addTerminal(); 
		const_or_range_expression();
		Expect(_T_Rbrack,__FUNCTION__);
		addTerminal(); 
}

void Parser::const_or_range_expression() {
		cycle_delay_const_range_expression();
}




// If the user declared a method Init and a mehtod Destroy they should
// be called in the contructur and the destructor respctively.
//
// The following templates are used to recognize if the user declared
// the methods Init and Destroy.

template<typename T>
struct ParserInitExistsRecognizer {
	template<typename U, void (U::*)() = &U::Init>
	struct ExistsIfInitIsDefinedMarker{};

	struct InitIsMissingType {
		char dummy1;
	};
	
	struct InitExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static InitIsMissingType is_here(...);

	// exist only if ExistsIfInitIsDefinedMarker is defined
	template<typename U>
	static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

	enum { InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType)) };
};

template<typename T>
struct ParserDestroyExistsRecognizer {
	template<typename U, void (U::*)() = &U::Destroy>
	struct ExistsIfDestroyIsDefinedMarker{};

	struct DestroyIsMissingType {
		char dummy1;
	};
	
	struct DestroyExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static DestroyIsMissingType is_here(...);

	// exist only if ExistsIfDestroyIsDefinedMarker is defined
	template<typename U>
	static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

	enum { DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType)) };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller {
	static void CallInit(T *t) {
		// nothing to do
	}
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true> {
	static void CallInit(T *t) {
		t->Init();
	}
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller {
	static void CallDestroy(T *t) {
		// nothing to do
	}
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true> {
	static void CallDestroy(T *t) {
		t->Destroy();
	}
};

void Parser::Parse() {
	d_cur = Vl::Token();
	d_next = Vl::Token();
	Get();
	Verilog();
	Expect(0,__FUNCTION__);
}

Parser::Parser(Vl::PpLexer *scanner, Vl::Errors* err) {
	maxT = 259;

	ParserInitCaller<Parser>::CallInit(this);
	la = &d_dummy;
	minErrDist = 2;
	errDist = minErrDist;
	this->scanner = scanner;
	errors = err;
}

bool Parser::StartOf(int s) {
	const bool T = true;
	const bool x = false;

	static bool set[49][261] = {
		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,T, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,T, T,T,x,x, T,T,T,T, x,x,x,T, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,T, x,x,x,T, T,T,x,x, T,x,x,x, x,x,T,T, T,x,T,x, x,x,x,x, T,T,x,x, x,T,x,x, T,T,x,T, T,T,T,T, T,T,x,x, x,x,x,T, T,x,x,T, T,T,T,x, x,x,T,T, T,T,T,T, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,T, T,x,x,x, T,x,T,T, T,T,T,T, T,T,T,T, x,x,x,T, x,x,T,x, x,x,x,T, x,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,T, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,T, T,T,x,x, T,T,T,T, x,x,x,T, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,T, x,x,x,T, x,T,x,x, T,x,x,x, x,x,T,x, x,x,T,x, x,x,x,x, T,T,x,x, x,T,x,x, T,T,x,T, T,T,T,x, x,T,x,x, x,x,x,T, T,x,x,T, T,T,T,x, x,x,T,T, T,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, T,x,T,T, T,T,T,T, T,T,T,T, x,x,x,T, x,x,T,x, x,x,x,T, x,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,T,T, T,T,T,x, x,x,x,T, x,x,T,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,T,T, T,T,T,x, x,x,x,T, x,x,T,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, T,x,T,x, x,x,T,T, T,T,T,T, x,x,x,T, x,x,T,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, T,T,T,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, T,T,x,T, T,T,T,x, x,T,x,x, x,x,x,T, T,x,x,T, x,x,x,x, x,x,x,T, T,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,T,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,T, T,T,T,T, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,x,T,T, T,x,x,x, x},
		{x,x,T,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,T,x,x, x,x,T,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x},
		{x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,x,T, x,x,x,T, T,T,x,x, x,T,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x},
		{x,x,T,x, x,x,x,x, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,x,x, x,x,T,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,x,T,T, T,x,x,x, x},
		{x,x,T,x, x,x,x,x, x,x,x,x, x,T,x,x, T,x,x,T, x,x,x,x, x,T,x,T, T,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,x,x, x,x,T,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,x,T,T, T,x,x,x, x},
		{x,x,T,x, x,x,x,x, x,x,x,x, x,T,x,x, T,x,x,T, x,x,x,x, x,T,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,x,x, x,x,T,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,x,T,T, T,x,x,x, x},
		{x,x,x,T, T,x,x,x, x,x,x,x, T,T,T,x, x,x,x,x, T,x,T,x, x,T,x,x, T,x,x,x, x,x,T,x, x,x,x,x, x,T,T,T, T,x,T,T, x,T,T,T, T,T,x,x, x,x,x,x, x,x,T,T, x,T,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,T, T,x,x,x, x,x,x,x, T,T,T,x, x,x,x,x, T,x,T,x, x,T,x,x, T,x,x,x, x,x,T,x, x,x,x,x, x,T,T,T, T,x,T,T, x,T,T,T, T,x,x,x, x,x,x,x, x,x,T,T, x,T,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,T,x, x,x,x,x, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,x,x, x,x,T,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,x,T,T, T,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,x,x,T, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,x,x,T, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,x,x,T, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,x,T, x,x,x,T, T,T,x,x, x,T,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x},
		{x,x,T,x, x,x,x,x, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,x,x, x,x,T,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,x,T,T, T,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,T, T,T,T,T, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,x,T,T, x,x,x,x, x},
		{x,x,T,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,T,x,x, x,x,T,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,T, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,T, x,T,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,T, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,T,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,T,x, x,x,T,T, T,T,T,x, x,T,x,x, T,x,x,T, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,x,T,T, T,T,T,T, x,x,T,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,T,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,T, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,x,T,T, T,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x}
	};



	return set[s][la->kind];
}

Parser::~Parser() {
	ParserDestroyCaller<Parser>::CallDestroy(this);
}

void Parser::SynErr(const QString& sourcePath, int line, int col, int n, Vl::Errors* err, const char* ctx, const QString& str ) {
	QString s;
	QString ctxStr;
	if( ctx )
		ctxStr = QString( " in %1" ).arg(ctx);
    if( n == 0 )
        s = QString("EOF expected%1").arg(ctxStr);
    else if( n < Vl::TT_Specials )
        s = QString("'%2' expected%1").arg(ctxStr).arg(Vl::tokenToString(n));
    else if( n <= Vl::TT_Max )
        s = QString("%2 expected%1").arg(ctxStr).arg(Vl::tokenToString(n));
    else
	switch (n) {
			case 0: s = coco_string_create(L"EOF expected"); break;
			case 1: s = coco_string_create(L"T_Literals_ expected"); break;
			case 2: s = coco_string_create(L"T_Bang expected"); break;
			case 3: s = coco_string_create(L"T_BangEq expected"); break;
			case 4: s = coco_string_create(L"T_Bang2Eq expected"); break;
			case 5: s = coco_string_create(L"T_Hash expected"); break;
			case 6: s = coco_string_create(L"T_2Hash expected"); break;
			case 7: s = coco_string_create(L"T_2HashLbrackStarRbrack expected"); break;
			case 8: s = coco_string_create(L"T_2HashLbrackPlusRbrack expected"); break;
			case 9: s = coco_string_create(L"T_HashMinusHash expected"); break;
			case 10: s = coco_string_create(L"T_HashEqHash expected"); break;
			case 11: s = coco_string_create(L"T_Dlr expected"); break;
			case 12: s = coco_string_create(L"T_Percent expected"); break;
			case 13: s = coco_string_create(L"T_Amp expected"); break;
			case 14: s = coco_string_create(L"T_2Amp expected"); break;
			case 15: s = coco_string_create(L"T_3Amp expected"); break;
			case 16: s = coco_string_create(L"T_Lpar expected"); break;
			case 17: s = coco_string_create(L"T_Latt expected"); break;
			case 18: s = coco_string_create(L"T_LparStarRpar expected"); break;
			case 19: s = coco_string_create(L"T_Rpar expected"); break;
			case 20: s = coco_string_create(L"T_Star expected"); break;
			case 21: s = coco_string_create(L"T_Ratt expected"); break;
			case 22: s = coco_string_create(L"T_2Star expected"); break;
			case 23: s = coco_string_create(L"T_Rcmt expected"); break;
			case 24: s = coco_string_create(L"T_StarGt expected"); break;
			case 25: s = coco_string_create(L"T_Plus expected"); break;
			case 26: s = coco_string_create(L"T_PlusColon expected"); break;
			case 27: s = coco_string_create(L"T_Comma expected"); break;
			case 28: s = coco_string_create(L"T_Minus expected"); break;
			case 29: s = coco_string_create(L"T_MinusColon expected"); break;
			case 30: s = coco_string_create(L"T_MinusGt expected"); break;
			case 31: s = coco_string_create(L"T_Dot expected"); break;
			case 32: s = coco_string_create(L"T_2Dot expected"); break;
			case 33: s = coco_string_create(L"T_3Dot expected"); break;
			case 34: s = coco_string_create(L"T_Slash expected"); break;
			case 35: s = coco_string_create(L"T_Lcmt expected"); break;
			case 36: s = coco_string_create(L"T_2Slash expected"); break;
			case 37: s = coco_string_create(L"T_Colon expected"); break;
			case 38: s = coco_string_create(L"T_ColonSlash expected"); break;
			case 39: s = coco_string_create(L"T_ColonEq expected"); break;
			case 40: s = coco_string_create(L"T_Semi expected"); break;
			case 41: s = coco_string_create(L"T_Lt expected"); break;
			case 42: s = coco_string_create(L"T_2Lt expected"); break;
			case 43: s = coco_string_create(L"T_3Lt expected"); break;
			case 44: s = coco_string_create(L"T_Leq expected"); break;
			case 45: s = coco_string_create(L"T_Eq expected"); break;
			case 46: s = coco_string_create(L"T_2Eq expected"); break;
			case 47: s = coco_string_create(L"T_3Eq expected"); break;
			case 48: s = coco_string_create(L"T_EqGt expected"); break;
			case 49: s = coco_string_create(L"T_Gt expected"); break;
			case 50: s = coco_string_create(L"T_Geq expected"); break;
			case 51: s = coco_string_create(L"T_2Gt expected"); break;
			case 52: s = coco_string_create(L"T_3Gt expected"); break;
			case 53: s = coco_string_create(L"T_Qmark expected"); break;
			case 54: s = coco_string_create(L"T_At expected"); break;
			case 55: s = coco_string_create(L"T_Lbrack expected"); break;
			case 56: s = coco_string_create(L"T_LbrackStar expected"); break;
			case 57: s = coco_string_create(L"T_LbrackStarRbrack expected"); break;
			case 58: s = coco_string_create(L"T_LbrackPlusRbrack expected"); break;
			case 59: s = coco_string_create(L"T_LbrackMinusGt expected"); break;
			case 60: s = coco_string_create(L"T_LbrackEq expected"); break;
			case 61: s = coco_string_create(L"T_Rbrack expected"); break;
			case 62: s = coco_string_create(L"T_Hat expected"); break;
			case 63: s = coco_string_create(L"T_HatTilde expected"); break;
			case 64: s = coco_string_create(L"T_Lbrace expected"); break;
			case 65: s = coco_string_create(L"T_Bar expected"); break;
			case 66: s = coco_string_create(L"T_BarMinusGt expected"); break;
			case 67: s = coco_string_create(L"T_BarEqGt expected"); break;
			case 68: s = coco_string_create(L"T_2Bar expected"); break;
			case 69: s = coco_string_create(L"T_Rbrace expected"); break;
			case 70: s = coco_string_create(L"T_Tilde expected"); break;
			case 71: s = coco_string_create(L"T_TildeAmp expected"); break;
			case 72: s = coco_string_create(L"T_TildeHat expected"); break;
			case 73: s = coco_string_create(L"T_TildeBar expected"); break;
			case 74: s = coco_string_create(L"T_Keywords_ expected"); break;
			case 75: s = coco_string_create(L"T_dlr_fullskew expected"); break;
			case 76: s = coco_string_create(L"T_dlr_hold expected"); break;
			case 77: s = coco_string_create(L"T_dlr_nochange expected"); break;
			case 78: s = coco_string_create(L"T_dlr_period expected"); break;
			case 79: s = coco_string_create(L"T_dlr_recovery expected"); break;
			case 80: s = coco_string_create(L"T_dlr_recrem expected"); break;
			case 81: s = coco_string_create(L"T_dlr_removal expected"); break;
			case 82: s = coco_string_create(L"T_dlr_setup expected"); break;
			case 83: s = coco_string_create(L"T_dlr_setuphold expected"); break;
			case 84: s = coco_string_create(L"T_dlr_skew expected"); break;
			case 85: s = coco_string_create(L"T_dlr_timeskew expected"); break;
			case 86: s = coco_string_create(L"T_dlr_width expected"); break;
			case 87: s = coco_string_create(L"T_PATHPULSE_dlr expected"); break;
			case 88: s = coco_string_create(L"T_accept_on expected"); break;
			case 89: s = coco_string_create(L"T_always expected"); break;
			case 90: s = coco_string_create(L"T_and expected"); break;
			case 91: s = coco_string_create(L"T_assert expected"); break;
			case 92: s = coco_string_create(L"T_assign expected"); break;
			case 93: s = coco_string_create(L"T_assume expected"); break;
			case 94: s = coco_string_create(L"T_automatic expected"); break;
			case 95: s = coco_string_create(L"T_begin expected"); break;
			case 96: s = coco_string_create(L"T_buf expected"); break;
			case 97: s = coco_string_create(L"T_bufif0 expected"); break;
			case 98: s = coco_string_create(L"T_bufif1 expected"); break;
			case 99: s = coco_string_create(L"T_case expected"); break;
			case 100: s = coco_string_create(L"T_casex expected"); break;
			case 101: s = coco_string_create(L"T_casez expected"); break;
			case 102: s = coco_string_create(L"T_cell expected"); break;
			case 103: s = coco_string_create(L"T_cmos expected"); break;
			case 104: s = coco_string_create(L"T_config expected"); break;
			case 105: s = coco_string_create(L"T_cover expected"); break;
			case 106: s = coco_string_create(L"T_deassign expected"); break;
			case 107: s = coco_string_create(L"T_default expected"); break;
			case 108: s = coco_string_create(L"T_defparam expected"); break;
			case 109: s = coco_string_create(L"T_design expected"); break;
			case 110: s = coco_string_create(L"T_disable expected"); break;
			case 111: s = coco_string_create(L"T_dist expected"); break;
			case 112: s = coco_string_create(L"T_edge expected"); break;
			case 113: s = coco_string_create(L"T_else expected"); break;
			case 114: s = coco_string_create(L"T_end expected"); break;
			case 115: s = coco_string_create(L"T_endcase expected"); break;
			case 116: s = coco_string_create(L"T_endconfig expected"); break;
			case 117: s = coco_string_create(L"T_endfunction expected"); break;
			case 118: s = coco_string_create(L"T_endgenerate expected"); break;
			case 119: s = coco_string_create(L"T_endmodule expected"); break;
			case 120: s = coco_string_create(L"T_endprimitive expected"); break;
			case 121: s = coco_string_create(L"T_endspecify expected"); break;
			case 122: s = coco_string_create(L"T_endtable expected"); break;
			case 123: s = coco_string_create(L"T_endtask expected"); break;
			case 124: s = coco_string_create(L"T_event expected"); break;
			case 125: s = coco_string_create(L"T_eventually expected"); break;
			case 126: s = coco_string_create(L"T_final expected"); break;
			case 127: s = coco_string_create(L"T_for expected"); break;
			case 128: s = coco_string_create(L"T_force expected"); break;
			case 129: s = coco_string_create(L"T_forever expected"); break;
			case 130: s = coco_string_create(L"T_fork expected"); break;
			case 131: s = coco_string_create(L"T_function expected"); break;
			case 132: s = coco_string_create(L"T_generate expected"); break;
			case 133: s = coco_string_create(L"T_genvar expected"); break;
			case 134: s = coco_string_create(L"T_highz0 expected"); break;
			case 135: s = coco_string_create(L"T_highz1 expected"); break;
			case 136: s = coco_string_create(L"T_if expected"); break;
			case 137: s = coco_string_create(L"T_iff expected"); break;
			case 138: s = coco_string_create(L"T_ifnone expected"); break;
			case 139: s = coco_string_create(L"T_implies expected"); break;
			case 140: s = coco_string_create(L"T_incdir expected"); break;
			case 141: s = coco_string_create(L"T_include expected"); break;
			case 142: s = coco_string_create(L"T_initial expected"); break;
			case 143: s = coco_string_create(L"T_inout expected"); break;
			case 144: s = coco_string_create(L"T_input expected"); break;
			case 145: s = coco_string_create(L"T_instance expected"); break;
			case 146: s = coco_string_create(L"T_integer expected"); break;
			case 147: s = coco_string_create(L"T_intersect expected"); break;
			case 148: s = coco_string_create(L"T_join expected"); break;
			case 149: s = coco_string_create(L"T_large expected"); break;
			case 150: s = coco_string_create(L"T_liblist expected"); break;
			case 151: s = coco_string_create(L"T_library expected"); break;
			case 152: s = coco_string_create(L"T_localparam expected"); break;
			case 153: s = coco_string_create(L"T_logic expected"); break;
			case 154: s = coco_string_create(L"T_macromodule expected"); break;
			case 155: s = coco_string_create(L"T_medium expected"); break;
			case 156: s = coco_string_create(L"T_module expected"); break;
			case 157: s = coco_string_create(L"T_nand expected"); break;
			case 158: s = coco_string_create(L"T_negedge expected"); break;
			case 159: s = coco_string_create(L"T_nexttime expected"); break;
			case 160: s = coco_string_create(L"T_nmos expected"); break;
			case 161: s = coco_string_create(L"T_nor expected"); break;
			case 162: s = coco_string_create(L"T_noshowcancelled expected"); break;
			case 163: s = coco_string_create(L"T_not expected"); break;
			case 164: s = coco_string_create(L"T_notif0 expected"); break;
			case 165: s = coco_string_create(L"T_notif1 expected"); break;
			case 166: s = coco_string_create(L"T_or expected"); break;
			case 167: s = coco_string_create(L"T_output expected"); break;
			case 168: s = coco_string_create(L"T_parameter expected"); break;
			case 169: s = coco_string_create(L"T_pmos expected"); break;
			case 170: s = coco_string_create(L"T_posedge expected"); break;
			case 171: s = coco_string_create(L"T_primitive expected"); break;
			case 172: s = coco_string_create(L"T_property expected"); break;
			case 173: s = coco_string_create(L"T_pull0 expected"); break;
			case 174: s = coco_string_create(L"T_pull1 expected"); break;
			case 175: s = coco_string_create(L"T_pulldown expected"); break;
			case 176: s = coco_string_create(L"T_pullup expected"); break;
			case 177: s = coco_string_create(L"T_pulsestyle_ondetect expected"); break;
			case 178: s = coco_string_create(L"T_pulsestyle_onevent expected"); break;
			case 179: s = coco_string_create(L"T_rcmos expected"); break;
			case 180: s = coco_string_create(L"T_real expected"); break;
			case 181: s = coco_string_create(L"T_realtime expected"); break;
			case 182: s = coco_string_create(L"T_reg expected"); break;
			case 183: s = coco_string_create(L"T_reject_on expected"); break;
			case 184: s = coco_string_create(L"T_release expected"); break;
			case 185: s = coco_string_create(L"T_repeat expected"); break;
			case 186: s = coco_string_create(L"T_restrict expected"); break;
			case 187: s = coco_string_create(L"T_rnmos expected"); break;
			case 188: s = coco_string_create(L"T_rpmos expected"); break;
			case 189: s = coco_string_create(L"T_rtran expected"); break;
			case 190: s = coco_string_create(L"T_rtranif0 expected"); break;
			case 191: s = coco_string_create(L"T_rtranif1 expected"); break;
			case 192: s = coco_string_create(L"T_s_always expected"); break;
			case 193: s = coco_string_create(L"T_s_eventually expected"); break;
			case 194: s = coco_string_create(L"T_s_nexttime expected"); break;
			case 195: s = coco_string_create(L"T_s_until expected"); break;
			case 196: s = coco_string_create(L"T_s_until_with expected"); break;
			case 197: s = coco_string_create(L"T_scalared expected"); break;
			case 198: s = coco_string_create(L"T_sequence expected"); break;
			case 199: s = coco_string_create(L"T_showcancelled expected"); break;
			case 200: s = coco_string_create(L"T_signed expected"); break;
			case 201: s = coco_string_create(L"T_small expected"); break;
			case 202: s = coco_string_create(L"T_specify expected"); break;
			case 203: s = coco_string_create(L"T_specparam expected"); break;
			case 204: s = coco_string_create(L"T_strong expected"); break;
			case 205: s = coco_string_create(L"T_strong0 expected"); break;
			case 206: s = coco_string_create(L"T_strong1 expected"); break;
			case 207: s = coco_string_create(L"T_supply0 expected"); break;
			case 208: s = coco_string_create(L"T_supply1 expected"); break;
			case 209: s = coco_string_create(L"T_sync_accept_on expected"); break;
			case 210: s = coco_string_create(L"T_sync_reject_on expected"); break;
			case 211: s = coco_string_create(L"T_table expected"); break;
			case 212: s = coco_string_create(L"T_task expected"); break;
			case 213: s = coco_string_create(L"T_throughout expected"); break;
			case 214: s = coco_string_create(L"T_time expected"); break;
			case 215: s = coco_string_create(L"T_tran expected"); break;
			case 216: s = coco_string_create(L"T_tranif0 expected"); break;
			case 217: s = coco_string_create(L"T_tranif1 expected"); break;
			case 218: s = coco_string_create(L"T_tri expected"); break;
			case 219: s = coco_string_create(L"T_tri0 expected"); break;
			case 220: s = coco_string_create(L"T_tri1 expected"); break;
			case 221: s = coco_string_create(L"T_triand expected"); break;
			case 222: s = coco_string_create(L"T_trior expected"); break;
			case 223: s = coco_string_create(L"T_trireg expected"); break;
			case 224: s = coco_string_create(L"T_until expected"); break;
			case 225: s = coco_string_create(L"T_until_with expected"); break;
			case 226: s = coco_string_create(L"T_use expected"); break;
			case 227: s = coco_string_create(L"T_uwire expected"); break;
			case 228: s = coco_string_create(L"T_vectored expected"); break;
			case 229: s = coco_string_create(L"T_wait expected"); break;
			case 230: s = coco_string_create(L"T_wand expected"); break;
			case 231: s = coco_string_create(L"T_weak expected"); break;
			case 232: s = coco_string_create(L"T_weak0 expected"); break;
			case 233: s = coco_string_create(L"T_weak1 expected"); break;
			case 234: s = coco_string_create(L"T_while expected"); break;
			case 235: s = coco_string_create(L"T_wire expected"); break;
			case 236: s = coco_string_create(L"T_within expected"); break;
			case 237: s = coco_string_create(L"T_wor expected"); break;
			case 238: s = coco_string_create(L"T_xnor expected"); break;
			case 239: s = coco_string_create(L"T_xor expected"); break;
			case 240: s = coco_string_create(L"T_Specials_ expected"); break;
			case 241: s = coco_string_create(L"T_Attribute expected"); break;
			case 242: s = coco_string_create(L"T_Comment expected"); break;
			case 243: s = coco_string_create(L"T_MacroUsage expected"); break;
			case 244: s = coco_string_create(L"T_Section expected"); break;
			case 245: s = coco_string_create(L"T_SectionEnd expected"); break;
			case 246: s = coco_string_create(L"T_CoDi expected"); break;
			case 247: s = coco_string_create(L"T_LineCont expected"); break;
			case 248: s = coco_string_create(L"T_Realnum expected"); break;
			case 249: s = coco_string_create(L"T_Natural expected"); break;
			case 250: s = coco_string_create(L"T_SizedBased expected"); break;
			case 251: s = coco_string_create(L"T_BasedInt expected"); break;
			case 252: s = coco_string_create(L"T_BaseFormat expected"); break;
			case 253: s = coco_string_create(L"T_BaseValue expected"); break;
			case 254: s = coco_string_create(L"T_SysName expected"); break;
			case 255: s = coco_string_create(L"T_Ident expected"); break;
			case 256: s = coco_string_create(L"T_Str expected"); break;
			case 257: s = coco_string_create(L"T_Eof expected"); break;
			case 258: s = coco_string_create(L"T_MaxToken_ expected"); break;
			case 259: s = coco_string_create(L"??? expected"); break;
			case 260: s = coco_string_create(L"invalid module_declaration"); break;
			case 261: s = coco_string_create(L"invalid udp_declaration"); break;
			case 262: s = coco_string_create(L"invalid file_path_spec"); break;
			case 263: s = coco_string_create(L"invalid file_path_glyph_"); break;
			case 264: s = coco_string_create(L"invalid module_keyword"); break;
			case 265: s = coco_string_create(L"invalid port_declaration"); break;
			case 266: s = coco_string_create(L"invalid non_port_module_item"); break;
			case 267: s = coco_string_create(L"invalid parameter_declaration"); break;
			case 268: s = coco_string_create(L"invalid port"); break;
			case 269: s = coco_string_create(L"invalid port_expression"); break;
			case 270: s = coco_string_create(L"invalid input_declaration"); break;
			case 271: s = coco_string_create(L"invalid output_declaration"); break;
			case 272: s = coco_string_create(L"invalid module_or_generate_item"); break;
			case 273: s = coco_string_create(L"invalid module_or_generate_item_declaration"); break;
			case 274: s = coco_string_create(L"invalid local_parameter_declaration"); break;
			case 275: s = coco_string_create(L"invalid gate_instantiation"); break;
			case 276: s = coco_string_create(L"invalid concurrent_assertion_statement"); break;
			case 277: s = coco_string_create(L"invalid loop_generate_construct"); break;
			case 278: s = coco_string_create(L"invalid conditional_generate_construct"); break;
			case 279: s = coco_string_create(L"invalid net_declaration"); break;
			case 280: s = coco_string_create(L"invalid config_rule_statement"); break;
			case 281: s = coco_string_create(L"invalid config_rule_statement"); break;
			case 282: s = coco_string_create(L"invalid config_rule_statement"); break;
			case 283: s = coco_string_create(L"invalid parameter_type"); break;
			case 284: s = coco_string_create(L"invalid net_type"); break;
			case 285: s = coco_string_create(L"invalid reg_"); break;
			case 286: s = coco_string_create(L"invalid output_variable_type"); break;
			case 287: s = coco_string_create(L"invalid drive_strength"); break;
			case 288: s = coco_string_create(L"invalid drive_strength"); break;
			case 289: s = coco_string_create(L"invalid delay3"); break;
			case 290: s = coco_string_create(L"invalid list_of_net_identifiers_of_decl_assignments_"); break;
			case 291: s = coco_string_create(L"invalid list_of_net_identifiers_of_decl_assignments_"); break;
			case 292: s = coco_string_create(L"invalid charge_strength"); break;
			case 293: s = coco_string_create(L"invalid expression"); break;
			case 294: s = coco_string_create(L"invalid real_type"); break;
			case 295: s = coco_string_create(L"invalid variable_type"); break;
			case 296: s = coco_string_create(L"invalid strength0"); break;
			case 297: s = coco_string_create(L"invalid strength1"); break;
			case 298: s = coco_string_create(L"invalid delay_value"); break;
			case 299: s = coco_string_create(L"invalid delay2"); break;
			case 300: s = coco_string_create(L"invalid specparam_assignment"); break;
			case 301: s = coco_string_create(L"invalid function_range_or_type"); break;
			case 302: s = coco_string_create(L"invalid block_item_declaration"); break;
			case 303: s = coco_string_create(L"invalid tf_input_declaration"); break;
			case 304: s = coco_string_create(L"invalid task_item_declaration"); break;
			case 305: s = coco_string_create(L"invalid statement_or_null"); break;
			case 306: s = coco_string_create(L"invalid tf_output_declaration"); break;
			case 307: s = coco_string_create(L"invalid tf_inout_declaration"); break;
			case 308: s = coco_string_create(L"invalid task_port_item"); break;
			case 309: s = coco_string_create(L"invalid task_port_type"); break;
			case 310: s = coco_string_create(L"invalid cmos_switchtype"); break;
			case 311: s = coco_string_create(L"invalid enable_gatetype"); break;
			case 312: s = coco_string_create(L"invalid mos_switchtype"); break;
			case 313: s = coco_string_create(L"invalid n_input_gatetype"); break;
			case 314: s = coco_string_create(L"invalid n_output_gatetype"); break;
			case 315: s = coco_string_create(L"invalid pass_en_switchtype"); break;
			case 316: s = coco_string_create(L"invalid pass_switchtype"); break;
			case 317: s = coco_string_create(L"invalid pulldown_strength"); break;
			case 318: s = coco_string_create(L"invalid pulldown_strength"); break;
			case 319: s = coco_string_create(L"invalid pullup_strength"); break;
			case 320: s = coco_string_create(L"invalid pullup_strength"); break;
			case 321: s = coco_string_create(L"invalid net_lvalue"); break;
			case 322: s = coco_string_create(L"invalid parameter_value_assignment_or_delay2_"); break;
			case 323: s = coco_string_create(L"invalid port_connection_or_output_terminal_"); break;
			case 324: s = coco_string_create(L"invalid genvar_expression"); break;
			case 325: s = coco_string_create(L"invalid unary_operator"); break;
			case 326: s = coco_string_create(L"invalid binary_operator"); break;
			case 327: s = coco_string_create(L"invalid primary"); break;
			case 328: s = coco_string_create(L"invalid generate_block_or_null"); break;
			case 329: s = coco_string_create(L"invalid case_generate_item"); break;
			case 330: s = coco_string_create(L"invalid udp_port_declaration"); break;
			case 331: s = coco_string_create(L"invalid udp_body_entry_"); break;
			case 332: s = coco_string_create(L"invalid udp_body_entry_"); break;
			case 333: s = coco_string_create(L"invalid entry_symbol_"); break;
			case 334: s = coco_string_create(L"invalid number"); break;
			case 335: s = coco_string_create(L"invalid number"); break;
			case 336: s = coco_string_create(L"invalid number"); break;
			case 337: s = coco_string_create(L"invalid statement"); break;
			case 338: s = coco_string_create(L"invalid assignment_or_task_enable_"); break;
			case 339: s = coco_string_create(L"invalid variable_lvalue"); break;
			case 340: s = coco_string_create(L"invalid delay_or_event_control"); break;
			case 341: s = coco_string_create(L"invalid procedural_continuous_assignments"); break;
			case 342: s = coco_string_create(L"invalid lvalue_"); break;
			case 343: s = coco_string_create(L"invalid case_statement"); break;
			case 344: s = coco_string_create(L"invalid loop_statement"); break;
			case 345: s = coco_string_create(L"invalid delay_control"); break;
			case 346: s = coco_string_create(L"invalid event_control"); break;
			case 347: s = coco_string_create(L"invalid event_control"); break;
			case 348: s = coco_string_create(L"invalid event_expression"); break;
			case 349: s = coco_string_create(L"invalid procedural_timing_control"); break;
			case 350: s = coco_string_create(L"invalid case_item"); break;
			case 351: s = coco_string_create(L"invalid specify_item"); break;
			case 352: s = coco_string_create(L"invalid pulsestyle_declaration"); break;
			case 353: s = coco_string_create(L"invalid showcancelled_declaration"); break;
			case 354: s = coco_string_create(L"invalid path_declaration"); break;
			case 355: s = coco_string_create(L"invalid system_timing_check"); break;
			case 356: s = coco_string_create(L"invalid path_description_"); break;
			case 357: s = coco_string_create(L"invalid path_description_"); break;
			case 358: s = coco_string_create(L"invalid path_description_"); break;
			case 359: s = coco_string_create(L"invalid state_dependent_path_declaration"); break;
			case 360: s = coco_string_create(L"invalid edge_identifier"); break;
			case 361: s = coco_string_create(L"invalid polarity_operator"); break;
			case 362: s = coco_string_create(L"invalid module_path_expression"); break;
			case 363: s = coco_string_create(L"invalid timing_check_event_control"); break;
			case 364: s = coco_string_create(L"invalid single_or_multiple_concatenation_"); break;
			case 365: s = coco_string_create(L"invalid mod_path_single_or_multi_concat_"); break;
			case 366: s = coco_string_create(L"invalid module_path_primary"); break;
			case 367: s = coco_string_create(L"invalid unary_module_path_operator"); break;
			case 368: s = coco_string_create(L"invalid binary_module_path_operator"); break;
			case 369: s = coco_string_create(L"invalid clocking_event"); break;
			case 370: s = coco_string_create(L"invalid sequence_expr"); break;
			case 371: s = coco_string_create(L"invalid sequence_expr"); break;
			case 372: s = coco_string_create(L"invalid immediate_assertion_statement_"); break;
			case 373: s = coco_string_create(L"invalid property_expr"); break;
			case 374: s = coco_string_create(L"invalid value_range"); break;
			case 375: s = coco_string_create(L"invalid dist_weight"); break;
			case 376: s = coco_string_create(L"invalid property_case_item"); break;
			case 377: s = coco_string_create(L"invalid cycle_delay_const_range_expression"); break;
			case 378: s = coco_string_create(L"invalid cycle_delay_range"); break;
			case 379: s = coco_string_create(L"invalid boolean_abbrev"); break;
			case 380: s = coco_string_create(L"invalid consecutive_repetition"); break;

		default:
		{
			s = QString( "generic error %1").arg(n);
		}
		break;
	}
    if( !str.isEmpty() )
        s = QString("%1 %2").arg(s).arg(str);
	if( err )
		err->error(Vl::Errors::Syntax, sourcePath, line, col, s);
	else
		qCritical() << "Error Parser" << line << col << s;
	//count++;
}


} // namespace

