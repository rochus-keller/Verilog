

// This file was automatically generated by Coco/R; don't modify it.
#if !defined(Coco_COCO_PARSER_H__)
#define Coco_COCO_PARSER_H__

#include <QStack>
#include <VlSynTree.h>


#include "VlPpLexer.h"

namespace Coco {


class Errors {
public:
	int count;			// number of errors detected

	Errors();
    static void SynErr(const QString& sourcePath, int line, int col, int n, Vl::Errors* err, const char* ctx, const QString& = QString() );
	void Error(int line, int col, const char *s);
	void Warning(int line, int col, const char *s);
	void Warning(const char *s);
	void Exception(const char *s);

}; // Errors

class Parser {
private:
	enum {
		_EOF=0,
		_T_Literals_=1,
		_T_Bang=2,
		_T_BangEq=3,
		_T_Bang2Eq=4,
		_T_Hash=5,
		_T_2Hash=6,
		_T_2HashLbrackStarRbrack=7,
		_T_2HashLbrackPlusRbrack=8,
		_T_Hash2Minus=9,
		_T_Hash2Eq=10,
		_T_Dlr=11,
		_T_Percent=12,
		_T_Amp=13,
		_T_2Amp=14,
		_T_3Amp=15,
		_T_Lpar=16,
		_T_Latt=17,
		_T_Rpar=18,
		_T_Star=19,
		_T_Ratt=20,
		_T_2Star=21,
		_T_Rcmt=22,
		_T_StarGt=23,
		_T_Plus=24,
		_T_PlusColon=25,
		_T_Comma=26,
		_T_Minus=27,
		_T_MinusColon=28,
		_T_MinusGt=29,
		_T_Dot=30,
		_T_Slash=31,
		_T_Lcmt=32,
		_T_Colon=33,
		_T_ColonSlash=34,
		_T_ColonEq=35,
		_T_Semi=36,
		_T_Lt=37,
		_T_2Lt=38,
		_T_3Lt=39,
		_T_Leq=40,
		_T_Eq=41,
		_T_2Eq=42,
		_T_3Eq=43,
		_T_EqGt=44,
		_T_Gt=45,
		_T_Geq=46,
		_T_2Gt=47,
		_T_3Gt=48,
		_T_Qmark=49,
		_T_At=50,
		_T_Lbrack=51,
		_T_LbrackStar=52,
		_T_Lbrack2Star=53,
		_T_Lbrack2Plus=54,
		_T_Lbrack2Minus=55,
		_T_LbrackEq=56,
		_T_Rbrack=57,
		_T_Hat=58,
		_T_HatTilde=59,
		_T_Lbrace=60,
		_T_Bar=61,
		_T_Bar2Minus=62,
		_T_Bar2Eq=63,
		_T_2Bar=64,
		_T_Rbrace=65,
		_T_Tilde=66,
		_T_TildeAmp=67,
		_T_TildeHat=68,
		_T_TildeBar=69,
		_T_Keywords_=70,
		_T_dlr_fullskew=71,
		_T_dlr_hold=72,
		_T_dlr_nochange=73,
		_T_dlr_period=74,
		_T_dlr_recovery=75,
		_T_dlr_recrem=76,
		_T_dlr_removal=77,
		_T_dlr_setup=78,
		_T_dlr_setuphold=79,
		_T_dlr_skew=80,
		_T_dlr_timeskew=81,
		_T_dlr_width=82,
		_T_PATHPULSE_dlr=83,
		_T_accept_on=84,
		_T_always=85,
		_T_and=86,
		_T_assert=87,
		_T_assign=88,
		_T_assume=89,
		_T_automatic=90,
		_T_begin=91,
		_T_buf=92,
		_T_bufif0=93,
		_T_bufif1=94,
		_T_case=95,
		_T_casex=96,
		_T_casez=97,
		_T_cell=98,
		_T_cmos=99,
		_T_config=100,
		_T_cover=101,
		_T_deassign=102,
		_T_default=103,
		_T_defparam=104,
		_T_design=105,
		_T_disable=106,
		_T_dist=107,
		_T_edge=108,
		_T_else=109,
		_T_end=110,
		_T_endcase=111,
		_T_endconfig=112,
		_T_endfunction=113,
		_T_endgenerate=114,
		_T_endmodule=115,
		_T_endprimitive=116,
		_T_endspecify=117,
		_T_endtable=118,
		_T_endtask=119,
		_T_event=120,
		_T_eventually=121,
		_T_final=122,
		_T_for=123,
		_T_force=124,
		_T_forever=125,
		_T_fork=126,
		_T_function=127,
		_T_generate=128,
		_T_genvar=129,
		_T_highz0=130,
		_T_highz1=131,
		_T_if=132,
		_T_iff=133,
		_T_ifnone=134,
		_T_implies=135,
		_T_incdir=136,
		_T_include=137,
		_T_initial=138,
		_T_inout=139,
		_T_input=140,
		_T_instance=141,
		_T_integer=142,
		_T_intersect=143,
		_T_join=144,
		_T_large=145,
		_T_liblist=146,
		_T_library=147,
		_T_localparam=148,
		_T_logic=149,
		_T_macromodule=150,
		_T_medium=151,
		_T_module=152,
		_T_nand=153,
		_T_negedge=154,
		_T_nexttime=155,
		_T_nmos=156,
		_T_nor=157,
		_T_noshowcancelled=158,
		_T_not=159,
		_T_notif0=160,
		_T_notif1=161,
		_T_or=162,
		_T_output=163,
		_T_parameter=164,
		_T_pmos=165,
		_T_posedge=166,
		_T_primitive=167,
		_T_property=168,
		_T_pull0=169,
		_T_pull1=170,
		_T_pulldown=171,
		_T_pullup=172,
		_T_pulsestyle_ondetect=173,
		_T_pulsestyle_onevent=174,
		_T_rcmos=175,
		_T_real=176,
		_T_realtime=177,
		_T_reg=178,
		_T_reject_on=179,
		_T_release=180,
		_T_repeat=181,
		_T_restrict=182,
		_T_rnmos=183,
		_T_rpmos=184,
		_T_rtran=185,
		_T_rtranif0=186,
		_T_rtranif1=187,
		_T_s_always=188,
		_T_s_eventually=189,
		_T_s_nexttime=190,
		_T_s_until=191,
		_T_s_until_with=192,
		_T_scalared=193,
		_T_sequence=194,
		_T_showcancelled=195,
		_T_signed=196,
		_T_small=197,
		_T_specify=198,
		_T_specparam=199,
		_T_strong=200,
		_T_strong0=201,
		_T_strong1=202,
		_T_supply0=203,
		_T_supply1=204,
		_T_sync_accept_on=205,
		_T_sync_reject_on=206,
		_T_table=207,
		_T_task=208,
		_T_throughout=209,
		_T_time=210,
		_T_tran=211,
		_T_tranif0=212,
		_T_tranif1=213,
		_T_tri=214,
		_T_tri0=215,
		_T_tri1=216,
		_T_triand=217,
		_T_trior=218,
		_T_trireg=219,
		_T_until=220,
		_T_until_with=221,
		_T_use=222,
		_T_uwire=223,
		_T_vectored=224,
		_T_wait=225,
		_T_wand=226,
		_T_weak=227,
		_T_weak0=228,
		_T_weak1=229,
		_T_while=230,
		_T_wire=231,
		_T_within=232,
		_T_wor=233,
		_T_xnor=234,
		_T_xor=235,
		_T_Specials_=236,
		_T_Attribute=237,
		_T_Comment=238,
		_T_MacroUsage=239,
		_T_Section=240,
		_T_SectionEnd=241,
		_T_CoDi=242,
		_T_LineCont=243,
		_T_Realnum=244,
		_T_Natural=245,
		_T_SizedBased=246,
		_T_BasedInt=247,
		_T_BaseFormat=248,
		_T_BaseValue=249,
		_T_SysName=250,
		_T_Ident=251,
		_T_Str=252,
		_T_Eof=253,
		_T_MaxToken_=254
	};
	int maxT;

	int errDist;
	int minErrDist;

	void SynErr(int n, const char* ctx = 0);
	void Get();
	void Expect(int n, const char* ctx = 0);
	bool StartOf(int s);
	void ExpectWeak(int n, int follow);
	bool WeakSeparator(int n, int syFol, int repFol);

public:
	Vl::PpLexer *scanner;
	Vl::Errors  *errors;

	Vl::Token d_cur;
	Vl::Token d_next;
	struct TokDummy
	{
		int kind;
	};
	TokDummy d_dummy;
	TokDummy *la;			// lookahead token
	QList<Vl::Token> d_sections;
	
	int peek( quint8 la = 1 );

    void RunParser()
    {
        d_stack.push(&d_root);
        Parse();
        d_stack.pop();
    }
    
Vl::SynTree d_root;
	QStack<Vl::SynTree*> d_stack;
	void addTerminal() {
		Vl::SynTree* n = new Vl::SynTree( d_cur ); d_stack.top()->d_children.append(n);
	}



	Parser(Vl::PpLexer *scanner,Vl::Errors*);
	~Parser();
	void SemErr(const char* msg);

	void Verilog05();
	void module_declaration();
	void udp_declaration();
	void config_declaration();
	void library_declaration();
	void include_statement();
	void library_identifier();
	void file_path_spec();
	void identifier();
	void string();
	void module_keyword();
	void module_identifier();
	void module_parameter_port_list();
	void list_of_ports();
	void list_of_port_declarations();
	void module_item();
	void parameter_declaration();
	void port();
	void port_declaration();
	void port_expression();
	void port_identifier();
	void port_reference();
	void constant_range_expression();
	void inout_declaration();
	void input_declaration();
	void output_declaration();
	void non_port_module_item();
	void module_or_generate_item();
	void module_or_generate_item_declaration();
	void local_parameter_declaration();
	void parameter_override();
	void continuous_assign();
	void gate_instantiation();
	void block_identifier();
	void concurrent_assertion_statement();
	void module_or_udp_instantiation();
	void initial_construct();
	void always_construct();
	void loop_generate_construct();
	void conditional_generate_construct();
	void net_declaration();
	void reg_declaration();
	void integer_declaration();
	void real_declaration();
	void time_declaration();
	void realtime_declaration();
	void event_declaration();
	void genvar_declaration();
	void task_declaration();
	void function_declaration();
	void generate_region();
	void specify_block();
	void specparam_declaration();
	void list_of_defparam_assignments();
	void config_identifier();
	void design_statement();
	void config_rule_statement();
	void cell_identifier();
	void default_clause();
	void inst_clause();
	void cell_clause();
	void liblist_clause();
	void use_clause();
	void inst_name();
	void topmodule_identifier();
	void instance_identifier();
	void range();
	void parameter_type();
	void list_of_param_assignments();
	void list_of_specparam_assignments();
	void net_type();
	void list_of_port_identifiers();
	void reg_or_logic();
	void list_of_variable_port_identifiers();
	void output_variable_type();
	void list_of_event_identifiers();
	void list_of_variable_identifiers();
	void list_of_net_decl_assignments_or_identifiers();
	void net_identifier();
	void dimension();
	void expression();
	void drive_strength();
	void charge_strength();
	void delay3();
	void list_of_real_identifiers();
	void real_type();
	void real_identifier();
	void constant_expression();
	void variable_type();
	void variable_identifier();
	void strength0();
	void strength1();
	void delay();
	void delay_value();
	void mintypmax_expression();
	void expression_nlr();
	void delay2();
	void unsigned_or_real_number();
	void defparam_assignment();
	void event_identifier();
	void param_assignment();
	void specparam_assignment();
	void hierarchical_parameter_identifier();
	void constant_mintypmax_expression();
	void parameter_identifier();
	void specparam_identifier();
	void pulse_control_specparam();
	void reject_limit_value();
	void error_limit_value();
	void limit_value();
	void dimension_constant_expression();
	void msb_constant_expression();
	void lsb_constant_expression();
	void function_range_or_type();
	void function_identifier();
	void function_port_list();
	void function_item_declaration();
	void function_statement();
	void block_item_declaration();
	void tf_input_declaration();
	void task_identifier();
	void task_port_list();
	void task_item_declaration();
	void statement_or_null();
	void tf_output_declaration();
	void tf_inout_declaration();
	void task_port_item();
	void task_port_type();
	void block_reg_declaration();
	void block_integer_declaration();
	void block_time_declaration();
	void block_real_declaration();
	void block_realtime_declaration();
	void list_of_block_variable_identifiers();
	void list_of_block_real_identifiers();
	void block_variable_type();
	void block_real_type();
	void cmos_switchtype();
	void cmos_switch_instance();
	void enable_gatetype();
	void enable_gate_instance();
	void mos_switchtype();
	void mos_switch_instance();
	void n_input_gatetype();
	void n_input_gate_instance();
	void n_output_gatetype();
	void n_output_gate_instance();
	void pass_en_switchtype();
	void pass_enable_switch_instance();
	void pass_switchtype();
	void pass_switch_instance();
	void pulldown_strength();
	void pull_gate_instance();
	void pullup_strength();
	void name_of_gate_instance();
	void output_terminal();
	void input_terminal();
	void ncontrol_terminal();
	void pcontrol_terminal();
	void enable_terminal();
	void input_or_output_terminal();
	void expression_2();
	void inout_terminal();
	void gate_instance_identifier();
	void net_lvalue();
	void named_parameter_assignment();
	void list_of_genvar_identifiers();
	void genvar_identifier();
	void genvar_initialization();
	void genvar_expression();
	void genvar_iteration();
	void generate_block();
	void unary_operator();
	void genvar_primary();
	void genvar_expression_nlr();
	void binary_operator();
	void constant_primary();
	void if_generate_construct();
	void case_generate_construct();
	void generate_block_or_null();
	void case_generate_item();
	void generate_block_identifier();
	void udp_identifier();
	void udp_port_list();
	void udp_declaration_port_list();
	void udp_port_declaration();
	void udp_body();
	void output_port_identifier();
	void input_port_identifier();
	void udp_output_declaration();
	void udp_input_declaration();
	void udp_reg_declaration();
	void udp_initial_statement();
	void sequential_or_combinatorial_entry();
	void init_val();
	void level_or_edge_symbol();
	void level_symbol();
	void number();
	void edge_descriptor();
	void scalar_constant();
	void list_of_net_assignments();
	void net_assignment();
	void statement();
	void procedural_continuous_assignments();
	void variable_assignment();
	void variable_lvalue();
	void variable_or_net_lvalue();
	void par_block();
	void seq_block();
	void blocking_or_nonblocking_assignment_or_task_enable();
	void delay_or_event_control();
	void case_statement();
	void conditional_statement();
	void disable_statement();
	void event_trigger();
	void loop_statement();
	void procedural_timing_control_statement();
	void system_task_enable();
	void wait_statement();
	void procedural_assertion_statement();
	void delay_control();
	void event_control();
	void hierarchical_task_or_block_identifier();
	void hierarchical_identifier();
	void event_expression();
	void hierarchical_event_identifier();
	void hierarchical_identifier_range();
	void event_expression_nlr();
	void procedural_timing_control();
	void case_item();
	void system_task_identifier();
	void specify_item();
	void pulsestyle_declaration();
	void showcancelled_declaration();
	void path_declaration();
	void system_timing_check();
	void list_of_path_outputs();
	void simple_or_edge_sensitive_path_declaration();
	void state_dependent_path_declaration();
	void parallel_or_full_path_description();
	void list_of_path_inputs();
	void polarity_operator();
	void specify_output_terminal_descriptor();
	void simple_path_declaration();
	void path_delay_value();
	void specify_input_terminal_descriptor();
	void input_identifier();
	void output_identifier();
	void input_or_inout_port_identifier();
	void output_or_inout_port_identifier();
	void list_of_path_delay_expressions();
	void path_delay_expression();
	void edge_identifier();
	void data_source_expression();
	void simple_or_edge_sensitive_path_description();
	void module_path_expression();
	void dlr_setup_timing_check();
	void dlr_hold_timing_check();
	void dlr_setuphold_timing_check();
	void dlr_recovery_timing_check();
	void dlr_removal_timing_check();
	void dlr_recrem_timing_check();
	void dlr_skew_timing_check();
	void dlr_timeskew_timing_check();
	void dlr_fullskew_timing_check();
	void dlr_period_timing_check();
	void dlr_width_timing_check();
	void dlr_nochange_timing_check();
	void data_event();
	void reference_event();
	void timing_check_limit();
	void notifier();
	void stamptime_condition();
	void checktime_condition();
	void delayed_reference();
	void delayed_data();
	void event_based_flag();
	void remain_active_flag();
	void controlled_reference_event();
	void threshold();
	void start_edge_offset();
	void end_edge_offset();
	void controlled_timing_check_event();
	void timing_check_event();
	void terminal_identifier();
	void timing_check_event_control();
	void specify_terminal_descriptor();
	void timing_check_condition();
	void edge_control_specifier();
	void specify_input_or_output_terminal_descriptor();
	void scalar_timing_check_condition();
	void constant_expression_nlr();
	void width_constant_expression();
	void primary();
	void unary_module_path_operator();
	void module_path_primary();
	void module_path_expression_nlr();
	void binary_module_path_operator();
	void module_path_mintypmax_expression();
	void range_expression();
	void system_name();
	void system_function_identifier();
	void hierarchical_identifier_range_const();
	void real_number();
	void natural_number();
	void based_number();
	void base_format();
	void base_value();
	void sizedbased_number();
	void parameter_value_assignment_or_delay2();
	void module_or_udp_instance();
	void port_connection_or_output_terminal();
	void primary_2();
	void concurrent_or_immediate_assert_statement();
	void property_spec();
	void action_block();
	void concurrent_or_immediate_assume_statement();
	void concurrent_or_immediate_cover_statement();
	void cover_sequence_statement();
	void clocking_event();
	void expression_or_dist();
	void sequence_expr();
	void restrict_property_statement();
	void simple_or_deferred_or_property_immediate_assertion_statement();
	void property_expr();
	void dist_list();
	void dist_item();
	void value_range();
	void dist_weight();
	void property_expr_nlr();
	void property_case_item();
	void cycle_delay_const_range_expression();
	void constant_range();
	void cycle_delay_range();
	void sequence_expr_nlr();
	void boolean_abbrev();
	void consecutive_repetition();
	void non_consecutive_repetition();
	void goto_repetition();
	void const_or_range_expression();

	void Parse();

}; // end Parser

} // namespace


#endif

