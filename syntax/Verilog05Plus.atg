// This file was automatically generated by EbnfStudio; don't modify it!
#include <QStack>
#include <Verilog/VlSynTree.h>
COMPILER Verilog05

	Vl::SynTree d_root;
	QStack<Vl::SynTree*> d_stack;
	void addTerminal() {
		Vl::SynTree* n = new Vl::SynTree( d_cur ); d_stack.top()->d_children.append(n);
	}

TOKENS
  T_Literals_
  T_Bang
  T_BangEq
  T_Bang2Eq
  T_Hash
  T_2Hash
  T_2HashLbrackStarRbrack
  T_2HashLbrackPlusRbrack
  T_Hash2Minus
  T_Hash2Eq
  T_Dlr
  T_Percent
  T_Amp
  T_2Amp
  T_3Amp
  T_Lpar
  T_Latt
  T_Rpar
  T_Star
  T_Ratt
  T_2Star
  T_Rcmt
  T_StarGt
  T_Plus
  T_PlusColon
  T_Comma
  T_Minus
  T_MinusColon
  T_MinusGt
  T_Dot
  T_Slash
  T_Lcmt
  T_Colon
  T_ColonSlash
  T_ColonEq
  T_Semi
  T_Lt
  T_2Lt
  T_3Lt
  T_Leq
  T_Eq
  T_2Eq
  T_3Eq
  T_EqGt
  T_Gt
  T_Geq
  T_2Gt
  T_3Gt
  T_Qmark
  T_At
  T_Lbrack
  T_LbrackStar
  T_Lbrack2Star
  T_Lbrack2Plus
  T_Lbrack2Minus
  T_LbrackEq
  T_Rbrack
  T_Hat
  T_HatTilde
  T_Lbrace
  T_Bar
  T_Bar2Minus
  T_Bar2Eq
  T_2Bar
  T_Rbrace
  T_Tilde
  T_TildeAmp
  T_TildeHat
  T_TildeBar
  T_Keywords_
  T_dlr_fullskew
  T_dlr_hold
  T_dlr_nochange
  T_dlr_period
  T_dlr_recovery
  T_dlr_recrem
  T_dlr_removal
  T_dlr_setup
  T_dlr_setuphold
  T_dlr_skew
  T_dlr_timeskew
  T_dlr_width
  T_PATHPULSE_dlr
  T_accept_on
  T_always
  T_and
  T_assert
  T_assign
  T_assume
  T_automatic
  T_begin
  T_buf
  T_bufif0
  T_bufif1
  T_case
  T_casex
  T_casez
  T_cell
  T_cmos
  T_config
  T_cover
  T_deassign
  T_default
  T_defparam
  T_design
  T_disable
  T_dist
  T_edge
  T_else
  T_end
  T_endcase
  T_endconfig
  T_endfunction
  T_endgenerate
  T_endmodule
  T_endprimitive
  T_endspecify
  T_endtable
  T_endtask
  T_event
  T_eventually
  T_final
  T_for
  T_force
  T_forever
  T_fork
  T_function
  T_generate
  T_genvar
  T_highz0
  T_highz1
  T_if
  T_iff
  T_ifnone
  T_implies
  T_incdir
  T_include
  T_initial
  T_inout
  T_input
  T_instance
  T_integer
  T_intersect
  T_join
  T_large
  T_liblist
  T_library
  T_localparam
  T_logic
  T_macromodule
  T_medium
  T_module
  T_nand
  T_negedge
  T_nexttime
  T_nmos
  T_nor
  T_noshowcancelled
  T_not
  T_notif0
  T_notif1
  T_or
  T_output
  T_parameter
  T_pmos
  T_posedge
  T_primitive
  T_property
  T_pull0
  T_pull1
  T_pulldown
  T_pullup
  T_pulsestyle_ondetect
  T_pulsestyle_onevent
  T_rcmos
  T_real
  T_realtime
  T_reg
  T_reject_on
  T_release
  T_repeat
  T_restrict
  T_rnmos
  T_rpmos
  T_rtran
  T_rtranif0
  T_rtranif1
  T_s_always
  T_s_eventually
  T_s_nexttime
  T_s_until
  T_s_until_with
  T_scalared
  T_sequence
  T_showcancelled
  T_signed
  T_small
  T_specify
  T_specparam
  T_strong
  T_strong0
  T_strong1
  T_supply0
  T_supply1
  T_sync_accept_on
  T_sync_reject_on
  T_table
  T_task
  T_throughout
  T_time
  T_tran
  T_tranif0
  T_tranif1
  T_tri
  T_tri0
  T_tri1
  T_triand
  T_trior
  T_trireg
  T_until
  T_until_with
  T_use
  T_uwire
  T_vectored
  T_wait
  T_wand
  T_weak
  T_weak0
  T_weak1
  T_while
  T_wire
  T_within
  T_wor
  T_xnor
  T_xor
  T_Specials_
  T_Attribute
  T_Comment
  T_MacroUsage
  T_Section
  T_SectionEnd
  T_CoDi
  T_LineCont
  T_Realnum
  T_Natural
  T_SizedBased
  T_BasedInt
  T_BaseFormat
  T_BaseValue
  T_SysName
  T_Ident
  T_Str
  T_Eof
  T_MaxToken_

PRODUCTIONS

Verilog05 = 
    (. d_stack.push(&d_root); .) ({ module_declaration 
    | udp_declaration 
    | config_declaration 
    | library_declaration 
    | include_statement } ) (. d_stack.pop(); .) 
    .

library_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_library_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_library (. addTerminal(); .) library_identifier file_path_spec { T_Comma (. addTerminal(); .) file_path_spec } [ T_Minus (. addTerminal(); .) T_incdir (. addTerminal(); .) file_path_spec { T_Comma (. addTerminal(); .) file_path_spec } ] T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

include_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_include_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_include (. addTerminal(); .) file_path_spec T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

file_path_spec = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_file_path_spec, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( identifier 
    | string ) (. d_stack.pop(); .) 
    .

module_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( module_keyword module_identifier [ module_parameter_port_list ] [ T_Lpar (. addTerminal(); .) [ list_of_ports | list_of_port_declarations ] T_Rpar (. addTerminal(); .) ] T_Semi (. addTerminal(); .) { module_item } T_endmodule (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

module_keyword = 
    T_module (. addTerminal(); .) 
    | T_macromodule (. addTerminal(); .) 
    .

module_parameter_port_list = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_parameter_port_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_Hash (. addTerminal(); .) T_Lpar (. addTerminal(); .) parameter_declaration { T_Comma (. addTerminal(); .) parameter_declaration } T_Rpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

list_of_ports = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_ports, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( port { T_Comma (. addTerminal(); .) [ port ] } ) (. d_stack.pop(); .) 
    .

list_of_port_declarations = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_port_declarations, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( port_declaration { T_Comma (. addTerminal(); .) port_declaration } ) (. d_stack.pop(); .) 
    .

port = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_port, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( port_expression 
    | ( T_Dot (. addTerminal(); .) port_identifier T_Lpar (. addTerminal(); .) [ port_expression ] T_Rpar (. addTerminal(); .) ) ) (. d_stack.pop(); .) 
    .

port_expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_port_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( port_reference 
    | ( T_Lbrace (. addTerminal(); .) port_reference { T_Comma (. addTerminal(); .) port_reference } T_Rbrace (. addTerminal(); .) ) ) (. d_stack.pop(); .) 
    .

port_reference = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_port_reference, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( port_identifier [ T_Lbrack (. addTerminal(); .) constant_range_expression T_Rbrack (. addTerminal(); .) ] ) (. d_stack.pop(); .) 
    .

port_declaration = 
    ( inout_declaration | input_declaration | output_declaration ) 
    .

module_item = 
    ( port_declaration T_Semi (. addTerminal(); .) ) 
    | non_port_module_item 
    .

module_or_generate_item = 
    ( module_or_generate_item_declaration ) 
    | ( local_parameter_declaration T_Semi (. addTerminal(); .) ) 
    | ( parameter_override ) 
    | ( continuous_assign ) 
    | ( gate_instantiation ) 
    | ( IF( peek(1) == _T_Ident && peek(2) == _T_Colon ) block_identifier T_Colon (. addTerminal(); .) concurrent_assertion_statement ) 
    | ( module_or_udp_instantiation ) 
    | ( initial_construct ) 
    | ( always_construct ) 
    | ( loop_generate_construct ) 
    | ( conditional_generate_construct ) 
    | ( concurrent_assertion_statement ) 
    .

module_or_generate_item_declaration = 
    net_declaration 
    | reg_declaration 
    | integer_declaration 
    | real_declaration 
    | time_declaration 
    | realtime_declaration 
    | event_declaration 
    | genvar_declaration 
    | task_declaration 
    | function_declaration 
    .

non_port_module_item = 
    module_or_generate_item 
    | generate_region 
    | specify_block 
    | ( parameter_declaration T_Semi (. addTerminal(); .) ) 
    | ( specparam_declaration ) 
    .

parameter_override = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_parameter_override, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_defparam (. addTerminal(); .) list_of_defparam_assignments T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

config_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_config_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_config (. addTerminal(); .) config_identifier T_Semi (. addTerminal(); .) design_statement { config_rule_statement } T_endconfig (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

design_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_design_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_design (. addTerminal(); .) { [ IF( peek(1) == _T_Ident && peek(2) == _T_Dot ) library_identifier T_Dot (. addTerminal(); .) ] cell_identifier } T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

config_rule_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_config_rule_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( default_clause | inst_clause | cell_clause ) ( liblist_clause | use_clause ) T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

default_clause = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_default_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_default (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

inst_clause = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_inst_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_instance (. addTerminal(); .) inst_name ) (. d_stack.pop(); .) 
    .

inst_name = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_inst_name, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( topmodule_identifier { T_Dot (. addTerminal(); .) instance_identifier } ) (. d_stack.pop(); .) 
    .

cell_clause = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_cell_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_cell (. addTerminal(); .) [ IF( peek(1) == _T_Ident && peek(2) == _T_Dot ) library_identifier T_Dot (. addTerminal(); .) ] cell_identifier ) (. d_stack.pop(); .) 
    .

liblist_clause = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_liblist_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_liblist (. addTerminal(); .) { library_identifier } ) (. d_stack.pop(); .) 
    .

use_clause = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_use_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_use (. addTerminal(); .) [ IF( peek(1) == _T_Ident && peek(2) == _T_Dot ) library_identifier T_Dot (. addTerminal(); .) ] cell_identifier [ T_Colon (. addTerminal(); .) T_config (. addTerminal(); .) ] ) (. d_stack.pop(); .) 
    .

local_parameter_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_local_parameter_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_localparam (. addTerminal(); .) ( ( [ T_signed (. addTerminal(); .) ] [ range ] ) | parameter_type ) list_of_param_assignments ) (. d_stack.pop(); .) 
    .

parameter_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_parameter_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_parameter (. addTerminal(); .) ( ( [ T_signed (. addTerminal(); .) ] [ range ] ) | parameter_type ) list_of_param_assignments ) (. d_stack.pop(); .) 
    .

specparam_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specparam_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_specparam (. addTerminal(); .) [ range ] list_of_specparam_assignments T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

parameter_type = 
    T_integer (. addTerminal(); .) 
    | T_real (. addTerminal(); .) 
    | T_realtime (. addTerminal(); .) 
    | T_time (. addTerminal(); .) 
    .

inout_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_inout_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_inout (. addTerminal(); .) [ net_type ] [ T_signed (. addTerminal(); .) ] [ range ] list_of_port_identifiers ) (. d_stack.pop(); .) 
    .

input_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_input_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_input (. addTerminal(); .) ( ( [ net_type ] [ T_signed (. addTerminal(); .) ] [ range ] list_of_port_identifiers ) | ( reg_or_logic [ T_signed (. addTerminal(); .) ] [ range ] list_of_variable_port_identifiers ) ) ) (. d_stack.pop(); .) 
    .

output_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_output_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_output (. addTerminal(); .) ( ( [ net_type ] [ T_signed (. addTerminal(); .) ] [ range ] list_of_port_identifiers ) | ( reg_or_logic [ T_signed (. addTerminal(); .) ] [ range ] list_of_variable_port_identifiers ) | ( output_variable_type list_of_variable_port_identifiers ) ) ) (. d_stack.pop(); .) 
    .

event_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_event_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_event (. addTerminal(); .) list_of_event_identifiers T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

integer_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_integer_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_integer (. addTerminal(); .) list_of_variable_identifiers T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

list_of_net_decl_assignments_or_identifiers = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_net_decl_assignments_or_identifiers, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( net_identifier [ ( dimension { dimension } ) | ( T_Eq (. addTerminal(); .) expression ) ] { T_Comma (. addTerminal(); .) net_identifier [ ( dimension { dimension } ) | ( T_Eq (. addTerminal(); .) expression ) ] } ) (. d_stack.pop(); .) 
    .

net_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_net_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( net_type | T_trireg (. addTerminal(); .) ) [ IF( peek(1) == _T_Lpar && ( peek(2) == _T_pull0 || peek(2) == _T_weak0 || peek(2) == _T_pull1 || peek(2) == _T_supply1 || peek(2) == _T_weak1 || peek(2) == _T_highz0 || peek(2) == _T_highz1 || peek(2) == _T_strong0 || peek(2) == _T_strong1 || peek(2) == _T_supply0 ) ) drive_strength ] [ charge_strength ] [ T_vectored (. addTerminal(); .) | T_scalared (. addTerminal(); .) ] [ T_signed (. addTerminal(); .) ] [ range ] [ delay3 ] list_of_net_decl_assignments_or_identifiers T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

real_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_real_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_real (. addTerminal(); .) list_of_real_identifiers T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

realtime_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_realtime_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_realtime (. addTerminal(); .) list_of_real_identifiers T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

reg_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_reg_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( reg_or_logic [ T_signed (. addTerminal(); .) ] [ range ] list_of_variable_identifiers T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

time_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_time_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_time (. addTerminal(); .) list_of_variable_identifiers T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

net_type = 
    T_supply0 (. addTerminal(); .) 
    | T_supply1 (. addTerminal(); .) 
    | T_tri (. addTerminal(); .) 
    | T_triand (. addTerminal(); .) 
    | T_trior (. addTerminal(); .) 
    | T_tri0 (. addTerminal(); .) 
    | T_tri1 (. addTerminal(); .) 
    | T_uwire (. addTerminal(); .) 
    | T_wire (. addTerminal(); .) 
    | T_wand (. addTerminal(); .) 
    | T_wor (. addTerminal(); .) 
    .

output_variable_type = 
    T_integer (. addTerminal(); .) 
    | T_time (. addTerminal(); .) 
    .

real_type = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_real_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( real_identifier ( { dimension } | ( T_Eq (. addTerminal(); .) constant_expression ) ) ) (. d_stack.pop(); .) 
    .

variable_type = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_variable_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( variable_identifier ( { dimension } | ( T_Eq (. addTerminal(); .) constant_expression ) ) ) (. d_stack.pop(); .) 
    .

drive_strength = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_drive_strength, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_Lpar (. addTerminal(); .) ( strength0 | strength1 | T_highz0 (. addTerminal(); .) | T_highz1 (. addTerminal(); .) ) T_Comma (. addTerminal(); .) ( strength1 | strength0 | T_highz1 (. addTerminal(); .) | T_highz0 (. addTerminal(); .) ) T_Rpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

strength0 = 
    T_supply0 (. addTerminal(); .) 
    | T_strong0 (. addTerminal(); .) 
    | T_pull0 (. addTerminal(); .) 
    | T_weak0 (. addTerminal(); .) 
    .

strength1 = 
    T_supply1 (. addTerminal(); .) 
    | T_strong1 (. addTerminal(); .) 
    | T_pull1 (. addTerminal(); .) 
    | T_weak1 (. addTerminal(); .) 
    .

charge_strength = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_charge_strength, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_Lpar (. addTerminal(); .) ( T_small (. addTerminal(); .) | T_medium (. addTerminal(); .) | T_large (. addTerminal(); .) ) T_Rpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

delay = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_delay, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_Hash (. addTerminal(); .) [ delay_value ] [ T_Lpar (. addTerminal(); .) mintypmax_expression { T_Comma (. addTerminal(); .) mintypmax_expression } T_Rpar (. addTerminal(); .) { expression_nlr } ] ) (. d_stack.pop(); .) 
    .

delay3 = 
    delay 
    .

delay2 = 
    delay 
    .

delay_value = 
    unsigned_or_real_number 
    | identifier 
    .

list_of_defparam_assignments = 
    defparam_assignment { T_Comma (. addTerminal(); .) defparam_assignment } 
    .

list_of_event_identifiers = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_event_identifiers, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( event_identifier { dimension } { T_Comma (. addTerminal(); .) event_identifier { dimension } } ) (. d_stack.pop(); .) 
    .

list_of_param_assignments = 
    param_assignment { IF( peek(1) == _T_Comma && peek(2) == _T_Ident ) T_Comma (. addTerminal(); .) param_assignment } 
    .

list_of_port_identifiers = 
    port_identifier { IF( peek(1) == _T_Comma && peek(2) == _T_Ident ) T_Comma (. addTerminal(); .) port_identifier } 
    .

list_of_real_identifiers = 
    real_type { T_Comma (. addTerminal(); .) real_type } 
    .

list_of_specparam_assignments = 
    specparam_assignment { T_Comma (. addTerminal(); .) specparam_assignment } 
    .

list_of_variable_identifiers = 
    variable_type { T_Comma (. addTerminal(); .) variable_type } 
    .

list_of_variable_port_identifiers = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_variable_port_identifiers, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( port_identifier [ T_Eq (. addTerminal(); .) constant_expression ] { IF( peek(1) == _T_Comma && peek(2) == _T_Ident ) T_Comma (. addTerminal(); .) port_identifier [ T_Eq (. addTerminal(); .) constant_expression ] } ) (. d_stack.pop(); .) 
    .

defparam_assignment = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_defparam_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( hierarchical_parameter_identifier T_Eq (. addTerminal(); .) constant_mintypmax_expression ) (. d_stack.pop(); .) 
    .

param_assignment = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_param_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( parameter_identifier T_Eq (. addTerminal(); .) constant_mintypmax_expression ) (. d_stack.pop(); .) 
    .

specparam_assignment = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specparam_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( specparam_identifier T_Eq (. addTerminal(); .) constant_mintypmax_expression ) 
    | pulse_control_specparam ) (. d_stack.pop(); .) 
    .

pulse_control_specparam = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pulse_control_specparam, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_PATHPULSE_dlr (. addTerminal(); .) T_Eq (. addTerminal(); .) T_Lpar (. addTerminal(); .) reject_limit_value [ T_Comma (. addTerminal(); .) error_limit_value ] T_Rpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

error_limit_value = 
    limit_value 
    .

reject_limit_value = 
    limit_value 
    .

limit_value = 
    constant_mintypmax_expression 
    .

dimension = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dimension, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_Lbrack (. addTerminal(); .) dimension_constant_expression T_Colon (. addTerminal(); .) dimension_constant_expression T_Rbrack (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

range = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_range, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_Lbrack (. addTerminal(); .) msb_constant_expression T_Colon (. addTerminal(); .) lsb_constant_expression T_Rbrack (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

function_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_function_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_function (. addTerminal(); .) [ T_automatic (. addTerminal(); .) ] [ function_range_or_type ] function_identifier [ T_Lpar (. addTerminal(); .) function_port_list T_Rpar (. addTerminal(); .) ] T_Semi (. addTerminal(); .) { function_item_declaration } function_statement T_endfunction (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

function_item_declaration = 
    block_item_declaration 
    | ( tf_input_declaration T_Semi (. addTerminal(); .) ) 
    .

function_port_list = 
    tf_input_declaration { T_Comma (. addTerminal(); .) tf_input_declaration } 
    .

function_range_or_type = 
    ( [ T_signed (. addTerminal(); .) ] [ range ] ) 
    | T_integer (. addTerminal(); .) 
    | T_real (. addTerminal(); .) 
    | T_realtime (. addTerminal(); .) 
    | T_time (. addTerminal(); .) 
    .

task_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_task_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_task (. addTerminal(); .) [ T_automatic (. addTerminal(); .) ] task_identifier [ T_Lpar (. addTerminal(); .) [ task_port_list ] T_Rpar (. addTerminal(); .) ] T_Semi (. addTerminal(); .) { task_item_declaration } statement_or_null T_endtask (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

task_item_declaration = 
    block_item_declaration 
    | ( tf_input_declaration T_Semi (. addTerminal(); .) ) 
    | ( tf_output_declaration T_Semi (. addTerminal(); .) ) 
    | ( tf_inout_declaration T_Semi (. addTerminal(); .) ) 
    .

task_port_list = 
    task_port_item { T_Comma (. addTerminal(); .) task_port_item } 
    .

task_port_item = 
    ( tf_input_declaration ) 
    | ( tf_output_declaration ) 
    | ( tf_inout_declaration ) 
    .

tf_input_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_tf_input_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_input (. addTerminal(); .) ( ( [ reg_or_logic ] [ T_signed (. addTerminal(); .) ] [ range ] ) | task_port_type ) list_of_port_identifiers ) (. d_stack.pop(); .) 
    .

tf_output_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_tf_output_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_output (. addTerminal(); .) ( ( [ reg_or_logic ] [ T_signed (. addTerminal(); .) ] [ range ] ) | task_port_type ) list_of_port_identifiers ) (. d_stack.pop(); .) 
    .

tf_inout_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_tf_inout_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_inout (. addTerminal(); .) ( ( [ reg_or_logic ] [ T_signed (. addTerminal(); .) ] [ range ] ) | task_port_type ) list_of_port_identifiers ) (. d_stack.pop(); .) 
    .

task_port_type = 
    T_integer (. addTerminal(); .) 
    | T_real (. addTerminal(); .) 
    | T_realtime (. addTerminal(); .) 
    | T_time (. addTerminal(); .) 
    .

block_item_declaration = 
    ( block_reg_declaration | block_integer_declaration | block_time_declaration | block_real_declaration | block_realtime_declaration | event_declaration | ( local_parameter_declaration T_Semi (. addTerminal(); .) ) | ( parameter_declaration T_Semi (. addTerminal(); .) ) ) 
    .

block_reg_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_reg_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( reg_or_logic [ T_signed (. addTerminal(); .) ] [ range ] list_of_block_variable_identifiers T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

block_integer_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_integer_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_integer (. addTerminal(); .) list_of_block_variable_identifiers T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

block_time_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_time_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_time (. addTerminal(); .) list_of_block_variable_identifiers T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

block_real_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_real_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_real (. addTerminal(); .) list_of_block_real_identifiers T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

block_realtime_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_realtime_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_realtime (. addTerminal(); .) list_of_block_real_identifiers T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

list_of_block_variable_identifiers = 
    block_variable_type { T_Comma (. addTerminal(); .) block_variable_type } 
    .

list_of_block_real_identifiers = 
    block_real_type { T_Comma (. addTerminal(); .) block_real_type } 
    .

block_variable_type = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_variable_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( variable_identifier { dimension } ) (. d_stack.pop(); .) 
    .

block_real_type = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_real_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( real_identifier { dimension } ) (. d_stack.pop(); .) 
    .

gate_instantiation = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_gate_instantiation, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( cmos_switchtype [ delay3 ] cmos_switch_instance { T_Comma (. addTerminal(); .) cmos_switch_instance } T_Semi (. addTerminal(); .) ) 
    | ( enable_gatetype [ IF( peek(1) == _T_Lpar && ( peek(2) == _T_pull0 || peek(2) == _T_weak0 || peek(2) == _T_pull1 || peek(2) == _T_supply1 || peek(2) == _T_weak1 || peek(2) == _T_highz0 || peek(2) == _T_highz1 || peek(2) == _T_strong0 || peek(2) == _T_strong1 || peek(2) == _T_supply0 ) ) drive_strength ] [ delay3 ] enable_gate_instance { T_Comma (. addTerminal(); .) enable_gate_instance } T_Semi (. addTerminal(); .) ) 
    | ( mos_switchtype [ delay3 ] mos_switch_instance { T_Comma (. addTerminal(); .) mos_switch_instance } T_Semi (. addTerminal(); .) ) 
    | ( n_input_gatetype [ IF( peek(1) == _T_Lpar && ( peek(2) == _T_pull0 || peek(2) == _T_weak0 || peek(2) == _T_pull1 || peek(2) == _T_supply1 || peek(2) == _T_weak1 || peek(2) == _T_highz0 || peek(2) == _T_highz1 || peek(2) == _T_strong0 || peek(2) == _T_strong1 || peek(2) == _T_supply0 ) ) drive_strength ] [ delay2 ] n_input_gate_instance { T_Comma (. addTerminal(); .) n_input_gate_instance } T_Semi (. addTerminal(); .) ) 
    | ( n_output_gatetype [ IF( peek(1) == _T_Lpar && ( peek(2) == _T_pull0 || peek(2) == _T_weak0 || peek(2) == _T_pull1 || peek(2) == _T_supply1 || peek(2) == _T_weak1 || peek(2) == _T_highz0 || peek(2) == _T_highz1 || peek(2) == _T_strong0 || peek(2) == _T_strong1 || peek(2) == _T_supply0 ) ) drive_strength ] [ delay2 ] n_output_gate_instance { T_Comma (. addTerminal(); .) n_output_gate_instance } T_Semi (. addTerminal(); .) ) 
    | ( pass_en_switchtype [ delay2 ] pass_enable_switch_instance { T_Comma (. addTerminal(); .) pass_enable_switch_instance } T_Semi (. addTerminal(); .) ) 
    | ( pass_switchtype pass_switch_instance { T_Comma (. addTerminal(); .) pass_switch_instance } T_Semi (. addTerminal(); .) ) 
    | ( T_pulldown (. addTerminal(); .) [ IF( peek(1) == _T_Lpar && ( peek(2) == _T_pull0 || peek(2) == _T_weak0 || peek(2) == _T_pull1 || peek(2) == _T_supply1 || peek(2) == _T_weak1 || peek(2) == _T_strong0 || peek(2) == _T_strong1 || peek(2) == _T_supply0 ) ) pulldown_strength ] pull_gate_instance { T_Comma (. addTerminal(); .) pull_gate_instance } T_Semi (. addTerminal(); .) ) 
    | ( T_pullup (. addTerminal(); .) [ IF( peek(1) == _T_Lpar && ( peek(2) == _T_pull0 || peek(2) == _T_weak0 || peek(2) == _T_pull1 || peek(2) == _T_supply1 || peek(2) == _T_weak1 || peek(2) == _T_strong0 || peek(2) == _T_strong1 || peek(2) == _T_supply0 ) ) pullup_strength ] pull_gate_instance { T_Comma (. addTerminal(); .) pull_gate_instance } T_Semi (. addTerminal(); .) ) ) (. d_stack.pop(); .) 
    .

cmos_switch_instance = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_cmos_switch_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ name_of_gate_instance ] T_Lpar (. addTerminal(); .) output_terminal T_Comma (. addTerminal(); .) input_terminal T_Comma (. addTerminal(); .) ncontrol_terminal T_Comma (. addTerminal(); .) pcontrol_terminal T_Rpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

enable_gate_instance = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_enable_gate_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ name_of_gate_instance ] T_Lpar (. addTerminal(); .) output_terminal T_Comma (. addTerminal(); .) input_terminal T_Comma (. addTerminal(); .) enable_terminal T_Rpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

mos_switch_instance = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_mos_switch_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ name_of_gate_instance ] T_Lpar (. addTerminal(); .) output_terminal T_Comma (. addTerminal(); .) input_terminal T_Comma (. addTerminal(); .) enable_terminal T_Rpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

n_input_gate_instance = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_n_input_gate_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ name_of_gate_instance ] T_Lpar (. addTerminal(); .) output_terminal T_Comma (. addTerminal(); .) input_terminal { T_Comma (. addTerminal(); .) input_terminal } T_Rpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

input_or_output_terminal = 
    expression_2 
    .

n_output_gate_instance = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_n_output_gate_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ name_of_gate_instance ] T_Lpar (. addTerminal(); .) input_or_output_terminal { T_Comma (. addTerminal(); .) input_or_output_terminal } T_Rpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

pass_switch_instance = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pass_switch_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ name_of_gate_instance ] T_Lpar (. addTerminal(); .) inout_terminal T_Comma (. addTerminal(); .) inout_terminal T_Rpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

pass_enable_switch_instance = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pass_enable_switch_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ name_of_gate_instance ] T_Lpar (. addTerminal(); .) inout_terminal T_Comma (. addTerminal(); .) inout_terminal T_Comma (. addTerminal(); .) enable_terminal T_Rpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

pull_gate_instance = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pull_gate_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ name_of_gate_instance ] T_Lpar (. addTerminal(); .) output_terminal T_Rpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

name_of_gate_instance = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_name_of_gate_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( gate_instance_identifier [ range ] ) (. d_stack.pop(); .) 
    .

pulldown_strength = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pulldown_strength, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_Lpar (. addTerminal(); .) ( strength0 | strength1 ) [ T_Comma (. addTerminal(); .) ( strength1 | strength0 ) ] T_Rpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

pullup_strength = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pullup_strength, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_Lpar (. addTerminal(); .) ( strength0 | strength1 ) [ T_Comma (. addTerminal(); .) ( strength1 | strength0 ) ] T_Rpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

enable_terminal = 
    expression 
    .

inout_terminal = 
    net_lvalue 
    .

input_terminal = 
    expression 
    .

ncontrol_terminal = 
    expression 
    .

output_terminal = 
    net_lvalue 
    .

pcontrol_terminal = 
    expression 
    .

cmos_switchtype = 
    T_cmos (. addTerminal(); .) 
    | T_rcmos (. addTerminal(); .) 
    .

enable_gatetype = 
    T_bufif0 (. addTerminal(); .) 
    | T_bufif1 (. addTerminal(); .) 
    | T_notif0 (. addTerminal(); .) 
    | T_notif1 (. addTerminal(); .) 
    .

mos_switchtype = 
    T_nmos (. addTerminal(); .) 
    | T_pmos (. addTerminal(); .) 
    | T_rnmos (. addTerminal(); .) 
    | T_rpmos (. addTerminal(); .) 
    .

n_input_gatetype = 
    T_and (. addTerminal(); .) 
    | T_nand (. addTerminal(); .) 
    | T_or (. addTerminal(); .) 
    | T_nor (. addTerminal(); .) 
    | T_xor (. addTerminal(); .) 
    | T_xnor (. addTerminal(); .) 
    .

n_output_gatetype = 
    T_buf (. addTerminal(); .) 
    | T_not (. addTerminal(); .) 
    .

pass_en_switchtype = 
    T_tranif0 (. addTerminal(); .) 
    | T_tranif1 (. addTerminal(); .) 
    | T_rtranif1 (. addTerminal(); .) 
    | T_rtranif0 (. addTerminal(); .) 
    .

pass_switchtype = 
    T_tran (. addTerminal(); .) 
    | T_rtran (. addTerminal(); .) 
    .

named_parameter_assignment = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_named_parameter_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_Dot (. addTerminal(); .) parameter_identifier T_Lpar (. addTerminal(); .) [ mintypmax_expression ] T_Rpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

generate_region = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_generate_region, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_generate (. addTerminal(); .) { module_or_generate_item } T_endgenerate (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

genvar_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_genvar_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_genvar (. addTerminal(); .) list_of_genvar_identifiers T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

list_of_genvar_identifiers = 
    genvar_identifier { T_Comma (. addTerminal(); .) genvar_identifier } 
    .

loop_generate_construct = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_loop_generate_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_for (. addTerminal(); .) T_Lpar (. addTerminal(); .) genvar_initialization T_Semi (. addTerminal(); .) genvar_expression T_Semi (. addTerminal(); .) genvar_iteration T_Rpar (. addTerminal(); .) ( generate_block | module_or_generate_item ) ) (. d_stack.pop(); .) 
    .

genvar_initialization = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_genvar_initialization, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( genvar_identifier T_Eq (. addTerminal(); .) constant_expression ) (. d_stack.pop(); .) 
    .

genvar_expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_genvar_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ unary_operator ] genvar_primary genvar_expression_nlr ) (. d_stack.pop(); .) 
    .

genvar_expression_nlr = 
    [ ( binary_operator genvar_expression genvar_expression_nlr ) 
    | ( T_Qmark (. addTerminal(); .) genvar_expression T_Colon (. addTerminal(); .) genvar_expression genvar_expression_nlr ) ] 
    .

genvar_iteration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_genvar_iteration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( genvar_identifier T_Eq (. addTerminal(); .) genvar_expression ) (. d_stack.pop(); .) 
    .

genvar_primary = 
    constant_primary 
    .

conditional_generate_construct = 
    if_generate_construct 
    | case_generate_construct 
    .

if_generate_construct = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_if_generate_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_if (. addTerminal(); .) T_Lpar (. addTerminal(); .) constant_expression T_Rpar (. addTerminal(); .) generate_block_or_null [ T_else (. addTerminal(); .) generate_block_or_null ] ) (. d_stack.pop(); .) 
    .

case_generate_construct = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_case_generate_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_case (. addTerminal(); .) T_Lpar (. addTerminal(); .) constant_expression T_Rpar (. addTerminal(); .) case_generate_item { case_generate_item } T_endcase (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

case_generate_item = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_case_generate_item, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( constant_expression { T_Comma (. addTerminal(); .) constant_expression } T_Colon (. addTerminal(); .) generate_block_or_null ) 
    | ( T_default (. addTerminal(); .) [ T_Colon (. addTerminal(); .) ] generate_block_or_null ) ) (. d_stack.pop(); .) 
    .

generate_block = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_generate_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_begin (. addTerminal(); .) [ T_Colon (. addTerminal(); .) generate_block_identifier ] { module_or_generate_item } T_end (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

generate_block_or_null = 
    generate_block 
    | module_or_generate_item 
    | T_Semi (. addTerminal(); .) 
    .

udp_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_primitive (. addTerminal(); .) udp_identifier T_Lpar (. addTerminal(); .) ( udp_port_list | udp_declaration_port_list ) T_Rpar (. addTerminal(); .) T_Semi (. addTerminal(); .) { udp_port_declaration } udp_body T_endprimitive (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

udp_port_list = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_port_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( output_port_identifier T_Comma (. addTerminal(); .) input_port_identifier { T_Comma (. addTerminal(); .) input_port_identifier } ) (. d_stack.pop(); .) 
    .

udp_declaration_port_list = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_declaration_port_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( udp_output_declaration T_Comma (. addTerminal(); .) udp_input_declaration { T_Comma (. addTerminal(); .) udp_input_declaration } ) (. d_stack.pop(); .) 
    .

udp_port_declaration = 
    ( udp_output_declaration T_Semi (. addTerminal(); .) ) 
    | ( udp_input_declaration T_Semi (. addTerminal(); .) ) 
    | ( udp_reg_declaration T_Semi (. addTerminal(); .) ) 
    .

udp_output_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_output_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_output (. addTerminal(); .) [ reg_or_logic ] port_identifier [ T_Eq (. addTerminal(); .) constant_expression ] ) (. d_stack.pop(); .) 
    .

udp_input_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_input_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_input (. addTerminal(); .) list_of_port_identifiers ) (. d_stack.pop(); .) 
    .

udp_reg_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_reg_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( reg_or_logic variable_identifier ) (. d_stack.pop(); .) 
    .

udp_body = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_body, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ udp_initial_statement ] T_table (. addTerminal(); .) sequential_or_combinatorial_entry { sequential_or_combinatorial_entry } T_endtable (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

udp_initial_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_initial_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_initial (. addTerminal(); .) output_port_identifier T_Eq (. addTerminal(); .) init_val T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

sequential_or_combinatorial_entry = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_sequential_or_combinatorial_entry, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( { level_or_edge_symbol | ( T_Lpar (. addTerminal(); .) level_symbol [ level_symbol ] T_Rpar (. addTerminal(); .) ) } T_Colon (. addTerminal(); .) ( level_symbol | T_Minus (. addTerminal(); .) ) [ T_Colon (. addTerminal(); .) ( level_symbol | T_Minus (. addTerminal(); .) ) ] T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

level_symbol = 
    number 
    | identifier 
    | T_Qmark (. addTerminal(); .) 
    .

level_or_edge_symbol = 
    number 
    | identifier 
    | T_Qmark (. addTerminal(); .) 
    | T_Star (. addTerminal(); .) 
    .

edge_descriptor = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_edge_descriptor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( identifier | number ) [ identifier | number ] ) (. d_stack.pop(); .) 
    .

init_val = 
    number 
    .

scalar_constant = 
    number 
    .

continuous_assign = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_continuous_assign, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_assign (. addTerminal(); .) [ drive_strength ] [ delay3 ] list_of_net_assignments T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

list_of_net_assignments = 
    net_assignment { T_Comma (. addTerminal(); .) net_assignment } 
    .

net_assignment = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_net_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( net_lvalue T_Eq (. addTerminal(); .) expression ) (. d_stack.pop(); .) 
    .

initial_construct = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_initial_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_initial (. addTerminal(); .) statement ) (. d_stack.pop(); .) 
    .

always_construct = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_always_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_always (. addTerminal(); .) statement ) (. d_stack.pop(); .) 
    .

procedural_continuous_assignments = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_procedural_continuous_assignments, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( T_assign (. addTerminal(); .) variable_assignment ) 
    | ( T_deassign (. addTerminal(); .) variable_lvalue ) 
    | ( T_force (. addTerminal(); .) variable_or_net_lvalue T_Eq (. addTerminal(); .) expression ) 
    | ( T_release (. addTerminal(); .) variable_or_net_lvalue ) ) (. d_stack.pop(); .) 
    .

variable_assignment = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_variable_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( variable_lvalue T_Eq (. addTerminal(); .) expression ) (. d_stack.pop(); .) 
    .

par_block = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_par_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_fork (. addTerminal(); .) [ T_Colon (. addTerminal(); .) block_identifier { block_item_declaration } ] { statement_or_null } T_join (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

seq_block = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_seq_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_begin (. addTerminal(); .) [ T_Colon (. addTerminal(); .) block_identifier { block_item_declaration } ] { statement_or_null } T_end (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

blocking_or_nonblocking_assignment_or_task_enable = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_blocking_or_nonblocking_assignment_or_task_enable, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( variable_lvalue [ T_Lpar (. addTerminal(); .) expression { T_Comma (. addTerminal(); .) expression } T_Rpar (. addTerminal(); .) ] [ ( T_Leq (. addTerminal(); .) | T_Eq (. addTerminal(); .) ) [ delay_or_event_control ] [ expression ] ] T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

statement = 
    ( blocking_or_nonblocking_assignment_or_task_enable | case_statement | conditional_statement | disable_statement | event_trigger | loop_statement | par_block | ( procedural_continuous_assignments T_Semi (. addTerminal(); .) ) | procedural_timing_control_statement | seq_block | system_task_enable | wait_statement | procedural_assertion_statement ) 
    .

statement_or_null = 
    statement 
    | ( T_Semi (. addTerminal(); .) ) 
    .

function_statement = 
    statement 
    .

delay_control = 
    delay 
    .

delay_or_event_control = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_delay_or_event_control, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( delay_control 
    | event_control 
    | ( T_repeat (. addTerminal(); .) T_Lpar (. addTerminal(); .) expression T_Rpar (. addTerminal(); .) event_control ) ) (. d_stack.pop(); .) 
    .

hierarchical_task_or_block_identifier = 
    hierarchical_identifier 
    .

disable_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_disable_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_disable (. addTerminal(); .) hierarchical_task_or_block_identifier T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

event_control = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_event_control, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_At (. addTerminal(); .) ( ( T_Lpar (. addTerminal(); .) ( event_expression | T_Star (. addTerminal(); .) ) T_Rpar (. addTerminal(); .) ) | T_Star (. addTerminal(); .) | hierarchical_event_identifier ) ) (. d_stack.pop(); .) 
    .

event_trigger = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_event_trigger, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_MinusGt (. addTerminal(); .) hierarchical_identifier_range T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

event_expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_event_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( expression event_expression_nlr ) 
    | ( T_posedge (. addTerminal(); .) expression event_expression_nlr ) 
    | ( T_negedge (. addTerminal(); .) expression event_expression_nlr ) ) (. d_stack.pop(); .) 
    .

event_expression_nlr = 
    [ ( T_or (. addTerminal(); .) event_expression event_expression_nlr ) 
    | ( T_Comma (. addTerminal(); .) event_expression event_expression_nlr ) ] 
    .

procedural_timing_control = 
    delay_control 
    | event_control 
    .

procedural_timing_control_statement = 
    procedural_timing_control statement_or_null 
    .

wait_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_wait_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_wait (. addTerminal(); .) T_Lpar (. addTerminal(); .) expression T_Rpar (. addTerminal(); .) statement_or_null ) (. d_stack.pop(); .) 
    .

conditional_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_conditional_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_if (. addTerminal(); .) T_Lpar (. addTerminal(); .) expression T_Rpar (. addTerminal(); .) statement_or_null [ T_else (. addTerminal(); .) statement_or_null ] ) (. d_stack.pop(); .) 
    .

case_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_case_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( T_case (. addTerminal(); .) | T_casez (. addTerminal(); .) | T_casex (. addTerminal(); .) ) T_Lpar (. addTerminal(); .) expression T_Rpar (. addTerminal(); .) case_item { case_item } T_endcase (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

case_item = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_case_item, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( expression { T_Comma (. addTerminal(); .) expression } T_Colon (. addTerminal(); .) statement_or_null ) 
    | ( T_default (. addTerminal(); .) [ T_Colon (. addTerminal(); .) ] statement_or_null ) ) (. d_stack.pop(); .) 
    .

loop_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_loop_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( T_forever (. addTerminal(); .) statement ) 
    | ( T_repeat (. addTerminal(); .) T_Lpar (. addTerminal(); .) expression T_Rpar (. addTerminal(); .) statement ) 
    | ( T_while (. addTerminal(); .) T_Lpar (. addTerminal(); .) expression T_Rpar (. addTerminal(); .) statement ) 
    | ( T_for (. addTerminal(); .) T_Lpar (. addTerminal(); .) variable_assignment T_Semi (. addTerminal(); .) expression T_Semi (. addTerminal(); .) variable_assignment T_Rpar (. addTerminal(); .) statement ) ) (. d_stack.pop(); .) 
    .

system_task_enable = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_system_task_enable, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( system_task_identifier [ T_Lpar (. addTerminal(); .) [ expression ] { T_Comma (. addTerminal(); .) [ expression ] } T_Rpar (. addTerminal(); .) ] T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

specify_block = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specify_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_specify (. addTerminal(); .) { specify_item } T_endspecify (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

specify_item = 
    specparam_declaration 
    | pulsestyle_declaration 
    | showcancelled_declaration 
    | path_declaration 
    | system_timing_check 
    .

pulsestyle_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pulsestyle_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( T_pulsestyle_onevent (. addTerminal(); .) | T_pulsestyle_ondetect (. addTerminal(); .) ) list_of_path_outputs T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

showcancelled_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_showcancelled_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( T_showcancelled (. addTerminal(); .) | T_noshowcancelled (. addTerminal(); .) ) list_of_path_outputs T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

path_declaration = 
    ( simple_or_edge_sensitive_path_declaration T_Semi (. addTerminal(); .) ) 
    | ( state_dependent_path_declaration T_Semi (. addTerminal(); .) ) 
    .

parallel_or_full_path_description = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_parallel_or_full_path_description, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_Lpar (. addTerminal(); .) list_of_path_inputs [ polarity_operator ] ( ( T_EqGt (. addTerminal(); .) specify_output_terminal_descriptor ) | ( T_StarGt (. addTerminal(); .) list_of_path_outputs ) ) T_Rpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

simple_path_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_simple_path_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( parallel_or_full_path_description T_Eq (. addTerminal(); .) path_delay_value ) (. d_stack.pop(); .) 
    .

list_of_path_inputs = 
    specify_input_terminal_descriptor { T_Comma (. addTerminal(); .) specify_input_terminal_descriptor } 
    .

list_of_path_outputs = 
    specify_output_terminal_descriptor { T_Comma (. addTerminal(); .) specify_output_terminal_descriptor } 
    .

specify_input_terminal_descriptor = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specify_input_terminal_descriptor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( input_identifier [ T_Lbrack (. addTerminal(); .) constant_range_expression T_Rbrack (. addTerminal(); .) ] ) (. d_stack.pop(); .) 
    .

specify_output_terminal_descriptor = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specify_output_terminal_descriptor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( output_identifier [ T_Lbrack (. addTerminal(); .) constant_range_expression T_Rbrack (. addTerminal(); .) ] ) (. d_stack.pop(); .) 
    .

input_or_inout_port_identifier = 
    identifier 
    .

input_identifier = 
    input_or_inout_port_identifier 
    .

output_or_inout_port_identifier = 
    identifier 
    .

output_identifier = 
    output_or_inout_port_identifier 
    .

path_delay_value = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_path_delay_value, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( list_of_path_delay_expressions ) (. d_stack.pop(); .) 
    .

list_of_path_delay_expressions = 
    path_delay_expression { T_Comma (. addTerminal(); .) path_delay_expression } 
    .

path_delay_expression = 
    constant_mintypmax_expression 
    .

simple_or_edge_sensitive_path_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_simple_or_edge_sensitive_path_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_Lpar (. addTerminal(); .) [ edge_identifier ] list_of_path_inputs [ polarity_operator ] ( ( T_EqGt (. addTerminal(); .) [ specify_output_terminal_descriptor ] ) | ( T_StarGt (. addTerminal(); .) [ list_of_path_outputs ] ) ) [ T_Lpar (. addTerminal(); .) list_of_path_outputs ( T_Colon (. addTerminal(); .) | T_PlusColon (. addTerminal(); .) | T_MinusColon (. addTerminal(); .) ) data_source_expression T_Rpar (. addTerminal(); .) ] T_Rpar (. addTerminal(); .) T_Eq (. addTerminal(); .) path_delay_value ) (. d_stack.pop(); .) 
    .

simple_or_edge_sensitive_path_description = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_simple_or_edge_sensitive_path_description, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_Lpar (. addTerminal(); .) [ edge_identifier ] list_of_path_inputs [ polarity_operator ] ( ( T_EqGt (. addTerminal(); .) [ specify_output_terminal_descriptor ] ) | ( T_StarGt (. addTerminal(); .) [ list_of_path_outputs ] ) ) [ T_Lpar (. addTerminal(); .) list_of_path_outputs ( T_Colon (. addTerminal(); .) | T_PlusColon (. addTerminal(); .) | T_MinusColon (. addTerminal(); .) ) data_source_expression T_Rpar (. addTerminal(); .) ] T_Rpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

data_source_expression = 
    expression 
    .

edge_identifier = 
    T_posedge (. addTerminal(); .) 
    | T_negedge (. addTerminal(); .) 
    .

state_dependent_path_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_state_dependent_path_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( T_if (. addTerminal(); .) T_Lpar (. addTerminal(); .) module_path_expression T_Rpar (. addTerminal(); .) simple_or_edge_sensitive_path_description T_Eq (. addTerminal(); .) path_delay_value ) 
    | ( T_ifnone (. addTerminal(); .) simple_path_declaration ) ) (. d_stack.pop(); .) 
    .

polarity_operator = 
    T_Plus (. addTerminal(); .) 
    | T_Minus (. addTerminal(); .) 
    .

system_timing_check = 
    dlr_setup_timing_check 
    | dlr_hold_timing_check 
    | dlr_setuphold_timing_check 
    | dlr_recovery_timing_check 
    | dlr_removal_timing_check 
    | dlr_recrem_timing_check 
    | dlr_skew_timing_check 
    | dlr_timeskew_timing_check 
    | dlr_fullskew_timing_check 
    | dlr_period_timing_check 
    | dlr_width_timing_check 
    | dlr_nochange_timing_check 
    .

dlr_setup_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_setup_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_dlr_setup (. addTerminal(); .) T_Lpar (. addTerminal(); .) data_event T_Comma (. addTerminal(); .) reference_event T_Comma (. addTerminal(); .) timing_check_limit [ T_Comma (. addTerminal(); .) [ notifier ] ] T_Rpar (. addTerminal(); .) T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_hold_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_hold_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_dlr_hold (. addTerminal(); .) T_Lpar (. addTerminal(); .) reference_event T_Comma (. addTerminal(); .) data_event T_Comma (. addTerminal(); .) timing_check_limit [ T_Comma (. addTerminal(); .) [ notifier ] ] T_Rpar (. addTerminal(); .) T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_setuphold_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_setuphold_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_dlr_setuphold (. addTerminal(); .) T_Lpar (. addTerminal(); .) reference_event T_Comma (. addTerminal(); .) data_event T_Comma (. addTerminal(); .) timing_check_limit T_Comma (. addTerminal(); .) timing_check_limit [ T_Comma (. addTerminal(); .) [ notifier ] [ T_Comma (. addTerminal(); .) [ stamptime_condition ] [ T_Comma (. addTerminal(); .) [ checktime_condition ] [ T_Comma (. addTerminal(); .) [ delayed_reference ] [ T_Comma (. addTerminal(); .) [ delayed_data ] ] ] ] ] ] T_Rpar (. addTerminal(); .) T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_recovery_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_recovery_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_dlr_recovery (. addTerminal(); .) T_Lpar (. addTerminal(); .) reference_event T_Comma (. addTerminal(); .) data_event T_Comma (. addTerminal(); .) timing_check_limit [ T_Comma (. addTerminal(); .) [ notifier ] ] T_Rpar (. addTerminal(); .) T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_removal_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_removal_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_dlr_removal (. addTerminal(); .) T_Lpar (. addTerminal(); .) reference_event T_Comma (. addTerminal(); .) data_event T_Comma (. addTerminal(); .) timing_check_limit [ T_Comma (. addTerminal(); .) [ notifier ] ] T_Rpar (. addTerminal(); .) T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_recrem_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_recrem_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_dlr_recrem (. addTerminal(); .) T_Lpar (. addTerminal(); .) reference_event T_Comma (. addTerminal(); .) data_event T_Comma (. addTerminal(); .) timing_check_limit T_Comma (. addTerminal(); .) timing_check_limit [ T_Comma (. addTerminal(); .) [ notifier ] [ T_Comma (. addTerminal(); .) [ stamptime_condition ] [ T_Comma (. addTerminal(); .) [ checktime_condition ] [ T_Comma (. addTerminal(); .) [ delayed_reference ] [ T_Comma (. addTerminal(); .) [ delayed_data ] ] ] ] ] ] T_Rpar (. addTerminal(); .) T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_skew_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_skew_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_dlr_skew (. addTerminal(); .) T_Lpar (. addTerminal(); .) reference_event T_Comma (. addTerminal(); .) data_event T_Comma (. addTerminal(); .) timing_check_limit [ T_Comma (. addTerminal(); .) [ notifier ] ] T_Rpar (. addTerminal(); .) T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_timeskew_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_timeskew_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_dlr_timeskew (. addTerminal(); .) T_Lpar (. addTerminal(); .) reference_event T_Comma (. addTerminal(); .) data_event T_Comma (. addTerminal(); .) timing_check_limit [ T_Comma (. addTerminal(); .) [ notifier ] [ T_Comma (. addTerminal(); .) [ event_based_flag ] [ T_Comma (. addTerminal(); .) [ remain_active_flag ] ] ] ] T_Rpar (. addTerminal(); .) T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_fullskew_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_fullskew_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_dlr_fullskew (. addTerminal(); .) T_Lpar (. addTerminal(); .) reference_event T_Comma (. addTerminal(); .) data_event T_Comma (. addTerminal(); .) timing_check_limit T_Comma (. addTerminal(); .) timing_check_limit [ T_Comma (. addTerminal(); .) [ notifier ] [ T_Comma (. addTerminal(); .) [ event_based_flag ] [ T_Comma (. addTerminal(); .) [ remain_active_flag ] ] ] ] T_Rpar (. addTerminal(); .) T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_period_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_period_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_dlr_period (. addTerminal(); .) T_Lpar (. addTerminal(); .) controlled_reference_event T_Comma (. addTerminal(); .) timing_check_limit [ T_Comma (. addTerminal(); .) [ notifier ] ] T_Rpar (. addTerminal(); .) T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_width_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_width_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_dlr_width (. addTerminal(); .) T_Lpar (. addTerminal(); .) controlled_reference_event T_Comma (. addTerminal(); .) timing_check_limit [ T_Comma (. addTerminal(); .) threshold [ T_Comma (. addTerminal(); .) notifier ] ] T_Rpar (. addTerminal(); .) T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_nochange_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_nochange_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_dlr_nochange (. addTerminal(); .) T_Lpar (. addTerminal(); .) reference_event T_Comma (. addTerminal(); .) data_event T_Comma (. addTerminal(); .) start_edge_offset T_Comma (. addTerminal(); .) end_edge_offset [ T_Comma (. addTerminal(); .) [ notifier ] ] T_Rpar (. addTerminal(); .) T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

checktime_condition = 
    mintypmax_expression 
    .

controlled_reference_event = 
    controlled_timing_check_event 
    .

data_event = 
    timing_check_event 
    .

delayed_data = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_delayed_data, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( terminal_identifier [ T_Lbrack (. addTerminal(); .) constant_mintypmax_expression T_Rbrack (. addTerminal(); .) ] ) (. d_stack.pop(); .) 
    .

delayed_reference = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_delayed_reference, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( terminal_identifier [ T_Lbrack (. addTerminal(); .) constant_mintypmax_expression T_Rbrack (. addTerminal(); .) ] ) (. d_stack.pop(); .) 
    .

end_edge_offset = 
    mintypmax_expression 
    .

event_based_flag = 
    constant_expression 
    .

notifier = 
    variable_identifier 
    .

reference_event = 
    timing_check_event 
    .

remain_active_flag = 
    constant_expression 
    .

stamptime_condition = 
    mintypmax_expression 
    .

start_edge_offset = 
    mintypmax_expression 
    .

threshold = 
    constant_expression 
    .

timing_check_limit = 
    expression 
    .

timing_check_event = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_timing_check_event, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ timing_check_event_control ] specify_terminal_descriptor [ T_3Amp (. addTerminal(); .) timing_check_condition ] ) (. d_stack.pop(); .) 
    .

controlled_timing_check_event = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_controlled_timing_check_event, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( timing_check_event_control specify_terminal_descriptor [ T_3Amp (. addTerminal(); .) timing_check_condition ] ) (. d_stack.pop(); .) 
    .

timing_check_event_control = 
    T_posedge (. addTerminal(); .) 
    | T_negedge (. addTerminal(); .) 
    | edge_control_specifier 
    .

specify_input_or_output_terminal_descriptor = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specify_input_or_output_terminal_descriptor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( identifier [ T_Lbrack (. addTerminal(); .) constant_range_expression T_Rbrack (. addTerminal(); .) ] ) (. d_stack.pop(); .) 
    .

specify_terminal_descriptor = 
    specify_input_or_output_terminal_descriptor 
    .

edge_control_specifier = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_edge_control_specifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_edge (. addTerminal(); .) T_Lbrack (. addTerminal(); .) edge_descriptor { T_Comma (. addTerminal(); .) edge_descriptor } T_Rbrack (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

timing_check_condition = 
    scalar_timing_check_condition 
    .

scalar_timing_check_condition = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_scalar_timing_check_condition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( expression [ ( T_2Eq (. addTerminal(); .) scalar_constant ) | ( T_3Eq (. addTerminal(); .) scalar_constant ) | ( T_BangEq (. addTerminal(); .) scalar_constant ) | ( T_Bang2Eq (. addTerminal(); .) scalar_constant ) ] ) (. d_stack.pop(); .) 
    .

constant_expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_constant_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ unary_operator ] constant_primary { constant_expression_nlr } ) (. d_stack.pop(); .) 
    .

constant_expression_nlr = 
    ( binary_operator constant_expression ) 
    | ( T_Qmark (. addTerminal(); .) constant_expression T_Colon (. addTerminal(); .) constant_expression ) 
    .

constant_mintypmax_expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_constant_mintypmax_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( constant_expression [ T_Colon (. addTerminal(); .) constant_expression T_Colon (. addTerminal(); .) constant_expression ] ) (. d_stack.pop(); .) 
    .

constant_range_expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_constant_range_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( constant_expression [ ( T_Colon (. addTerminal(); .) lsb_constant_expression ) | ( T_PlusColon (. addTerminal(); .) width_constant_expression ) | ( T_MinusColon (. addTerminal(); .) width_constant_expression ) ] ) (. d_stack.pop(); .) 
    .

dimension_constant_expression = 
    constant_expression 
    .

expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ unary_operator ] primary { expression_nlr } ) (. d_stack.pop(); .) 
    .

expression_nlr = 
    ( binary_operator expression ) 
    | ( T_Qmark (. addTerminal(); .) expression T_Colon (. addTerminal(); .) expression ) 
    .

lsb_constant_expression = 
    constant_expression 
    .

mintypmax_expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_mintypmax_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( expression [ T_Colon (. addTerminal(); .) expression T_Colon (. addTerminal(); .) expression ] ) (. d_stack.pop(); .) 
    .

module_path_expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_path_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ unary_module_path_operator ] module_path_primary module_path_expression_nlr ) (. d_stack.pop(); .) 
    .

module_path_expression_nlr = 
    [ ( binary_module_path_operator module_path_expression module_path_expression_nlr ) 
    | ( T_Qmark (. addTerminal(); .) module_path_expression T_Colon (. addTerminal(); .) module_path_expression module_path_expression_nlr ) ] 
    .

module_path_mintypmax_expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_path_mintypmax_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( module_path_expression [ T_Colon (. addTerminal(); .) module_path_expression T_Colon (. addTerminal(); .) module_path_expression ] ) (. d_stack.pop(); .) 
    .

msb_constant_expression = 
    constant_expression 
    .

range_expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_range_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( expression [ ( T_Colon (. addTerminal(); .) lsb_constant_expression ) | ( T_PlusColon (. addTerminal(); .) width_constant_expression ) | ( T_MinusColon (. addTerminal(); .) width_constant_expression ) ] ) (. d_stack.pop(); .) 
    .

width_constant_expression = 
    constant_expression 
    .

constant_primary = 
    number 
    | string 
    | ( T_Lpar (. addTerminal(); .) constant_mintypmax_expression { T_Comma (. addTerminal(); .) constant_mintypmax_expression } T_Rpar (. addTerminal(); .) ) 
    | ( ( identifier | system_name ) [ ( T_Lbrack (. addTerminal(); .) constant_range_expression T_Rbrack (. addTerminal(); .) ) | ( T_Lpar (. addTerminal(); .) constant_expression { T_Comma (. addTerminal(); .) constant_expression } T_Rpar (. addTerminal(); .) ) ] ) 
    | ( T_Lbrace (. addTerminal(); .) constant_expression [ ( T_Comma (. addTerminal(); .) constant_expression { T_Comma (. addTerminal(); .) constant_expression } ) | ( T_Lbrace (. addTerminal(); .) constant_expression { T_Comma (. addTerminal(); .) constant_expression } T_Rbrace (. addTerminal(); .) ) ] T_Rbrace (. addTerminal(); .) ) 
    .

primary = 
    ( ( hierarchical_identifier_range | system_function_identifier ) [ T_Lpar (. addTerminal(); .) expression { T_Comma (. addTerminal(); .) expression } T_Rpar (. addTerminal(); .) ] ) 
    | number 
    | string 
    | ( T_Lpar (. addTerminal(); .) mintypmax_expression T_Rpar (. addTerminal(); .) ) 
    | ( T_Lbrace (. addTerminal(); .) expression [ ( T_Comma (. addTerminal(); .) expression { T_Comma (. addTerminal(); .) expression } ) | ( T_Lbrace (. addTerminal(); .) expression { T_Comma (. addTerminal(); .) expression } T_Rbrace (. addTerminal(); .) ) ] T_Rbrace (. addTerminal(); .) ) 
    .

module_path_primary = 
    number 
    | ( ( hierarchical_identifier | system_function_identifier ) [ T_Lpar (. addTerminal(); .) expression { T_Comma (. addTerminal(); .) expression } T_Rpar (. addTerminal(); .) ] ) 
    | ( T_Lpar (. addTerminal(); .) module_path_mintypmax_expression T_Rpar (. addTerminal(); .) ) 
    | ( T_Lbrace (. addTerminal(); .) module_path_expression [ ( T_Comma (. addTerminal(); .) module_path_expression { T_Comma (. addTerminal(); .) module_path_expression } ) | ( T_Lbrace (. addTerminal(); .) module_path_expression { T_Comma (. addTerminal(); .) module_path_expression } T_Rbrace (. addTerminal(); .) ) ] T_Rbrace (. addTerminal(); .) ) 
    .

net_lvalue = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_net_lvalue, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( hierarchical_identifier_range_const 
    | ( T_Lbrace (. addTerminal(); .) net_lvalue { T_Comma (. addTerminal(); .) net_lvalue } T_Rbrace (. addTerminal(); .) ) ) (. d_stack.pop(); .) 
    .

variable_lvalue = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_variable_lvalue, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( hierarchical_identifier_range 
    | ( T_Lbrace (. addTerminal(); .) variable_lvalue { T_Comma (. addTerminal(); .) variable_lvalue } T_Rbrace (. addTerminal(); .) ) ) (. d_stack.pop(); .) 
    .

variable_or_net_lvalue = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_variable_or_net_lvalue, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( hierarchical_identifier_range 
    | ( T_Lbrace (. addTerminal(); .) variable_or_net_lvalue { T_Comma (. addTerminal(); .) variable_or_net_lvalue } T_Rbrace (. addTerminal(); .) ) ) (. d_stack.pop(); .) 
    .

unary_operator = 
    T_Plus (. addTerminal(); .) 
    | T_Minus (. addTerminal(); .) 
    | T_Bang (. addTerminal(); .) 
    | T_Tilde (. addTerminal(); .) 
    | T_Amp (. addTerminal(); .) 
    | T_TildeAmp (. addTerminal(); .) 
    | T_Bar (. addTerminal(); .) 
    | T_TildeBar (. addTerminal(); .) 
    | T_Hat (. addTerminal(); .) 
    | T_TildeHat (. addTerminal(); .) 
    | T_HatTilde (. addTerminal(); .) 
    .

binary_operator = 
    T_Plus (. addTerminal(); .) 
    | T_Minus (. addTerminal(); .) 
    | T_Star (. addTerminal(); .) 
    | T_Slash (. addTerminal(); .) 
    | T_Percent (. addTerminal(); .) 
    | T_2Eq (. addTerminal(); .) 
    | T_BangEq (. addTerminal(); .) 
    | T_3Eq (. addTerminal(); .) 
    | T_Bang2Eq (. addTerminal(); .) 
    | T_2Amp (. addTerminal(); .) 
    | T_2Bar (. addTerminal(); .) 
    | T_2Star (. addTerminal(); .) 
    | T_Lt (. addTerminal(); .) 
    | T_Leq (. addTerminal(); .) 
    | T_Gt (. addTerminal(); .) 
    | T_Geq (. addTerminal(); .) 
    | T_Amp (. addTerminal(); .) 
    | T_Bar (. addTerminal(); .) 
    | T_Hat (. addTerminal(); .) 
    | T_HatTilde (. addTerminal(); .) 
    | T_TildeHat (. addTerminal(); .) 
    | T_2Gt (. addTerminal(); .) 
    | T_2Lt (. addTerminal(); .) 
    | T_3Gt (. addTerminal(); .) 
    | T_3Lt (. addTerminal(); .) 
    .

unary_module_path_operator = 
    T_Bang (. addTerminal(); .) 
    | T_Tilde (. addTerminal(); .) 
    | T_Amp (. addTerminal(); .) 
    | T_TildeAmp (. addTerminal(); .) 
    | T_Bar (. addTerminal(); .) 
    | T_TildeBar (. addTerminal(); .) 
    | T_Hat (. addTerminal(); .) 
    | T_TildeHat (. addTerminal(); .) 
    | T_HatTilde (. addTerminal(); .) 
    .

binary_module_path_operator = 
    T_2Eq (. addTerminal(); .) 
    | T_BangEq (. addTerminal(); .) 
    | T_2Amp (. addTerminal(); .) 
    | T_2Bar (. addTerminal(); .) 
    | T_Amp (. addTerminal(); .) 
    | T_Bar (. addTerminal(); .) 
    | T_Hat (. addTerminal(); .) 
    | T_HatTilde (. addTerminal(); .) 
    | T_TildeHat (. addTerminal(); .) 
    .

number = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_number, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( real_number 
    | ( natural_number [ based_number | ( base_format ( base_value | natural_number ) ) ] ) 
    | sizedbased_number 
    | based_number 
    | ( base_format ( base_value | natural_number ) ) ) (. d_stack.pop(); .) 
    .

unsigned_or_real_number = 
    number 
    .

real_number = 
    T_Realnum (. addTerminal(); .) 
    .

natural_number = 
    T_Natural (. addTerminal(); .) 
    .

sizedbased_number = 
    T_SizedBased (. addTerminal(); .) 
    .

based_number = 
    T_BasedInt (. addTerminal(); .) 
    .

base_format = 
    T_BaseFormat (. addTerminal(); .) 
    .

base_value = 
    T_BaseValue (. addTerminal(); .) 
    .

string = 
    T_Str (. addTerminal(); .) 
    .

block_identifier = 
    identifier 
    .

cell_identifier = 
    identifier 
    .

config_identifier = 
    identifier 
    .

event_identifier = 
    identifier 
    .

function_identifier = 
    identifier 
    .

gate_instance_identifier = 
    identifier 
    .

generate_block_identifier = 
    identifier 
    .

genvar_identifier = 
    identifier 
    .

hierarchical_event_identifier = 
    hierarchical_identifier 
    .

hierarchical_identifier = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_hierarchical_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( identifier [ T_Lbrack (. addTerminal(); .) constant_expression T_Rbrack (. addTerminal(); .) ] { T_Dot (. addTerminal(); .) identifier [ T_Lbrack (. addTerminal(); .) constant_expression T_Rbrack (. addTerminal(); .) ] } ) (. d_stack.pop(); .) 
    .

hierarchical_identifier_range = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_hierarchical_identifier_range, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( identifier { ( T_Dot (. addTerminal(); .) identifier ) | ( T_Lbrack (. addTerminal(); .) range_expression T_Rbrack (. addTerminal(); .) ) } ) (. d_stack.pop(); .) 
    .

hierarchical_identifier_range_const = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_hierarchical_identifier_range_const, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( identifier { ( T_Dot (. addTerminal(); .) identifier ) | ( T_Lbrack (. addTerminal(); .) constant_range_expression T_Rbrack (. addTerminal(); .) ) } ) (. d_stack.pop(); .) 
    .

hierarchical_parameter_identifier = 
    hierarchical_identifier 
    .

input_port_identifier = 
    identifier 
    .

instance_identifier = 
    identifier 
    .

library_identifier = 
    identifier 
    .

module_identifier = 
    identifier 
    .

net_identifier = 
    identifier 
    .

output_port_identifier = 
    identifier 
    .

parameter_identifier = 
    identifier 
    .

port_identifier = 
    identifier 
    .

real_identifier = 
    identifier 
    .

specparam_identifier = 
    identifier 
    .

task_identifier = 
    identifier 
    .

terminal_identifier = 
    identifier 
    .

topmodule_identifier = 
    identifier 
    .

udp_identifier = 
    identifier 
    .

variable_identifier = 
    identifier 
    .

system_function_identifier = 
    system_name 
    .

system_task_identifier = 
    system_name 
    .

identifier = 
    T_Ident (. addTerminal(); .) 
    .

system_name = 
    T_SysName (. addTerminal(); .) 
    .

module_or_udp_instantiation = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_or_udp_instantiation, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( identifier [ IF( peek(1) == _T_Lpar && ( peek(2) == _T_pull0 || peek(2) == _T_weak0 || peek(2) == _T_pull1 || peek(2) == _T_supply1 || peek(2) == _T_weak1 || peek(2) == _T_highz0 || peek(2) == _T_highz1 || peek(2) == _T_strong0 || peek(2) == _T_strong1 || peek(2) == _T_supply0 ) ) drive_strength ] [ parameter_value_assignment_or_delay2 ] module_or_udp_instance { T_Comma (. addTerminal(); .) module_or_udp_instance } T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

module_or_udp_instance = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_or_udp_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ identifier ] [ range ] T_Lpar (. addTerminal(); .) [ port_connection_or_output_terminal { T_Comma (. addTerminal(); .) port_connection_or_output_terminal } ] T_Rpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

port_connection_or_output_terminal = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_port_connection_or_output_terminal, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( T_Dot (. addTerminal(); .) port_identifier T_Lpar (. addTerminal(); .) [ expression ] T_Rpar (. addTerminal(); .) ) 
    | [ expression_2 ] ) (. d_stack.pop(); .) 
    .

parameter_value_assignment_or_delay2 = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_parameter_value_assignment_or_delay2, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_Hash (. addTerminal(); .) [ delay_value ] T_Lpar (. addTerminal(); .) ( ( mintypmax_expression { T_Comma (. addTerminal(); .) mintypmax_expression } ) | ( named_parameter_assignment { T_Comma (. addTerminal(); .) named_parameter_assignment } ) ) T_Rpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

expression_2 = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_expression_2, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ unary_operator ] primary_2 { expression_nlr } ) (. d_stack.pop(); .) 
    .

primary_2 = 
    ( ( hierarchical_identifier_range | system_function_identifier ) [ ( T_Lpar (. addTerminal(); .) expression { T_Comma (. addTerminal(); .) expression } T_Rpar (. addTerminal(); .) ) | ( T_Lbrace (. addTerminal(); .) net_lvalue { T_Comma (. addTerminal(); .) net_lvalue } T_Rbrace (. addTerminal(); .) ) ] ) 
    | number 
    | string 
    | ( T_Lpar (. addTerminal(); .) mintypmax_expression T_Rpar (. addTerminal(); .) ) 
    | ( T_Lbrace (. addTerminal(); .) expression [ ( T_Comma (. addTerminal(); .) expression { T_Comma (. addTerminal(); .) expression } ) | ( T_Lbrace (. addTerminal(); .) expression { T_Comma (. addTerminal(); .) expression } T_Rbrace (. addTerminal(); .) ) ] T_Rbrace (. addTerminal(); .) ) 
    .

reg_or_logic = 
    T_reg (. addTerminal(); .) 
    | T_logic (. addTerminal(); .) 
    .

concurrent_or_immediate_assert_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_concurrent_or_immediate_assert_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_assert (. addTerminal(); .) [ ( T_Hash (. addTerminal(); .) natural_number ) | T_final (. addTerminal(); .) | T_property (. addTerminal(); .) ] T_Lpar (. addTerminal(); .) property_spec T_Rpar (. addTerminal(); .) action_block ) (. d_stack.pop(); .) 
    .

concurrent_or_immediate_assume_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_concurrent_or_immediate_assume_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_assume (. addTerminal(); .) [ ( T_Hash (. addTerminal(); .) natural_number ) | T_final (. addTerminal(); .) | T_property (. addTerminal(); .) ] T_Lpar (. addTerminal(); .) property_spec T_Rpar (. addTerminal(); .) action_block ) (. d_stack.pop(); .) 
    .

concurrent_or_immediate_cover_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_concurrent_or_immediate_cover_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_cover (. addTerminal(); .) [ ( T_Hash (. addTerminal(); .) natural_number ) | T_final (. addTerminal(); .) | T_property (. addTerminal(); .) ] T_Lpar (. addTerminal(); .) property_spec T_Rpar (. addTerminal(); .) statement_or_null ) (. d_stack.pop(); .) 
    .

cover_sequence_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_cover_sequence_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_cover (. addTerminal(); .) T_sequence (. addTerminal(); .) T_Lpar (. addTerminal(); .) [ clocking_event ] [ T_disable (. addTerminal(); .) T_iff (. addTerminal(); .) T_Lpar (. addTerminal(); .) expression_or_dist T_Rpar (. addTerminal(); .) ] sequence_expr T_Rpar (. addTerminal(); .) statement_or_null ) (. d_stack.pop(); .) 
    .

restrict_property_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_restrict_property_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( T_restrict (. addTerminal(); .) [ T_property (. addTerminal(); .) ] T_Lpar (. addTerminal(); .) property_spec T_Rpar (. addTerminal(); .) T_Semi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

action_block = 
    statement_or_null [ T_else (. addTerminal(); .) statement_or_null ] 
    .

simple_or_deferred_or_property_immediate_assertion_statement = 
    concurrent_or_immediate_assert_statement 
    | concurrent_or_immediate_assume_statement 
    | concurrent_or_immediate_cover_statement 
    .

procedural_assertion_statement = 
    concurrent_assertion_statement 
    .

concurrent_assertion_statement = 
    ( IF( peek(1) == _T_cover && peek(2) == _T_sequence ) cover_sequence_statement ) 
    | simple_or_deferred_or_property_immediate_assertion_statement 
    | restrict_property_statement 
    .

property_spec = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_property_spec, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ clocking_event ] [ T_disable (. addTerminal(); .) T_iff (. addTerminal(); .) T_Lpar (. addTerminal(); .) expression_or_dist T_Rpar (. addTerminal(); .) ] property_expr ) (. d_stack.pop(); .) 
    .

clocking_event = 
    T_At (. addTerminal(); .) ( identifier | ( T_Lpar (. addTerminal(); .) event_expression T_Rpar (. addTerminal(); .) ) ) 
    .

expression_or_dist = 
    expression [ T_dist (. addTerminal(); .) T_Lbrace (. addTerminal(); .) dist_list T_Rbrace (. addTerminal(); .) ] 
    .

dist_list = 
    dist_item { T_Comma (. addTerminal(); .) dist_item } 
    .

dist_item = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dist_item, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( value_range [ dist_weight ] ) (. d_stack.pop(); .) 
    .

dist_weight = 
    ( T_ColonEq (. addTerminal(); .) | T_ColonSlash (. addTerminal(); .) ) expression 
    .

value_range = 
    expression 
    | ( T_Lbrack (. addTerminal(); .) expression T_Colon (. addTerminal(); .) expression T_Rbrack (. addTerminal(); .) ) 
    .

property_expr = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_property_expr, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( sequence_expr [ ( ( T_Bar2Minus (. addTerminal(); .) | T_Bar2Eq (. addTerminal(); .) | T_Hash2Minus (. addTerminal(); .) | T_Hash2Eq (. addTerminal(); .) ) property_expr ) | ( T_Lpar (. addTerminal(); .) property_expr T_Rpar (. addTerminal(); .) ) ] property_expr_nlr ) 
    | ( T_strong (. addTerminal(); .) T_Lpar (. addTerminal(); .) sequence_expr T_Rpar (. addTerminal(); .) property_expr_nlr ) 
    | ( T_weak (. addTerminal(); .) T_Lpar (. addTerminal(); .) sequence_expr T_Rpar (. addTerminal(); .) property_expr_nlr ) 
    | ( T_not (. addTerminal(); .) property_expr property_expr_nlr ) 
    | ( T_if (. addTerminal(); .) expression_or_dist property_expr [ T_else (. addTerminal(); .) property_expr ] property_expr_nlr ) 
    | ( T_case (. addTerminal(); .) expression_or_dist property_case_item { property_case_item } T_endcase (. addTerminal(); .) property_expr_nlr ) 
    | ( T_nexttime (. addTerminal(); .) [ T_Lbrack (. addTerminal(); .) constant_expression T_Rbrack (. addTerminal(); .) ] property_expr property_expr_nlr ) 
    | ( T_s_nexttime (. addTerminal(); .) [ T_Lbrack (. addTerminal(); .) constant_expression T_Rbrack (. addTerminal(); .) ] property_expr property_expr_nlr ) 
    | ( T_always (. addTerminal(); .) [ T_Lbrack (. addTerminal(); .) cycle_delay_const_range_expression T_Rbrack (. addTerminal(); .) ] property_expr property_expr_nlr ) 
    | ( T_s_always (. addTerminal(); .) T_Lbrack (. addTerminal(); .) constant_range T_Rbrack (. addTerminal(); .) property_expr property_expr_nlr ) 
    | ( T_s_eventually (. addTerminal(); .) [ T_Lbrack (. addTerminal(); .) cycle_delay_const_range_expression T_Rbrack (. addTerminal(); .) ] property_expr property_expr_nlr ) 
    | ( T_eventually (. addTerminal(); .) T_Lbrack (. addTerminal(); .) constant_range T_Rbrack (. addTerminal(); .) property_expr property_expr_nlr ) 
    | ( T_accept_on (. addTerminal(); .) T_Lpar (. addTerminal(); .) expression_or_dist T_Rpar (. addTerminal(); .) property_expr property_expr_nlr ) 
    | ( T_reject_on (. addTerminal(); .) T_Lpar (. addTerminal(); .) expression_or_dist T_Rpar (. addTerminal(); .) property_expr property_expr_nlr ) 
    | ( T_sync_accept_on (. addTerminal(); .) T_Lpar (. addTerminal(); .) expression_or_dist T_Rpar (. addTerminal(); .) property_expr property_expr_nlr ) 
    | ( T_sync_reject_on (. addTerminal(); .) T_Lpar (. addTerminal(); .) expression_or_dist T_Rpar (. addTerminal(); .) property_expr property_expr_nlr ) 
    | ( clocking_event property_expr property_expr_nlr ) ) (. d_stack.pop(); .) 
    .

property_expr_nlr = 
    [ ( T_or (. addTerminal(); .) property_expr property_expr_nlr ) 
    | ( T_and (. addTerminal(); .) property_expr property_expr_nlr ) 
    | ( T_until (. addTerminal(); .) property_expr property_expr_nlr ) 
    | ( T_s_until (. addTerminal(); .) property_expr property_expr_nlr ) 
    | ( T_until_with (. addTerminal(); .) property_expr property_expr_nlr ) 
    | ( T_s_until_with (. addTerminal(); .) property_expr property_expr_nlr ) 
    | ( T_implies (. addTerminal(); .) property_expr property_expr_nlr ) 
    | ( T_iff (. addTerminal(); .) property_expr property_expr_nlr ) ] 
    .

property_case_item = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_property_case_item, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( expression_or_dist { T_Comma (. addTerminal(); .) expression_or_dist } T_Colon (. addTerminal(); .) property_expr [ T_Semi (. addTerminal(); .) ] ) 
    | ( T_default (. addTerminal(); .) [ T_Colon (. addTerminal(); .) ] property_expr [ T_Semi (. addTerminal(); .) ] ) ) (. d_stack.pop(); .) 
    .

constant_range = 
    constant_expression T_Colon (. addTerminal(); .) constant_expression 
    .

cycle_delay_const_range_expression = 
    constant_expression T_Colon (. addTerminal(); .) ( constant_expression | T_Dlr (. addTerminal(); .) ) 
    .

sequence_expr = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_sequence_expr, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( cycle_delay_range sequence_expr { cycle_delay_range sequence_expr } sequence_expr_nlr ) 
    | ( expression_or_dist ( [ boolean_abbrev ] | ( T_throughout (. addTerminal(); .) sequence_expr ) ) sequence_expr_nlr ) ) (. d_stack.pop(); .) 
    .

sequence_expr_nlr = 
    [ ( T_and (. addTerminal(); .) sequence_expr sequence_expr_nlr ) 
    | ( T_intersect (. addTerminal(); .) sequence_expr sequence_expr_nlr ) 
    | ( T_or (. addTerminal(); .) sequence_expr sequence_expr_nlr ) 
    | ( T_within (. addTerminal(); .) sequence_expr sequence_expr_nlr ) ] 
    .

cycle_delay_range = 
    ( T_2Hash (. addTerminal(); .) [ cycle_delay_const_range_expression ] ) 
    | T_2HashLbrackStarRbrack (. addTerminal(); .) 
    | T_2HashLbrackPlusRbrack (. addTerminal(); .) 
    .

boolean_abbrev = 
    consecutive_repetition 
    | non_consecutive_repetition 
    | goto_repetition 
    .

consecutive_repetition = 
    ( T_LbrackStar (. addTerminal(); .) const_or_range_expression T_Rbrack (. addTerminal(); .) ) 
    | T_Lbrack2Star (. addTerminal(); .) 
    | T_Lbrack2Plus (. addTerminal(); .) 
    .

non_consecutive_repetition = 
    T_LbrackEq (. addTerminal(); .) const_or_range_expression T_Rbrack (. addTerminal(); .) 
    .

goto_repetition = 
    T_Lbrack2Minus (. addTerminal(); .) const_or_range_expression T_Rbrack (. addTerminal(); .) 
    .

const_or_range_expression = 
    cycle_delay_const_range_expression 
    .

END Verilog05 .
