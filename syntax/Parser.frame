/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University
modified by Rochus Keller, me@rochus-keller.ch, (c) 2018

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

/*----------------------------------------------------------------------
Parser.h Specification
-----------------------------------------------------------------------*/

-->begin

// This file was automatically generated by Coco/R; don't modify it.
#if !defined(-->prefixCOCO_PARSER_H__)
#define -->prefixCOCO_PARSER_H__

-->headerdef

#include "VlPpLexer.h"

-->namespace_open

class Errors {
public:
	int count;			// number of errors detected

	Errors();
    static void SynErr(const QString& sourcePath, int line, int col, int n, Vl::Errors* err, const char* ctx, const QString& = QString() );
	void Error(int line, int col, const char *s);
	void Warning(int line, int col, const char *s);
	void Warning(const char *s);
	void Exception(const char *s);

}; // Errors

class Parser {
private:
-->constantsheader
	int errDist;
	int minErrDist;

	void SynErr(int n, const char* ctx = 0);
	void Get();
	void Expect(int n, const char* ctx = 0);
	bool StartOf(int s);
	void ExpectWeak(int n, int follow);
	bool WeakSeparator(int n, int syFol, int repFol);

public:
	Vl::PpLexer *scanner;
	Vl::Errors  *errors;

	Vl::Token d_cur;
	Vl::Token d_next;
	struct TokDummy
	{
		int kind;
	};
	TokDummy d_dummy;
	TokDummy *la;			// lookahead token
	QList<Vl::Token> d_sections;
	
	int peek( quint8 la = 1 );

    void RunParser()
    {
        d_stack.push(&d_root);
        Parse();
        d_stack.pop();
    }
    
-->declarations

	Parser(Vl::PpLexer *scanner,Vl::Errors*);
	~Parser();
	void SemErr(const char* msg);

-->productionsheader
	void Parse();

}; // end Parser

-->namespace_close

#endif

-->implementation

/*----------------------------------------------------------------------
Parser.cpp Specification
-----------------------------------------------------------------------*/

-->begin

// This file was automatically generated by Coco/R; don't modify it.
#include "CocoParser.h"
#include "VlErrors.h"
#include <QtDebug>
#include <QFileInfo>

-->namespace_open

static QString coco_string_create( const wchar_t* str )
{
    return QString::fromStdWString(str);
}

int Parser::peek( quint8 la )
{
	if( la == 0 )
		return d_cur.d_type;
	else if( la == 1 )
		return d_next.d_type;
	else
		return scanner->peekToken( la - 1 ).d_type;
}


void Parser::SynErr(int n, const char* ctx) {
    if (errDist >= minErrDist)
    {
        if( d_next.d_substituted )
        {
            QFileInfo info(d_next.d_sourcePath);
            QString str = QString(": included from here: %1:%2:%3")
                    .arg(info.fileName()).arg(d_next.d_lineNr).arg(d_next.d_colNr);
            Errors::SynErr(scanner->getMainSource(),scanner->getMainLineNr(), scanner->getMainColNr(),
                           n, errors, ctx, str );
        }else
            Errors::SynErr(d_next.d_sourcePath,d_next.d_lineNr, d_next.d_colNr, n, errors, ctx);
    }
	errDist = 0;
}

void Parser::SemErr(const char* msg) {
	if (errDist >= minErrDist) errors->error(Vl::Errors::Semantics,d_cur.d_sourcePath,d_cur.d_lineNr, d_cur.d_colNr, msg);
	errDist = 0;
}

void Parser::Get() {
	for (;;) {
		d_cur = d_next;
		d_next = scanner->nextToken();
        bool deliverToParser = false;
        switch( d_next.d_type )
        {
        case Vl::Tok_Invalid:
        	if( !d_next.d_val.isEmpty() )
            	SynErr( d_next.d_type, d_next.d_val );
            // else errors already handeled in lexer
            break;
        case Vl::Tok_MacroUsage:
            {
                Vl::SynTree* n = new Vl::SynTree( Vl::Tok_MacroUsage, d_next );
                d_stack.top()->d_children.append(n);
                for(;;)
                {
                    Vl::Token t = scanner->nextToken();
                    if( t.d_prePp )
                    {
                        if( t.d_type == Vl::Tok_Ident || t.d_type == Vl::Tok_CoDi )
                            n->d_children.append( new Vl::SynTree( t ) );
                        // else ignore
                    }else
                    {
                        // regular end
                        d_next = t;
                        deliverToParser = true;
                        break;
                    }
                }
            }
            break;
        case Vl::Tok_Attribute:
            {
                Vl::SynTree* n = new Vl::SynTree( Vl::Tok_Attribute, d_next );
                d_stack.top()->d_children.append(n);
            }
            break;
        case Vl::Tok_Latt:
            {
                Vl::SynTree* n = new Vl::SynTree( Vl::Tok_Attribute, d_next );
                d_stack.top()->d_children.append(n);
                for(;;)
                {
                    Vl::Token t = scanner->nextToken();
                    if( t.d_type == Vl::Tok_Ratt )
                    {
                        // regular end
                        break;
                    }else if( t.d_type == Vl::Tok_Eof || t.d_type == Vl::Tok_Latt )
                    {
                        // irregular end
                        d_cur = d_next;
                        SemErr("non-terminated attribute");
                        break;
                    }else
                    {
                        if( t.d_type == Vl::Tok_Ident || t.d_type == Vl::Tok_CoDi )
                            n->d_children.append( new Vl::SynTree( t ) );
                        // else ignore
                    }
                }
            }
            break;
        case Vl::Tok_Comment:
            // ignorieren
            break;
        case Vl::Tok_Section:
        case Vl::Tok_SectionEnd:
            d_sections.append(d_next);
            break;
        default:
            deliverToParser = true;
            break;
        }

        if( deliverToParser )
        {
            if( d_next.d_type == Vl::Tok_Eof )
                d_next.d_type = _EOF;

            la->kind = d_next.d_type;
            if (la->kind <= maxT)
            {
                ++errDist;
                break;
            }
        }
-->pragmas
		d_next = d_cur;
	}
}

void Parser::Expect(int n, const char* ctx ) {
	if (la->kind==n) Get(); else { SynErr(n, ctx); }
}

void Parser::ExpectWeak(int n, int follow) {
	if (la->kind == n) Get();
	else {
		SynErr(n);
		while (!StartOf(follow)) Get();
	}
}

bool Parser::WeakSeparator(int n, int syFol, int repFol) {
	if (la->kind == n) {Get(); return true;}
	else if (StartOf(repFol)) {return false;}
	else {
		SynErr(n);
		while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
			Get();
		}
		return StartOf(syFol);
	}
}

-->productions


// If the user declared a method Init and a mehtod Destroy they should
// be called in the contructur and the destructor respctively.
//
// The following templates are used to recognize if the user declared
// the methods Init and Destroy.

template<typename T>
struct ParserInitExistsRecognizer {
	template<typename U, void (U::*)() = &U::Init>
	struct ExistsIfInitIsDefinedMarker{};

	struct InitIsMissingType {
		char dummy1;
	};
	
	struct InitExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static InitIsMissingType is_here(...);

	// exist only if ExistsIfInitIsDefinedMarker is defined
	template<typename U>
	static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

	enum { InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType)) };
};

template<typename T>
struct ParserDestroyExistsRecognizer {
	template<typename U, void (U::*)() = &U::Destroy>
	struct ExistsIfDestroyIsDefinedMarker{};

	struct DestroyIsMissingType {
		char dummy1;
	};
	
	struct DestroyExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static DestroyIsMissingType is_here(...);

	// exist only if ExistsIfDestroyIsDefinedMarker is defined
	template<typename U>
	static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

	enum { DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType)) };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller {
	static void CallInit(T *t) {
		// nothing to do
	}
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true> {
	static void CallInit(T *t) {
		t->Init();
	}
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller {
	static void CallDestroy(T *t) {
		// nothing to do
	}
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true> {
	static void CallDestroy(T *t) {
		t->Destroy();
	}
};

void Parser::Parse() {
	d_cur = Vl::Token();
	d_next = Vl::Token();
	Get();
-->parseRoot
}

Parser::Parser(Vl::PpLexer *scanner, Vl::Errors* err) {
-->constants
	ParserInitCaller<Parser>::CallInit(this);
	la = &d_dummy;
	minErrDist = 2;
	errDist = minErrDist;
	this->scanner = scanner;
	errors = err;
}

bool Parser::StartOf(int s) {
	const bool T = true;
	const bool x = false;

-->initialization

	return set[s][la->kind];
}

Parser::~Parser() {
	ParserDestroyCaller<Parser>::CallDestroy(this);
}

Errors::Errors() {
	count = 0;
}

void Errors::SynErr(const QString& sourcePath, int line, int col, int n, Vl::Errors* err, const char* ctx, const QString& str ) {
	QString s;
	QString ctxStr;
	if( ctx )
		ctxStr = QString( " in %1" ).arg(ctx);
    if( n == 0 )
        s = QString("EOF expected%1").arg(ctxStr);
    else if( n < Vl::TT_Specials )
        s = QString("'%2' expected%1").arg(ctxStr).arg(Vl::tokenToString(n));
    else if( n <= Vl::TT_Max )
        s = QString("%2 expected%1").arg(ctxStr).arg(Vl::tokenToString(n));
    else
	switch (n) {
-->errors
		default:
		{
			s = QString( "generic error %1").arg(n);
		}
		break;
	}
    if( !str.isEmpty() )
        s = QString("%1 %2").arg(s).arg(str);
	if( err )
		err->error(Vl::Errors::Syntax, sourcePath, line, col, s);
	else
		qCritical() << "Error Parser" << line << col << s;
	//count++;
}

void Errors::Error(int line, int col, const char *s) {
	printf("-- line %d col %d: %s\n", line, col, s);
	count++;
}

void Errors::Warning(int line, int col, const char *s) {
	printf("-- line %d col %d: %s\n", line, col, s);
}

void Errors::Warning(const char *s) {
	printf("%s\n", s);
}

void Errors::Exception(const char* s) {
	printf("%s", s); 
	exit(1);
}

-->namespace_close
