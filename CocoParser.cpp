

// This file was automatically generated by Coco/R; don't modify it.
#include "CocoParser.h"
#include "VlErrors.h"
#include <QtDebug>
#include <QFileInfo>

namespace Coco {


static QString coco_string_create( const wchar_t* str )
{
    return QString::fromStdWString(str);
}

int Parser::peek( quint8 la )
{
	if( la == 0 )
		return d_cur.d_type;
	else if( la == 1 )
		return d_next.d_type;
	else
		return scanner->peekToken( la - 1 ).d_type;
}


void Parser::SynErr(int n, const char* ctx) {
    if (errDist >= minErrDist)
    {
        if( d_next.d_substituted )
        {
            QFileInfo info(d_next.d_sourcePath);
            QString str = QString(": included from here: %1:%2:%3")
                    .arg(info.fileName()).arg(d_next.d_lineNr).arg(d_next.d_colNr);
            Errors::SynErr(scanner->getMainSource(),scanner->getMainLineNr(), scanner->getMainColNr(),
                           n, errors, ctx, str );
        }else
            Errors::SynErr(d_next.d_sourcePath,d_next.d_lineNr, d_next.d_colNr, n, errors, ctx);
    }
	errDist = 0;
}

void Parser::SemErr(const char* msg) {
	if (errDist >= minErrDist) errors->error(Vl::Errors::Semantics,d_cur.d_sourcePath,d_cur.d_lineNr, d_cur.d_colNr, msg);
	errDist = 0;
}

void Parser::Get() {
	for (;;) {
		d_cur = d_next;
		d_next = scanner->nextToken();
        bool deliverToParser = false;
        switch( d_next.d_type )
        {
        case Vl::Tok_Invalid:
        	if( !d_next.d_val.isEmpty() )
            	SynErr( d_next.d_type, d_next.d_val );
            // else errors already handeled in lexer
            break;
        case Vl::Tok_MacroUsage:
            {
                Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_MacroUsage, d_next );
                d_stack.top()->d_children.append(n);
                for(;;)
                {
                    Vl::Token t = scanner->nextToken();
                    if( t.d_prePp )
                    {
                        if( t.d_type == Vl::Tok_Ident || t.d_type == Vl::Tok_CoDi )
                            n->d_children.append( new Vl::SynTree( t ) );
                        // else ignore
                    }else
                    {
                        // regular end
                        d_next = t;
                        deliverToParser = true;
                        break;
                    }
                }
            }
            break;
        case Vl::Tok_Attribute:
            {
                Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_Attribute, d_next );
                d_stack.top()->d_children.append(n);
            }
            break;
        case Vl::Tok_Latt:
            {
                Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_Attribute, d_next );
                d_stack.top()->d_children.append(n);
                for(;;)
                {
                    Vl::Token t = scanner->nextToken();
                    if( t.d_type == Vl::Tok_Ratt )
                    {
                        // regular end
                        break;
                    }else if( t.d_type == Vl::Tok_Eof || t.d_type == Vl::Tok_Latt )
                    {
                        // irregular end
                        d_cur = d_next;
                        SemErr("non-terminated attribute");
                        break;
                    }else
                    {
                        if( t.d_type == Vl::Tok_Ident || t.d_type == Vl::Tok_CoDi )
                            n->d_children.append( new Vl::SynTree( t ) );
                        // else ignore
                    }
                }
            }
            break;
        case Vl::Tok_Comment:
            // ignorieren
            break;
        case Vl::Tok_Section:
        case Vl::Tok_SectionEnd:
            d_sections.append(d_next);
            break;
        default:
            deliverToParser = true;
            break;
        }

        if( deliverToParser )
        {
            if( d_next.d_type == Vl::Tok_Eof )
                d_next.d_type = _EOF;

            la->kind = d_next.d_type;
            if (la->kind <= maxT)
            {
                ++errDist;
                break;
            }
        }

		d_next = d_cur;
	}
}

void Parser::Expect(int n, const char* ctx ) {
	if (la->kind==n) Get(); else { SynErr(n, ctx); }
}

void Parser::ExpectWeak(int n, int follow) {
	if (la->kind == n) Get();
	else {
		SynErr(n);
		while (!StartOf(follow)) Get();
	}
}

bool Parser::WeakSeparator(int n, int syFol, int repFol) {
	if (la->kind == n) {Get(); return true;}
	else if (StartOf(repFol)) {return false;}
	else {
		SynErr(n);
		while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
			Get();
		}
		return StartOf(syFol);
	}
}

void Parser::Verilog05() {
		d_stack.push(&d_root); 
		translation_unit();
		d_stack.pop(); 
}

void Parser::translation_unit() {
		while (StartOf(1)) {
			if (la->kind == _Tmacromodule || la->kind == _Tmodule) {
				module_declaration();
			} else if (la->kind == _Tprimitive) {
				udp_declaration();
			} else if (la->kind == _Tconfig) {
				config_declaration();
			} else if (la->kind == _Tlibrary) {
				library_declaration();
			} else {
				include_statement();
			}
		}
}

void Parser::identifier() {
		Expect(_TIdent,__FUNCTION__);
		addTerminal(); 
}

void Parser::system_name() {
		Expect(_TSysName,__FUNCTION__);
		addTerminal(); 
}

void Parser::real_number() {
		Expect(_TRealnum,__FUNCTION__);
		addTerminal(); 
}

void Parser::natural_number() {
		Expect(_TNatural,__FUNCTION__);
		addTerminal(); 
}

void Parser::sizedbased_number() {
		Expect(_TSizedBased,__FUNCTION__);
		addTerminal(); 
}

void Parser::based_number() {
		Expect(_TBasedInt,__FUNCTION__);
		addTerminal(); 
}

void Parser::base_format() {
		Expect(_TBaseFormat,__FUNCTION__);
		addTerminal(); 
}

void Parser::base_value() {
		Expect(_TBaseValue,__FUNCTION__);
		addTerminal(); 
}

void Parser::string() {
		Expect(_TString,__FUNCTION__);
		addTerminal(); 
}

void Parser::unary_operator() {
		switch (la->kind) {
		case _TPlus: {
			Get();
			addTerminal(); 
			break;
		}
		case _TMinus: {
			Get();
			addTerminal(); 
			break;
		}
		case _TBang: {
			Get();
			addTerminal(); 
			break;
		}
		case _TTilde: {
			Get();
			addTerminal(); 
			break;
		}
		case _TAmp: {
			Get();
			addTerminal(); 
			break;
		}
		case _TTildeAmp: {
			Get();
			addTerminal(); 
			break;
		}
		case _TBar: {
			Get();
			addTerminal(); 
			break;
		}
		case _TTildeBar: {
			Get();
			addTerminal(); 
			break;
		}
		case _THat: {
			Get();
			addTerminal(); 
			break;
		}
		case _TTildeHat: {
			Get();
			addTerminal(); 
			break;
		}
		case _THatTilde: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(206,__FUNCTION__); break;
		}
}

void Parser::binary_operator() {
		switch (la->kind) {
		case _TPlus: {
			Get();
			addTerminal(); 
			break;
		}
		case _TMinus: {
			Get();
			addTerminal(); 
			break;
		}
		case _TStar: {
			Get();
			addTerminal(); 
			break;
		}
		case _TSlash: {
			Get();
			addTerminal(); 
			break;
		}
		case _TPercent: {
			Get();
			addTerminal(); 
			break;
		}
		case _T2Eq: {
			Get();
			addTerminal(); 
			break;
		}
		case _TBangEq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T3Eq: {
			Get();
			addTerminal(); 
			break;
		}
		case _TBang2Eq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T2Amp: {
			Get();
			addTerminal(); 
			break;
		}
		case _T2Bar: {
			Get();
			addTerminal(); 
			break;
		}
		case _T2Star: {
			Get();
			addTerminal(); 
			break;
		}
		case _TLt: {
			Get();
			addTerminal(); 
			break;
		}
		case _TLeq: {
			Get();
			addTerminal(); 
			break;
		}
		case _TGt: {
			Get();
			addTerminal(); 
			break;
		}
		case _TGeq: {
			Get();
			addTerminal(); 
			break;
		}
		case _TAmp: {
			Get();
			addTerminal(); 
			break;
		}
		case _TBar: {
			Get();
			addTerminal(); 
			break;
		}
		case _THat: {
			Get();
			addTerminal(); 
			break;
		}
		case _THatTilde: {
			Get();
			addTerminal(); 
			break;
		}
		case _TTildeHat: {
			Get();
			addTerminal(); 
			break;
		}
		case _T2Gt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T2Lt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T3Gt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T3Lt: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(207,__FUNCTION__); break;
		}
}

void Parser::unary_module_path_operator() {
		switch (la->kind) {
		case _TBang: {
			Get();
			addTerminal(); 
			break;
		}
		case _TTilde: {
			Get();
			addTerminal(); 
			break;
		}
		case _TAmp: {
			Get();
			addTerminal(); 
			break;
		}
		case _TTildeAmp: {
			Get();
			addTerminal(); 
			break;
		}
		case _TBar: {
			Get();
			addTerminal(); 
			break;
		}
		case _TTildeBar: {
			Get();
			addTerminal(); 
			break;
		}
		case _THat: {
			Get();
			addTerminal(); 
			break;
		}
		case _TTildeHat: {
			Get();
			addTerminal(); 
			break;
		}
		case _THatTilde: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(208,__FUNCTION__); break;
		}
}

void Parser::binary_module_path_operator() {
		switch (la->kind) {
		case _T2Eq: {
			Get();
			addTerminal(); 
			break;
		}
		case _TBangEq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T2Amp: {
			Get();
			addTerminal(); 
			break;
		}
		case _T2Bar: {
			Get();
			addTerminal(); 
			break;
		}
		case _TAmp: {
			Get();
			addTerminal(); 
			break;
		}
		case _TBar: {
			Get();
			addTerminal(); 
			break;
		}
		case _THat: {
			Get();
			addTerminal(); 
			break;
		}
		case _TTildeHat: {
			Get();
			addTerminal(); 
			break;
		}
		case _THatTilde: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(209,__FUNCTION__); break;
		}
}

void Parser::module_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		module_keyword();
		module_identifier();
		if (la->kind == _THash) {
			module_parameter_port_list();
		}
		if (la->kind == _TLpar) {
			Get();
			addTerminal(); 
			if (StartOf(2)) {
				if (la->kind == _TLbrace || la->kind == _TDot || la->kind == _TIdent) {
					list_of_ports();
				} else {
					list_of_port_declarations();
				}
			}
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
		}
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		while (StartOf(3)) {
			module_item();
		}
		Expect(_Tendmodule,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::udp_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tprimitive,__FUNCTION__);
		addTerminal(); 
		udp_identifier();
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _TIdent) {
			udp_port_list();
		} else if (la->kind == _Toutput) {
			udp_declaration_port_list();
		} else SynErr(210,__FUNCTION__);
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		while (la->kind == _Tinput || la->kind == _Toutput || la->kind == _Treg) {
			udp_port_declaration();
		}
		udp_body();
		Expect(_Tendprimitive,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::config_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_config_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tconfig,__FUNCTION__);
		addTerminal(); 
		config_identifier();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		design_statement();
		while (la->kind == _Tcell || la->kind == _Tdefault || la->kind == _Tinstance) {
			config_rule_statement();
		}
		Expect(_Tendconfig,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::library_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_library_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tlibrary,__FUNCTION__);
		addTerminal(); 
		library_identifier();
		file_path_spec();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			file_path_spec();
		}
		if (la->kind == _TMinus) {
			Get();
			addTerminal(); 
			Expect(_Tincdir,__FUNCTION__);
			addTerminal(); 
			file_path_spec();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				file_path_spec();
			}
		}
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::include_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_include_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tinclude,__FUNCTION__);
		addTerminal(); 
		file_path_spec();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::library_identifier() {
		identifier();
}

void Parser::file_path_spec() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_file_path_spec, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TIdent) {
			identifier();
		} else if (la->kind == _TString) {
			string();
		} else SynErr(211,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::module_keyword() {
		if (la->kind == _Tmodule) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Tmacromodule) {
			Get();
			addTerminal(); 
		} else SynErr(212,__FUNCTION__);
}

void Parser::module_identifier() {
		identifier();
}

void Parser::module_parameter_port_list() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_parameter_port_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_THash,__FUNCTION__);
		addTerminal(); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		parameter_declaration();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			parameter_declaration();
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::list_of_ports() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_ports, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		port();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			if (la->kind == _TLbrace || la->kind == _TDot || la->kind == _TIdent) {
				port();
			}
		}
		d_stack.pop(); 
}

void Parser::list_of_port_declarations() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_port_declarations, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		port_declaration();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			port_declaration();
		}
		d_stack.pop(); 
}

void Parser::module_item() {
		if (la->kind == _Tinout || la->kind == _Tinput || la->kind == _Toutput) {
			port_declaration();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
		} else if (StartOf(4)) {
			non_port_module_item();
		} else SynErr(213,__FUNCTION__);
}

void Parser::parameter_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_parameter_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tparameter,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _TLbrack || la->kind == _Tsigned || la->kind == _TIdent) {
			if (la->kind == _Tsigned) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _TLbrack) {
				range();
			}
		} else if (StartOf(5)) {
			parameter_type();
		} else SynErr(214,__FUNCTION__);
		list_of_param_assignments();
		d_stack.pop(); 
}

void Parser::port() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_port, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TLbrace || la->kind == _TIdent) {
			port_expression();
		} else if (la->kind == _TDot) {
			Get();
			addTerminal(); 
			port_identifier();
			Expect(_TLpar,__FUNCTION__);
			addTerminal(); 
			if (la->kind == _TLbrace || la->kind == _TIdent) {
				port_expression();
			}
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
		} else SynErr(215,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::port_declaration() {
		if (la->kind == _Tinout) {
			inout_declaration();
		} else if (la->kind == _Tinput) {
			input_declaration();
		} else if (la->kind == _Toutput) {
			output_declaration();
		} else SynErr(216,__FUNCTION__);
}

void Parser::port_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_port_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TIdent) {
			port_reference();
		} else if (la->kind == _TLbrace) {
			Get();
			addTerminal(); 
			port_reference();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				port_reference();
			}
			Expect(_TRbrace,__FUNCTION__);
			addTerminal(); 
		} else SynErr(217,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::port_identifier() {
		identifier();
}

void Parser::port_reference() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_port_reference, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		port_identifier();
		if (la->kind == _TLbrack) {
			Get();
			addTerminal(); 
			constant_range_expression();
			Expect(_TRbrack,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::constant_range_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_constant_range_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		constant_expression();
		if (la->kind == _TColon || la->kind == _TPlusColon || la->kind == _TMinusColon) {
			if (la->kind == _TColon) {
				Get();
				addTerminal(); 
				lsb_constant_expression();
			} else if (la->kind == _TPlusColon) {
				Get();
				addTerminal(); 
				width_constant_expression();
			} else {
				Get();
				addTerminal(); 
				width_constant_expression();
			}
		}
		d_stack.pop(); 
}

void Parser::inout_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_inout_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tinout,__FUNCTION__);
		addTerminal(); 
		if (StartOf(6)) {
			net_type();
		}
		if (la->kind == _Tsigned) {
			Get();
			addTerminal(); 
		}
		if (la->kind == _TLbrack) {
			range();
		}
		list_of_port_identifiers();
		d_stack.pop(); 
}

void Parser::input_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_input_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tinput,__FUNCTION__);
		addTerminal(); 
		if (StartOf(6)) {
			net_type();
		}
		if (la->kind == _Tsigned) {
			Get();
			addTerminal(); 
		}
		if (la->kind == _TLbrack) {
			range();
		}
		list_of_port_identifiers();
		d_stack.pop(); 
}

void Parser::output_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_output_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Toutput,__FUNCTION__);
		addTerminal(); 
		if (StartOf(7)) {
			if (StartOf(6)) {
				net_type();
			}
			if (la->kind == _Tsigned) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _TLbrack) {
				range();
			}
			list_of_port_identifiers();
		} else if (la->kind == _Treg) {
			Get();
			addTerminal(); 
			if (la->kind == _Tsigned) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _TLbrack) {
				range();
			}
			list_of_variable_port_identifiers();
		} else if (la->kind == _Tinteger || la->kind == _Ttime) {
			output_variable_type();
			list_of_variable_port_identifiers();
		} else SynErr(218,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::non_port_module_item() {
		if (StartOf(8)) {
			module_or_generate_item();
		} else if (la->kind == _Tgenerate) {
			generate_region();
		} else if (la->kind == _Tspecify) {
			specify_block();
		} else if (la->kind == _Tparameter) {
			parameter_declaration();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _Tspecparam) {
			specparam_declaration();
		} else SynErr(219,__FUNCTION__);
}

void Parser::module_or_generate_item() {
		switch (la->kind) {
		case _Tevent: case _Tfunction: case _Tgenvar: case _Tinteger: case _Treal: case _Trealtime: case _Treg: case _Tsupply0: case _Tsupply1: case _Ttask: case _Ttime: case _Ttri: case _Ttri0: case _Ttri1: case _Ttriand: case _Ttrior: case _Ttrireg: case _Tuwire: case _Twand: case _Twire: case _Twor: {
			module_or_generate_item_declaration();
			break;
		}
		case _Tlocalparam: {
			local_parameter_declaration();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _Tdefparam: {
			parameter_override();
			break;
		}
		case _Tassign: {
			continuous_assign();
			break;
		}
		case _Tand: case _Tbuf: case _Tbufif0: case _Tbufif1: case _Tcmos: case _Tnand: case _Tnmos: case _Tnor: case _Tnot: case _Tnotif0: case _Tnotif1: case _Tor: case _Tpmos: case _Tpulldown: case _Tpullup: case _Trcmos: case _Trnmos: case _Trpmos: case _Trtran: case _Trtranif0: case _Trtranif1: case _Ttran: case _Ttranif0: case _Ttranif1: case _Txnor: case _Txor: {
			gate_instantiation();
			break;
		}
		case _TIdent: {
			module_or_udp_instantiation();
			break;
		}
		case _Tinitial: {
			initial_construct();
			break;
		}
		case _Talways: {
			always_construct();
			break;
		}
		case _Tfor: {
			loop_generate_construct();
			break;
		}
		case _Tcase: case _Tif: {
			conditional_generate_construct();
			break;
		}
		default: SynErr(220,__FUNCTION__); break;
		}
}

void Parser::module_or_generate_item_declaration() {
		switch (la->kind) {
		case _Tsupply0: case _Tsupply1: case _Ttri: case _Ttri0: case _Ttri1: case _Ttriand: case _Ttrior: case _Ttrireg: case _Tuwire: case _Twand: case _Twire: case _Twor: {
			net_declaration();
			break;
		}
		case _Treg: {
			reg_declaration();
			break;
		}
		case _Tinteger: {
			integer_declaration();
			break;
		}
		case _Treal: {
			real_declaration();
			break;
		}
		case _Ttime: {
			time_declaration();
			break;
		}
		case _Trealtime: {
			realtime_declaration();
			break;
		}
		case _Tevent: {
			event_declaration();
			break;
		}
		case _Tgenvar: {
			genvar_declaration();
			break;
		}
		case _Ttask: {
			task_declaration();
			break;
		}
		case _Tfunction: {
			function_declaration();
			break;
		}
		default: SynErr(221,__FUNCTION__); break;
		}
}

void Parser::local_parameter_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_local_parameter_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tlocalparam,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _TLbrack || la->kind == _Tsigned || la->kind == _TIdent) {
			if (la->kind == _Tsigned) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _TLbrack) {
				range();
			}
		} else if (StartOf(5)) {
			parameter_type();
		} else SynErr(222,__FUNCTION__);
		list_of_param_assignments();
		d_stack.pop(); 
}

void Parser::parameter_override() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_parameter_override, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tdefparam,__FUNCTION__);
		addTerminal(); 
		list_of_defparam_assignments();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::continuous_assign() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_continuous_assign, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tassign,__FUNCTION__);
		addTerminal(); 
		if (peek(1) == _TLpar && ( peek(2) == _Tsupply1 || peek(2) == _Tsupply0 || peek(2) == _Tweak1 || peek(2) == _Tpull0 || peek(2) == _Tstrong0 || peek(2) == _Tpull1 || peek(2) == _Tstrong1 || peek(2) == _Thighz0 || peek(2) == _Tweak0 || peek(2) == _Thighz1 ) ) {
			drive_strength();
		}
		if (la->kind == _THash) {
			delay3();
		}
		list_of_net_assignments();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::gate_instantiation() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_gate_instantiation, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _Tcmos: case _Trcmos: {
			cmos_switchtype();
			if (la->kind == _THash) {
				delay3();
			}
			cmos_switch_instance();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				cmos_switch_instance();
			}
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _Tbufif0: case _Tbufif1: case _Tnotif0: case _Tnotif1: {
			enable_gatetype();
			if (peek(1) == _TLpar && ( peek(2) == _Tsupply1 || peek(2) == _Tsupply0 || peek(2) == _Tweak1 || peek(2) == _Tpull0 || peek(2) == _Tstrong0 || peek(2) == _Tpull1 || peek(2) == _Tstrong1 || peek(2) == _Thighz0 || peek(2) == _Tweak0 || peek(2) == _Thighz1 ) ) {
				drive_strength();
			}
			if (la->kind == _THash) {
				delay3();
			}
			enable_gate_instance();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				enable_gate_instance();
			}
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _Tnmos: case _Tpmos: case _Trnmos: case _Trpmos: {
			mos_switchtype();
			if (la->kind == _THash) {
				delay3();
			}
			mos_switch_instance();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				mos_switch_instance();
			}
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _Tand: case _Tnand: case _Tnor: case _Tor: case _Txnor: case _Txor: {
			n_input_gatetype();
			if (peek(1) == _TLpar && ( peek(2) == _Tsupply1 || peek(2) == _Tsupply0 || peek(2) == _Tweak1 || peek(2) == _Tpull0 || peek(2) == _Tstrong0 || peek(2) == _Tpull1 || peek(2) == _Tstrong1 || peek(2) == _Thighz0 || peek(2) == _Tweak0 || peek(2) == _Thighz1 ) ) {
				drive_strength();
			}
			if (la->kind == _THash) {
				delay2();
			}
			n_input_gate_instance();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				n_input_gate_instance();
			}
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _Tbuf: case _Tnot: {
			n_output_gatetype();
			if (peek(1) == _TLpar && ( peek(2) == _Tsupply1 || peek(2) == _Tsupply0 || peek(2) == _Tweak1 || peek(2) == _Tpull0 || peek(2) == _Tstrong0 || peek(2) == _Tpull1 || peek(2) == _Tstrong1 || peek(2) == _Thighz0 || peek(2) == _Tweak0 || peek(2) == _Thighz1 ) ) {
				drive_strength();
			}
			if (la->kind == _THash) {
				delay2();
			}
			n_output_gate_instance();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				n_output_gate_instance();
			}
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _Trtranif0: case _Trtranif1: case _Ttranif0: case _Ttranif1: {
			pass_en_switchtype();
			if (la->kind == _THash) {
				delay2();
			}
			pass_enable_switch_instance();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				pass_enable_switch_instance();
			}
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _Trtran: case _Ttran: {
			pass_switchtype();
			pass_switch_instance();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				pass_switch_instance();
			}
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _Tpulldown: {
			Get();
			addTerminal(); 
			if (peek(1) == _TLpar && ( peek(2) == _Tsupply1 || peek(2) == _Tsupply0 || peek(2) == _Tweak1 || peek(2) == _Tpull0 || peek(2) == _Tstrong0 || peek(2) == _Tpull1 || peek(2) == _Tstrong1 || peek(2) == _Tweak0 ) ) {
				pulldown_strength();
			}
			pull_gate_instance();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				pull_gate_instance();
			}
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _Tpullup: {
			Get();
			addTerminal(); 
			if (peek(1) == _TLpar && ( peek(2) == _Tsupply1 || peek(2) == _Tsupply0 || peek(2) == _Tweak1 || peek(2) == _Tpull0 || peek(2) == _Tstrong0 || peek(2) == _Tpull1 || peek(2) == _Tstrong1 || peek(2) == _Tweak0 ) ) {
				pullup_strength();
			}
			pull_gate_instance();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				pull_gate_instance();
			}
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		default: SynErr(223,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::module_or_udp_instantiation() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_or_udp_instantiation, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		if (peek(1) == _TLpar && ( peek(2) == _Tsupply1 || peek(2) == _Tsupply0 || peek(2) == _Tweak1 || peek(2) == _Tpull0 || peek(2) == _Tstrong0 || peek(2) == _Tpull1 || peek(2) == _Tstrong1 || peek(2) == _Thighz0 || peek(2) == _Tweak0 || peek(2) == _Thighz1 ) ) {
			drive_strength();
		}
		if (la->kind == _THash) {
			parameter_value_assignment_or_delay2();
		}
		module_or_udp_instance();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			module_or_udp_instance();
		}
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::initial_construct() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_initial_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tinitial,__FUNCTION__);
		addTerminal(); 
		statement();
		d_stack.pop(); 
}

void Parser::always_construct() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_always_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Talways,__FUNCTION__);
		addTerminal(); 
		statement();
		d_stack.pop(); 
}

void Parser::loop_generate_construct() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_loop_generate_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tfor,__FUNCTION__);
		addTerminal(); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		genvar_initialization();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		genvar_expression();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		genvar_iteration();
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _Tbegin) {
			generate_block();
		} else if (StartOf(8)) {
			module_or_generate_item();
		} else SynErr(224,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::conditional_generate_construct() {
		if (la->kind == _Tif) {
			if_generate_construct();
		} else if (la->kind == _Tcase) {
			case_generate_construct();
		} else SynErr(225,__FUNCTION__);
}

void Parser::net_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_net_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(6)) {
			net_type();
		} else if (la->kind == _Ttrireg) {
			Get();
			addTerminal(); 
		} else SynErr(226,__FUNCTION__);
		if (peek(1) == _TLpar && ( peek(2) == _Tsupply1 || peek(2) == _Tsupply0 || peek(2) == _Tweak1 || peek(2) == _Tpull0 || peek(2) == _Tstrong0 || peek(2) == _Tpull1 || peek(2) == _Tstrong1 || peek(2) == _Thighz0 || peek(2) == _Tweak0 || peek(2) == _Thighz1 ) ) {
			drive_strength();
		}
		if (la->kind == _TLpar) {
			charge_strength();
		}
		if (la->kind == _Tscalared || la->kind == _Tvectored) {
			if (la->kind == _Tvectored) {
				Get();
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
			}
		}
		if (la->kind == _Tsigned) {
			Get();
			addTerminal(); 
		}
		if (la->kind == _TLbrack) {
			range();
		}
		if (la->kind == _THash) {
			delay3();
		}
		list_of_net_decl_assignments_or_identifiers();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::reg_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_reg_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Treg,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _Tsigned) {
			Get();
			addTerminal(); 
		}
		if (la->kind == _TLbrack) {
			range();
		}
		list_of_variable_identifiers();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::integer_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_integer_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tinteger,__FUNCTION__);
		addTerminal(); 
		list_of_variable_identifiers();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::real_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_real_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Treal,__FUNCTION__);
		addTerminal(); 
		list_of_real_identifiers();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::time_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_time_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Ttime,__FUNCTION__);
		addTerminal(); 
		list_of_variable_identifiers();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::realtime_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_realtime_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Trealtime,__FUNCTION__);
		addTerminal(); 
		list_of_real_identifiers();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::event_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_event_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tevent,__FUNCTION__);
		addTerminal(); 
		list_of_event_identifiers();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::genvar_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_genvar_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tgenvar,__FUNCTION__);
		addTerminal(); 
		list_of_genvar_identifiers();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::task_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_task_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Ttask,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _Tautomatic) {
			Get();
			addTerminal(); 
		}
		task_identifier();
		if (la->kind == _TLpar) {
			Get();
			addTerminal(); 
			if (la->kind == _Tinout || la->kind == _Tinput || la->kind == _Toutput) {
				task_port_list();
			}
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
		}
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		while (StartOf(9)) {
			task_item_declaration();
		}
		statement_or_null();
		Expect(_Tendtask,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::function_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_function_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tfunction,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _Tautomatic) {
			Get();
			addTerminal(); 
		}
		if (StartOf(10)) {
			function_range_or_type();
		}
		function_identifier();
		if (la->kind == _TLpar) {
			Get();
			addTerminal(); 
			function_port_list();
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
		}
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		while (StartOf(11)) {
			function_item_declaration();
		}
		function_statement();
		Expect(_Tendfunction,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::generate_region() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_generate_region, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tgenerate,__FUNCTION__);
		addTerminal(); 
		while (StartOf(8)) {
			module_or_generate_item();
		}
		Expect(_Tendgenerate,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::specify_block() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specify_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tspecify,__FUNCTION__);
		addTerminal(); 
		while (StartOf(12)) {
			specify_item();
		}
		Expect(_Tendspecify,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::specparam_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specparam_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tspecparam,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _TLbrack) {
			range();
		}
		list_of_specparam_assignments();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::list_of_defparam_assignments() {
		defparam_assignment();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			defparam_assignment();
		}
}

void Parser::config_identifier() {
		identifier();
}

void Parser::design_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_design_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tdesign,__FUNCTION__);
		addTerminal(); 
		while (la->kind == _TIdent) {
			if (la->kind == _TIdent) {
				library_identifier();
				Expect(_TDot,__FUNCTION__);
				addTerminal(); 
			}
			cell_identifier();
		}
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::config_rule_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_config_rule_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _Tdefault) {
			default_clause();
		} else if (la->kind == _Tinstance) {
			inst_clause();
		} else if (la->kind == _Tcell) {
			cell_clause();
		} else SynErr(227,__FUNCTION__);
		if (la->kind == _Tliblist) {
			liblist_clause();
		} else if (la->kind == _Tuse) {
			use_clause();
		} else SynErr(228,__FUNCTION__);
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::cell_identifier() {
		identifier();
}

void Parser::default_clause() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_default_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tdefault,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::inst_clause() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_inst_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tinstance,__FUNCTION__);
		addTerminal(); 
		inst_name();
		d_stack.pop(); 
}

void Parser::cell_clause() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_cell_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tcell,__FUNCTION__);
		addTerminal(); 
		if (peek(1) == _TIdent && peek(2) == _TDot ) {
			library_identifier();
			Expect(_TDot,__FUNCTION__);
			addTerminal(); 
		}
		cell_identifier();
		d_stack.pop(); 
}

void Parser::liblist_clause() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_liblist_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tliblist,__FUNCTION__);
		addTerminal(); 
		while (la->kind == _TIdent) {
			library_identifier();
		}
		d_stack.pop(); 
}

void Parser::use_clause() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_use_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tuse,__FUNCTION__);
		addTerminal(); 
		if (peek(1) == _TIdent && peek(2) == _TDot ) {
			library_identifier();
			Expect(_TDot,__FUNCTION__);
			addTerminal(); 
		}
		cell_identifier();
		if (la->kind == _TColon) {
			Get();
			addTerminal(); 
			Expect(_Tconfig,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::inst_name() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_inst_name, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		topmodule_identifier();
		while (la->kind == _TDot) {
			Get();
			addTerminal(); 
			instance_identifier();
		}
		d_stack.pop(); 
}

void Parser::topmodule_identifier() {
		identifier();
}

void Parser::instance_identifier() {
		identifier();
}

void Parser::range() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_range, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TLbrack,__FUNCTION__);
		addTerminal(); 
		msb_constant_expression();
		Expect(_TColon,__FUNCTION__);
		addTerminal(); 
		lsb_constant_expression();
		Expect(_TRbrack,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::parameter_type() {
		if (la->kind == _Tinteger) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Treal) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Trealtime) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Ttime) {
			Get();
			addTerminal(); 
		} else SynErr(229,__FUNCTION__);
}

void Parser::list_of_param_assignments() {
		param_assignment();
		while (peek(1) == _TComma && peek(2) == _TIdent ) {
			Expect(_TComma,__FUNCTION__);
			addTerminal(); 
			param_assignment();
		}
}

void Parser::list_of_specparam_assignments() {
		specparam_assignment();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			specparam_assignment();
		}
}

void Parser::net_type() {
		switch (la->kind) {
		case _Tsupply0: {
			Get();
			addTerminal(); 
			break;
		}
		case _Tsupply1: {
			Get();
			addTerminal(); 
			break;
		}
		case _Ttri: {
			Get();
			addTerminal(); 
			break;
		}
		case _Ttriand: {
			Get();
			addTerminal(); 
			break;
		}
		case _Ttrior: {
			Get();
			addTerminal(); 
			break;
		}
		case _Ttri0: {
			Get();
			addTerminal(); 
			break;
		}
		case _Ttri1: {
			Get();
			addTerminal(); 
			break;
		}
		case _Tuwire: {
			Get();
			addTerminal(); 
			break;
		}
		case _Twire: {
			Get();
			addTerminal(); 
			break;
		}
		case _Twand: {
			Get();
			addTerminal(); 
			break;
		}
		case _Twor: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(230,__FUNCTION__); break;
		}
}

void Parser::list_of_port_identifiers() {
		port_identifier();
		while (peek(1) == _TComma && peek(2) == _TIdent ) {
			Expect(_TComma,__FUNCTION__);
			addTerminal(); 
			port_identifier();
		}
}

void Parser::list_of_variable_port_identifiers() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_variable_port_identifiers, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		port_identifier();
		if (la->kind == _TEq) {
			Get();
			addTerminal(); 
			constant_expression();
		}
		while (peek(1) == _TComma && peek(2) == _TIdent ) {
			Expect(_TComma,__FUNCTION__);
			addTerminal(); 
			port_identifier();
			if (la->kind == _TEq) {
				Get();
				addTerminal(); 
				constant_expression();
			}
		}
		d_stack.pop(); 
}

void Parser::output_variable_type() {
		if (la->kind == _Tinteger) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Ttime) {
			Get();
			addTerminal(); 
		} else SynErr(231,__FUNCTION__);
}

void Parser::list_of_event_identifiers() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_event_identifiers, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		event_identifier();
		while (la->kind == _TLbrack) {
			dimension();
		}
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			event_identifier();
			while (la->kind == _TLbrack) {
				dimension();
			}
		}
		d_stack.pop(); 
}

void Parser::list_of_variable_identifiers() {
		variable_type();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			variable_type();
		}
}

void Parser::list_of_net_decl_assignments_or_identifiers() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_net_decl_assignments_or_identifiers, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		net_identifier();
		if (la->kind == _TEq || la->kind == _TLbrack) {
			if (la->kind == _TLbrack) {
				dimension();
				while (la->kind == _TLbrack) {
					dimension();
				}
			} else {
				Get();
				addTerminal(); 
				expression();
			}
		}
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			net_identifier();
			if (la->kind == _TEq || la->kind == _TLbrack) {
				if (la->kind == _TLbrack) {
					dimension();
					while (la->kind == _TLbrack) {
						dimension();
					}
				} else {
					Get();
					addTerminal(); 
					expression();
				}
			}
		}
		d_stack.pop(); 
}

void Parser::net_identifier() {
		identifier();
}

void Parser::dimension() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dimension, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TLbrack,__FUNCTION__);
		addTerminal(); 
		dimension_constant_expression();
		Expect(_TColon,__FUNCTION__);
		addTerminal(); 
		dimension_constant_expression();
		Expect(_TRbrack,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(13)) {
			unary_operator();
		}
		primary();
		while (StartOf(14)) {
			expression_nlr();
		}
		d_stack.pop(); 
}

void Parser::drive_strength() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_drive_strength, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		if (StartOf(15)) {
			strength0();
		} else if (StartOf(16)) {
			strength1();
		} else if (la->kind == _Thighz0) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Thighz1) {
			Get();
			addTerminal(); 
		} else SynErr(232,__FUNCTION__);
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		if (StartOf(16)) {
			strength1();
		} else if (StartOf(15)) {
			strength0();
		} else if (la->kind == _Thighz1) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Thighz0) {
			Get();
			addTerminal(); 
		} else SynErr(233,__FUNCTION__);
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::charge_strength() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_charge_strength, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _Tsmall) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Tmedium) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Tlarge) {
			Get();
			addTerminal(); 
		} else SynErr(234,__FUNCTION__);
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::delay3() {
		delay();
}

void Parser::list_of_real_identifiers() {
		real_type();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			real_type();
		}
}

void Parser::real_type() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_real_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		real_identifier();
		if (la->kind == _TLbrack || la->kind == _TComma || la->kind == _TSemi) {
			while (la->kind == _TLbrack) {
				dimension();
			}
		} else if (la->kind == _TEq) {
			Get();
			addTerminal(); 
			constant_expression();
		} else SynErr(235,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::real_identifier() {
		identifier();
}

void Parser::constant_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_constant_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(13)) {
			unary_operator();
		}
		constant_primary();
		while (StartOf(14)) {
			constant_expression_nlr();
		}
		d_stack.pop(); 
}

void Parser::variable_type() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_variable_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		variable_identifier();
		if (la->kind == _TLbrack || la->kind == _TComma || la->kind == _TSemi) {
			while (la->kind == _TLbrack) {
				dimension();
			}
		} else if (la->kind == _TEq) {
			Get();
			addTerminal(); 
			constant_expression();
		} else SynErr(236,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::variable_identifier() {
		identifier();
}

void Parser::strength0() {
		if (la->kind == _Tsupply0) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Tstrong0) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Tpull0) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Tweak0) {
			Get();
			addTerminal(); 
		} else SynErr(237,__FUNCTION__);
}

void Parser::strength1() {
		if (la->kind == _Tsupply1) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Tstrong1) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Tpull1) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Tweak1) {
			Get();
			addTerminal(); 
		} else SynErr(238,__FUNCTION__);
}

void Parser::delay() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_delay, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_THash,__FUNCTION__);
		addTerminal(); 
		if (StartOf(17)) {
			delay_value();
		}
		if (la->kind == _TLpar) {
			Get();
			addTerminal(); 
			mintypmax_expression();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				mintypmax_expression();
			}
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
			while (StartOf(14)) {
				expression_nlr();
			}
		}
		d_stack.pop(); 
}

void Parser::delay_value() {
		if (StartOf(18)) {
			unsigned_or_real_number();
		} else if (la->kind == _TIdent) {
			identifier();
		} else SynErr(239,__FUNCTION__);
}

void Parser::mintypmax_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_mintypmax_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		if (la->kind == _TColon) {
			Get();
			addTerminal(); 
			expression();
			Expect(_TColon,__FUNCTION__);
			addTerminal(); 
			expression();
		}
		d_stack.pop(); 
}

void Parser::expression_nlr() {
		if (StartOf(19)) {
			binary_operator();
			expression();
		} else if (la->kind == _TQmark) {
			Get();
			addTerminal(); 
			expression();
			Expect(_TColon,__FUNCTION__);
			addTerminal(); 
			expression();
		} else SynErr(240,__FUNCTION__);
}

void Parser::delay2() {
		delay();
}

void Parser::unsigned_or_real_number() {
		number();
}

void Parser::defparam_assignment() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_defparam_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		hierarchical_parameter_identifier();
		Expect(_TEq,__FUNCTION__);
		addTerminal(); 
		constant_mintypmax_expression();
		d_stack.pop(); 
}

void Parser::event_identifier() {
		identifier();
}

void Parser::param_assignment() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_param_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		parameter_identifier();
		Expect(_TEq,__FUNCTION__);
		addTerminal(); 
		constant_mintypmax_expression();
		d_stack.pop(); 
}

void Parser::specparam_assignment() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specparam_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TIdent) {
			specparam_identifier();
			Expect(_TEq,__FUNCTION__);
			addTerminal(); 
			constant_mintypmax_expression();
		} else if (la->kind == _TPathPulse) {
			pulse_control_specparam();
		} else SynErr(241,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::hierarchical_parameter_identifier() {
		hierarchical_identifier();
}

void Parser::constant_mintypmax_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_constant_mintypmax_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		constant_expression();
		if (la->kind == _TColon) {
			Get();
			addTerminal(); 
			constant_expression();
			Expect(_TColon,__FUNCTION__);
			addTerminal(); 
			constant_expression();
		}
		d_stack.pop(); 
}

void Parser::parameter_identifier() {
		identifier();
}

void Parser::specparam_identifier() {
		identifier();
}

void Parser::pulse_control_specparam() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pulse_control_specparam, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TPathPulse,__FUNCTION__);
		addTerminal(); 
		Expect(_TEq,__FUNCTION__);
		addTerminal(); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		reject_limit_value();
		if (la->kind == _TComma) {
			Get();
			addTerminal(); 
			error_limit_value();
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::reject_limit_value() {
		limit_value();
}

void Parser::error_limit_value() {
		limit_value();
}

void Parser::limit_value() {
		constant_mintypmax_expression();
}

void Parser::dimension_constant_expression() {
		constant_expression();
}

void Parser::msb_constant_expression() {
		constant_expression();
}

void Parser::lsb_constant_expression() {
		constant_expression();
}

void Parser::function_range_or_type() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_function_range_or_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TLbrack || la->kind == _Tsigned || la->kind == _TIdent) {
			if (la->kind == _Tsigned) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _TLbrack) {
				range();
			}
		} else if (la->kind == _Tinteger) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Treal) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Trealtime) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Ttime) {
			Get();
			addTerminal(); 
		} else SynErr(242,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::function_identifier() {
		identifier();
}

void Parser::function_port_list() {
		tf_input_declaration();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			tf_input_declaration();
		}
}

void Parser::function_item_declaration() {
		if (StartOf(20)) {
			block_item_declaration();
		} else if (la->kind == _Tinput) {
			tf_input_declaration();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
		} else SynErr(243,__FUNCTION__);
}

void Parser::function_statement() {
		statement();
}

void Parser::block_item_declaration() {
		switch (la->kind) {
		case _Treg: {
			block_reg_declaration();
			break;
		}
		case _Tinteger: {
			block_integer_declaration();
			break;
		}
		case _Ttime: {
			block_time_declaration();
			break;
		}
		case _Treal: {
			block_real_declaration();
			break;
		}
		case _Trealtime: {
			block_realtime_declaration();
			break;
		}
		case _Tevent: {
			event_declaration();
			break;
		}
		case _Tlocalparam: {
			local_parameter_declaration();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _Tparameter: {
			parameter_declaration();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		default: SynErr(244,__FUNCTION__); break;
		}
}

void Parser::tf_input_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_tf_input_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tinput,__FUNCTION__);
		addTerminal(); 
		if (StartOf(21)) {
			if (la->kind == _Treg) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _Tsigned) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _TLbrack) {
				range();
			}
		} else if (StartOf(5)) {
			task_port_type();
		} else SynErr(245,__FUNCTION__);
		list_of_port_identifiers();
		d_stack.pop(); 
}

void Parser::task_identifier() {
		identifier();
}

void Parser::task_port_list() {
		task_port_item();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			task_port_item();
		}
}

void Parser::task_item_declaration() {
		if (StartOf(20)) {
			block_item_declaration();
		} else if (la->kind == _Tinput) {
			tf_input_declaration();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _Toutput) {
			tf_output_declaration();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _Tinout) {
			tf_inout_declaration();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
		} else SynErr(246,__FUNCTION__);
}

void Parser::statement_or_null() {
		if (StartOf(22)) {
			statement();
		}
}

void Parser::tf_output_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_tf_output_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Toutput,__FUNCTION__);
		addTerminal(); 
		if (StartOf(21)) {
			if (la->kind == _Treg) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _Tsigned) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _TLbrack) {
				range();
			}
		} else if (StartOf(5)) {
			task_port_type();
		} else SynErr(247,__FUNCTION__);
		list_of_port_identifiers();
		d_stack.pop(); 
}

void Parser::tf_inout_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_tf_inout_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tinout,__FUNCTION__);
		addTerminal(); 
		if (StartOf(21)) {
			if (la->kind == _Treg) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _Tsigned) {
				Get();
				addTerminal(); 
			}
			if (la->kind == _TLbrack) {
				range();
			}
		} else if (StartOf(5)) {
			task_port_type();
		} else SynErr(248,__FUNCTION__);
		list_of_port_identifiers();
		d_stack.pop(); 
}

void Parser::task_port_item() {
		if (la->kind == _Tinput) {
			tf_input_declaration();
		} else if (la->kind == _Toutput) {
			tf_output_declaration();
		} else if (la->kind == _Tinout) {
			tf_inout_declaration();
		} else SynErr(249,__FUNCTION__);
}

void Parser::task_port_type() {
		if (la->kind == _Tinteger) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Treal) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Trealtime) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Ttime) {
			Get();
			addTerminal(); 
		} else SynErr(250,__FUNCTION__);
}

void Parser::block_reg_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_reg_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Treg,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _Tsigned) {
			Get();
			addTerminal(); 
		}
		if (la->kind == _TLbrack) {
			range();
		}
		list_of_block_variable_identifiers();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::block_integer_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_integer_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tinteger,__FUNCTION__);
		addTerminal(); 
		list_of_block_variable_identifiers();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::block_time_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_time_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Ttime,__FUNCTION__);
		addTerminal(); 
		list_of_block_variable_identifiers();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::block_real_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_real_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Treal,__FUNCTION__);
		addTerminal(); 
		list_of_block_real_identifiers();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::block_realtime_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_realtime_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Trealtime,__FUNCTION__);
		addTerminal(); 
		list_of_block_real_identifiers();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::list_of_block_variable_identifiers() {
		block_variable_type();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			block_variable_type();
		}
}

void Parser::list_of_block_real_identifiers() {
		block_real_type();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			block_real_type();
		}
}

void Parser::block_variable_type() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_variable_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		variable_identifier();
		while (la->kind == _TLbrack) {
			dimension();
		}
		d_stack.pop(); 
}

void Parser::block_real_type() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_real_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		real_identifier();
		while (la->kind == _TLbrack) {
			dimension();
		}
		d_stack.pop(); 
}

void Parser::cmos_switchtype() {
		if (la->kind == _Tcmos) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Trcmos) {
			Get();
			addTerminal(); 
		} else SynErr(251,__FUNCTION__);
}

void Parser::cmos_switch_instance() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_cmos_switch_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TIdent) {
			name_of_gate_instance();
		}
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		output_terminal();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		input_terminal();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		ncontrol_terminal();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		pcontrol_terminal();
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::enable_gatetype() {
		if (la->kind == _Tbufif0) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Tbufif1) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Tnotif0) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Tnotif1) {
			Get();
			addTerminal(); 
		} else SynErr(252,__FUNCTION__);
}

void Parser::enable_gate_instance() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_enable_gate_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TIdent) {
			name_of_gate_instance();
		}
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		output_terminal();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		input_terminal();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		enable_terminal();
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::mos_switchtype() {
		if (la->kind == _Tnmos) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Tpmos) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Trnmos) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Trpmos) {
			Get();
			addTerminal(); 
		} else SynErr(253,__FUNCTION__);
}

void Parser::mos_switch_instance() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_mos_switch_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TIdent) {
			name_of_gate_instance();
		}
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		output_terminal();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		input_terminal();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		enable_terminal();
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::n_input_gatetype() {
		switch (la->kind) {
		case _Tand: {
			Get();
			addTerminal(); 
			break;
		}
		case _Tnand: {
			Get();
			addTerminal(); 
			break;
		}
		case _Tor: {
			Get();
			addTerminal(); 
			break;
		}
		case _Tnor: {
			Get();
			addTerminal(); 
			break;
		}
		case _Txor: {
			Get();
			addTerminal(); 
			break;
		}
		case _Txnor: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(254,__FUNCTION__); break;
		}
}

void Parser::n_input_gate_instance() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_n_input_gate_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TIdent) {
			name_of_gate_instance();
		}
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		output_terminal();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		input_terminal();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			input_terminal();
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::n_output_gatetype() {
		if (la->kind == _Tbuf) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Tnot) {
			Get();
			addTerminal(); 
		} else SynErr(255,__FUNCTION__);
}

void Parser::n_output_gate_instance() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_n_output_gate_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TIdent) {
			name_of_gate_instance();
		}
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		input_or_output_terminal();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			input_or_output_terminal();
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::pass_en_switchtype() {
		if (la->kind == _Ttranif0) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Ttranif1) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Trtranif1) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Trtranif0) {
			Get();
			addTerminal(); 
		} else SynErr(256,__FUNCTION__);
}

void Parser::pass_enable_switch_instance() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pass_enable_switch_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TIdent) {
			name_of_gate_instance();
		}
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		inout_terminal();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		inout_terminal();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		enable_terminal();
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::pass_switchtype() {
		if (la->kind == _Ttran) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Trtran) {
			Get();
			addTerminal(); 
		} else SynErr(257,__FUNCTION__);
}

void Parser::pass_switch_instance() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pass_switch_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TIdent) {
			name_of_gate_instance();
		}
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		inout_terminal();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		inout_terminal();
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::pulldown_strength() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pulldown_strength, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		if (StartOf(15)) {
			strength0();
		} else if (StartOf(16)) {
			strength1();
		} else SynErr(258,__FUNCTION__);
		if (la->kind == _TComma) {
			Get();
			addTerminal(); 
			if (StartOf(16)) {
				strength1();
			} else if (StartOf(15)) {
				strength0();
			} else SynErr(259,__FUNCTION__);
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::pull_gate_instance() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pull_gate_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TIdent) {
			name_of_gate_instance();
		}
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		output_terminal();
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::pullup_strength() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pullup_strength, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		if (StartOf(15)) {
			strength0();
		} else if (StartOf(16)) {
			strength1();
		} else SynErr(260,__FUNCTION__);
		if (la->kind == _TComma) {
			Get();
			addTerminal(); 
			if (StartOf(16)) {
				strength1();
			} else if (StartOf(15)) {
				strength0();
			} else SynErr(261,__FUNCTION__);
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::name_of_gate_instance() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_name_of_gate_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		gate_instance_identifier();
		if (la->kind == _TLbrack) {
			range();
		}
		d_stack.pop(); 
}

void Parser::output_terminal() {
		net_lvalue();
}

void Parser::input_terminal() {
		expression();
}

void Parser::ncontrol_terminal() {
		expression();
}

void Parser::pcontrol_terminal() {
		expression();
}

void Parser::enable_terminal() {
		expression();
}

void Parser::input_or_output_terminal() {
		expression_2();
}

void Parser::expression_2() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_expression_2, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(13)) {
			unary_operator();
		}
		primary_2();
		while (StartOf(14)) {
			expression_nlr();
		}
		d_stack.pop(); 
}

void Parser::inout_terminal() {
		net_lvalue();
}

void Parser::gate_instance_identifier() {
		identifier();
}

void Parser::net_lvalue() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_net_lvalue, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TIdent) {
			hierarchical_identifier_range_const();
		} else if (la->kind == _TLbrace) {
			Get();
			addTerminal(); 
			net_lvalue();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				net_lvalue();
			}
			Expect(_TRbrace,__FUNCTION__);
			addTerminal(); 
		} else SynErr(262,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::named_parameter_assignment() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_named_parameter_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TDot,__FUNCTION__);
		addTerminal(); 
		parameter_identifier();
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		if (StartOf(23)) {
			mintypmax_expression();
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::list_of_genvar_identifiers() {
		genvar_identifier();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			genvar_identifier();
		}
}

void Parser::genvar_identifier() {
		identifier();
}

void Parser::genvar_initialization() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_genvar_initialization, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		genvar_identifier();
		Expect(_TEq,__FUNCTION__);
		addTerminal(); 
		constant_expression();
		d_stack.pop(); 
}

void Parser::genvar_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_genvar_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(13)) {
			unary_operator();
		}
		genvar_primary();
		genvar_expression_nlr();
		d_stack.pop(); 
}

void Parser::genvar_iteration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_genvar_iteration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		genvar_identifier();
		Expect(_TEq,__FUNCTION__);
		addTerminal(); 
		genvar_expression();
		d_stack.pop(); 
}

void Parser::generate_block() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_generate_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tbegin,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _TColon) {
			Get();
			addTerminal(); 
			generate_block_identifier();
		}
		while (StartOf(8)) {
			module_or_generate_item();
		}
		Expect(_Tend,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::genvar_primary() {
		constant_primary();
}

void Parser::genvar_expression_nlr() {
		if (StartOf(14)) {
			if (StartOf(19)) {
				binary_operator();
				genvar_expression();
				genvar_expression_nlr();
			} else {
				Get();
				addTerminal(); 
				genvar_expression();
				Expect(_TColon,__FUNCTION__);
				addTerminal(); 
				genvar_expression();
				genvar_expression_nlr();
			}
		}
}

void Parser::constant_primary() {
		if (StartOf(18)) {
			number();
		} else if (la->kind == _TString) {
			string();
		} else if (la->kind == _TLpar) {
			Get();
			addTerminal(); 
			constant_mintypmax_expression();
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _TIdent || la->kind == _TSysName) {
			if (la->kind == _TIdent) {
				identifier();
			} else {
				system_name();
			}
			if (la->kind == _TLpar || la->kind == _TLbrack) {
				if (la->kind == _TLbrack) {
					Get();
					addTerminal(); 
					constant_range_expression();
					Expect(_TRbrack,__FUNCTION__);
					addTerminal(); 
				} else {
					Get();
					addTerminal(); 
					constant_expression();
					while (la->kind == _TComma) {
						Get();
						addTerminal(); 
						constant_expression();
					}
					Expect(_TRpar,__FUNCTION__);
					addTerminal(); 
				}
			}
		} else if (la->kind == _TLbrace) {
			Get();
			addTerminal(); 
			constant_expression();
			if (la->kind == _TLbrace || la->kind == _TComma) {
				if (la->kind == _TComma) {
					Get();
					addTerminal(); 
					constant_expression();
					while (la->kind == _TComma) {
						Get();
						addTerminal(); 
						constant_expression();
					}
				} else {
					Get();
					addTerminal(); 
					constant_expression();
					while (la->kind == _TComma) {
						Get();
						addTerminal(); 
						constant_expression();
					}
					Expect(_TRbrace,__FUNCTION__);
					addTerminal(); 
				}
			}
			Expect(_TRbrace,__FUNCTION__);
			addTerminal(); 
		} else SynErr(263,__FUNCTION__);
}

void Parser::if_generate_construct() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_if_generate_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tif,__FUNCTION__);
		addTerminal(); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		constant_expression();
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		generate_block_or_null();
		if (la->kind == _Telse) {
			Get();
			addTerminal(); 
			generate_block_or_null();
		}
		d_stack.pop(); 
}

void Parser::case_generate_construct() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_case_generate_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tcase,__FUNCTION__);
		addTerminal(); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		constant_expression();
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		case_generate_item();
		while (StartOf(24)) {
			case_generate_item();
		}
		Expect(_Tendcase,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::generate_block_or_null() {
		if (la->kind == _Tbegin) {
			generate_block();
		} else if (StartOf(8)) {
			module_or_generate_item();
		} else if (la->kind == _TSemi) {
			Get();
			addTerminal(); 
		} else SynErr(264,__FUNCTION__);
}

void Parser::case_generate_item() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_case_generate_item, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(23)) {
			constant_expression();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				constant_expression();
			}
			Expect(_TColon,__FUNCTION__);
			addTerminal(); 
			generate_block_or_null();
		} else if (la->kind == _Tdefault) {
			Get();
			addTerminal(); 
			if (la->kind == _TColon) {
				Get();
				addTerminal(); 
			}
			generate_block_or_null();
		} else SynErr(265,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::generate_block_identifier() {
		identifier();
}

void Parser::udp_identifier() {
		identifier();
}

void Parser::udp_port_list() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_port_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		output_port_identifier();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		input_port_identifier();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			input_port_identifier();
		}
		d_stack.pop(); 
}

void Parser::udp_declaration_port_list() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_declaration_port_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		udp_output_declaration();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		udp_input_declaration();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			udp_input_declaration();
		}
		d_stack.pop(); 
}

void Parser::udp_port_declaration() {
		if (la->kind == _Toutput) {
			udp_output_declaration();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _Tinput) {
			udp_input_declaration();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _Treg) {
			udp_reg_declaration();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
		} else SynErr(266,__FUNCTION__);
}

void Parser::udp_body() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_body, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _Tinitial) {
			udp_initial_statement();
		}
		Expect(_Ttable,__FUNCTION__);
		addTerminal(); 
		sequential_or_combinatorial_entry();
		while (StartOf(25)) {
			sequential_or_combinatorial_entry();
		}
		Expect(_Tendtable,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::output_port_identifier() {
		identifier();
}

void Parser::input_port_identifier() {
		identifier();
}

void Parser::udp_output_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_output_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Toutput,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _Treg) {
			Get();
			addTerminal(); 
		}
		port_identifier();
		if (la->kind == _TEq) {
			Get();
			addTerminal(); 
			constant_expression();
		}
		d_stack.pop(); 
}

void Parser::udp_input_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_input_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tinput,__FUNCTION__);
		addTerminal(); 
		list_of_port_identifiers();
		d_stack.pop(); 
}

void Parser::udp_reg_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_reg_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Treg,__FUNCTION__);
		addTerminal(); 
		variable_identifier();
		d_stack.pop(); 
}

void Parser::udp_initial_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_initial_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tinitial,__FUNCTION__);
		addTerminal(); 
		output_port_identifier();
		Expect(_TEq,__FUNCTION__);
		addTerminal(); 
		init_val();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::sequential_or_combinatorial_entry() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_sequential_or_combinatorial_entry, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		while (StartOf(26)) {
			level_or_edge_symbol();
		}
		if (la->kind == _TLpar) {
			Get();
			addTerminal(); 
			level_symbol();
			if (StartOf(27)) {
				level_symbol();
			}
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
		}
		while (StartOf(26)) {
			level_or_edge_symbol();
		}
		Expect(_TColon,__FUNCTION__);
		addTerminal(); 
		if (StartOf(27)) {
			level_symbol();
		} else if (la->kind == _TMinus) {
			Get();
			addTerminal(); 
		} else SynErr(267,__FUNCTION__);
		if (la->kind == _TColon) {
			Get();
			addTerminal(); 
			if (StartOf(27)) {
				level_symbol();
			} else if (la->kind == _TMinus) {
				Get();
				addTerminal(); 
			} else SynErr(268,__FUNCTION__);
		}
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::init_val() {
		number();
}

void Parser::level_or_edge_symbol() {
		if (StartOf(18)) {
			number();
		} else if (la->kind == _TIdent) {
			identifier();
		} else if (la->kind == _TQmark) {
			Get();
			addTerminal(); 
		} else if (la->kind == _TStar) {
			Get();
			addTerminal(); 
		} else SynErr(269,__FUNCTION__);
}

void Parser::level_symbol() {
		if (StartOf(18)) {
			number();
		} else if (la->kind == _TIdent) {
			identifier();
		} else if (la->kind == _TQmark) {
			Get();
			addTerminal(); 
		} else SynErr(270,__FUNCTION__);
}

void Parser::number() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_number, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TRealnum) {
			real_number();
		} else if (la->kind == _TNatural) {
			natural_number();
			if (la->kind == _TBasedInt || la->kind == _TBaseFormat) {
				if (la->kind == _TBasedInt) {
					based_number();
				} else {
					base_format();
					if (la->kind == _TBaseValue) {
						base_value();
					} else if (la->kind == _TNatural) {
						natural_number();
					} else SynErr(271,__FUNCTION__);
				}
			}
		} else if (la->kind == _TSizedBased) {
			sizedbased_number();
		} else if (la->kind == _TBasedInt) {
			based_number();
		} else if (la->kind == _TBaseFormat) {
			base_format();
			if (la->kind == _TBaseValue) {
				base_value();
			} else if (la->kind == _TNatural) {
				natural_number();
			} else SynErr(272,__FUNCTION__);
		} else SynErr(273,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::edge_descriptor() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_edge_descriptor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TIdent) {
			identifier();
		} else if (StartOf(18)) {
			number();
		} else SynErr(274,__FUNCTION__);
		if (StartOf(17)) {
			if (la->kind == _TIdent) {
				identifier();
			} else {
				number();
			}
		}
		d_stack.pop(); 
}

void Parser::scalar_constant() {
		number();
}

void Parser::list_of_net_assignments() {
		net_assignment();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			net_assignment();
		}
}

void Parser::net_assignment() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_net_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		net_lvalue();
		Expect(_TEq,__FUNCTION__);
		addTerminal(); 
		expression();
		d_stack.pop(); 
}

void Parser::statement() {
		switch (la->kind) {
		case _TLbrace: case _TIdent: {
			blocking_or_nonblocking_assignment_or_task_enable();
			break;
		}
		case _Tcase: case _Tcasex: case _Tcasez: {
			case_statement();
			break;
		}
		case _Tif: {
			conditional_statement();
			break;
		}
		case _Tdisable: {
			disable_statement();
			break;
		}
		case _TMinusGt: {
			event_trigger();
			break;
		}
		case _Tfor: case _Tforever: case _Trepeat: case _Twhile: {
			loop_statement();
			break;
		}
		case _Tfork: {
			par_block();
			break;
		}
		case _Tassign: case _Tdeassign: case _Tforce: case _Trelease: {
			procedural_continuous_assignments();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _THash: case _TAt: {
			procedural_timing_control_statement();
			break;
		}
		case _Tbegin: {
			seq_block();
			break;
		}
		case _TSysName: {
			system_task_enable();
			break;
		}
		case _Twait: {
			wait_statement();
			break;
		}
		case _TSemi: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(275,__FUNCTION__); break;
		}
}

void Parser::procedural_continuous_assignments() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_procedural_continuous_assignments, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _Tassign) {
			Get();
			addTerminal(); 
			variable_assignment();
		} else if (la->kind == _Tdeassign) {
			Get();
			addTerminal(); 
			variable_lvalue();
		} else if (la->kind == _Tforce) {
			Get();
			addTerminal(); 
			variable_or_net_lvalue();
			Expect(_TEq,__FUNCTION__);
			addTerminal(); 
			expression();
		} else if (la->kind == _Trelease) {
			Get();
			addTerminal(); 
			variable_or_net_lvalue();
		} else SynErr(276,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::variable_assignment() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_variable_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		variable_lvalue();
		Expect(_TEq,__FUNCTION__);
		addTerminal(); 
		expression();
		d_stack.pop(); 
}

void Parser::variable_lvalue() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_variable_lvalue, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TIdent) {
			hierarchical_identifier_range();
		} else if (la->kind == _TLbrace) {
			Get();
			addTerminal(); 
			variable_lvalue();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				variable_lvalue();
			}
			Expect(_TRbrace,__FUNCTION__);
			addTerminal(); 
		} else SynErr(277,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::variable_or_net_lvalue() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_variable_or_net_lvalue, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TIdent) {
			hierarchical_identifier_range();
		} else if (la->kind == _TLbrace) {
			Get();
			addTerminal(); 
			variable_or_net_lvalue();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				variable_or_net_lvalue();
			}
			Expect(_TRbrace,__FUNCTION__);
			addTerminal(); 
		} else SynErr(278,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::par_block() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_par_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tfork,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _TColon) {
			Get();
			addTerminal(); 
			block_identifier();
			while (StartOf(20)) {
				block_item_declaration();
			}
		}
		while (StartOf(22)) {
			statement();
		}
		Expect(_Tjoin,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::block_identifier() {
		identifier();
}

void Parser::seq_block() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_seq_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tbegin,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _TColon) {
			Get();
			addTerminal(); 
			block_identifier();
			while (StartOf(20)) {
				block_item_declaration();
			}
		}
		while (StartOf(22)) {
			statement();
		}
		Expect(_Tend,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::blocking_or_nonblocking_assignment_or_task_enable() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_blocking_or_nonblocking_assignment_or_task_enable, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		variable_lvalue();
		if (la->kind == _TLpar) {
			Get();
			addTerminal(); 
			expression();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				expression();
			}
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
		}
		if (la->kind == _TEq || la->kind == _TLeq) {
			if (la->kind == _TLeq) {
				Get();
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
			}
			if (la->kind == _THash || la->kind == _TAt || la->kind == _Trepeat) {
				delay_or_event_control();
			}
			if (StartOf(23)) {
				expression();
			}
		}
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::delay_or_event_control() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_delay_or_event_control, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _THash) {
			delay_control();
		} else if (la->kind == _TAt) {
			event_control();
		} else if (la->kind == _Trepeat) {
			Get();
			addTerminal(); 
			Expect(_TLpar,__FUNCTION__);
			addTerminal(); 
			expression();
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
			event_control();
		} else SynErr(279,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::case_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_case_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _Tcase) {
			Get();
			addTerminal(); 
			Expect(_TLpar,__FUNCTION__);
			addTerminal(); 
			expression();
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
			case_item();
			while (StartOf(24)) {
				case_item();
			}
			Expect(_Tendcase,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _Tcasez) {
			Get();
			addTerminal(); 
			Expect(_TLpar,__FUNCTION__);
			addTerminal(); 
			expression();
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
			case_item();
			while (StartOf(24)) {
				case_item();
			}
			Expect(_Tendcase,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _Tcasex) {
			Get();
			addTerminal(); 
			Expect(_TLpar,__FUNCTION__);
			addTerminal(); 
			expression();
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
			case_item();
			while (StartOf(24)) {
				case_item();
			}
			Expect(_Tendcase,__FUNCTION__);
			addTerminal(); 
		} else SynErr(280,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::conditional_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_conditional_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tif,__FUNCTION__);
		addTerminal(); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		expression();
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		statement_or_null();
		if (la->kind == _Telse) {
			Get();
			addTerminal(); 
			statement_or_null();
		}
		d_stack.pop(); 
}

void Parser::disable_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_disable_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tdisable,__FUNCTION__);
		addTerminal(); 
		hierarchical_task_or_block_identifier();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::event_trigger() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_event_trigger, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TMinusGt,__FUNCTION__);
		addTerminal(); 
		hierarchical_identifier_range();
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::loop_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_loop_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _Tforever) {
			Get();
			addTerminal(); 
			statement();
		} else if (la->kind == _Trepeat) {
			Get();
			addTerminal(); 
			Expect(_TLpar,__FUNCTION__);
			addTerminal(); 
			expression();
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
			statement();
		} else if (la->kind == _Twhile) {
			Get();
			addTerminal(); 
			Expect(_TLpar,__FUNCTION__);
			addTerminal(); 
			expression();
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
			statement();
		} else if (la->kind == _Tfor) {
			Get();
			addTerminal(); 
			Expect(_TLpar,__FUNCTION__);
			addTerminal(); 
			variable_assignment();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
			expression();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
			variable_assignment();
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
			statement();
		} else SynErr(281,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::procedural_timing_control_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_procedural_timing_control_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		procedural_timing_control();
		statement_or_null();
		d_stack.pop(); 
}

void Parser::system_task_enable() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_system_task_enable, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		system_task_identifier();
		if (la->kind == _TLpar) {
			Get();
			addTerminal(); 
			if (StartOf(23)) {
				expression();
			}
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				if (StartOf(23)) {
					expression();
				}
			}
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
		}
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::wait_statement() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_wait_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Twait,__FUNCTION__);
		addTerminal(); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		expression();
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		statement_or_null();
		d_stack.pop(); 
}

void Parser::delay_control() {
		delay();
}

void Parser::event_control() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_event_control, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TAt,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _TLpar) {
			Get();
			addTerminal(); 
			if (StartOf(28)) {
				event_expression();
			} else if (la->kind == _TStar) {
				Get();
				addTerminal(); 
			} else SynErr(282,__FUNCTION__);
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _TStar) {
			Get();
			addTerminal(); 
		} else if (la->kind == _TIdent) {
			hierarchical_event_identifier();
		} else SynErr(283,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::hierarchical_task_or_block_identifier() {
		hierarchical_identifier();
}

void Parser::hierarchical_identifier() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_hierarchical_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		if (la->kind == _TLbrack) {
			Get();
			addTerminal(); 
			constant_expression();
			Expect(_TRbrack,__FUNCTION__);
			addTerminal(); 
		}
		while (la->kind == _TDot) {
			Get();
			addTerminal(); 
			identifier();
			if (la->kind == _TLbrack) {
				Get();
				addTerminal(); 
				constant_expression();
				Expect(_TRbrack,__FUNCTION__);
				addTerminal(); 
			}
		}
		d_stack.pop(); 
}

void Parser::event_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_event_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(23)) {
			expression();
			event_expression_nlr();
		} else if (la->kind == _Tposedge) {
			Get();
			addTerminal(); 
			expression();
			event_expression_nlr();
		} else if (la->kind == _Tnegedge) {
			Get();
			addTerminal(); 
			expression();
			event_expression_nlr();
		} else SynErr(284,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::hierarchical_event_identifier() {
		hierarchical_identifier();
}

void Parser::hierarchical_identifier_range() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_hierarchical_identifier_range, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		while (la->kind == _TLbrack || la->kind == _TDot) {
			if (la->kind == _TDot) {
				Get();
				addTerminal(); 
				identifier();
				if (la->kind == _TLbrack) {
					Get();
					addTerminal(); 
					range_expression();
					Expect(_TRbrack,__FUNCTION__);
					addTerminal(); 
				}
			} else {
				Get();
				addTerminal(); 
				range_expression();
				Expect(_TRbrack,__FUNCTION__);
				addTerminal(); 
			}
		}
		d_stack.pop(); 
}

void Parser::event_expression_nlr() {
		if (la->kind == _TComma || la->kind == _Tor) {
			if (la->kind == _Tor) {
				Get();
				addTerminal(); 
				event_expression();
				event_expression_nlr();
			} else {
				Get();
				addTerminal(); 
				event_expression();
				event_expression_nlr();
			}
		}
}

void Parser::procedural_timing_control() {
		if (la->kind == _THash) {
			delay_control();
		} else if (la->kind == _TAt) {
			event_control();
		} else SynErr(285,__FUNCTION__);
}

void Parser::case_item() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_case_item, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(23)) {
			expression();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				expression();
			}
			Expect(_TColon,__FUNCTION__);
			addTerminal(); 
			statement_or_null();
		} else if (la->kind == _Tdefault) {
			Get();
			addTerminal(); 
			if (la->kind == _TColon) {
				Get();
				addTerminal(); 
			}
			statement_or_null();
		} else SynErr(286,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::system_task_identifier() {
		system_name();
}

void Parser::specify_item() {
		if (la->kind == _Tspecparam) {
			specparam_declaration();
		} else if (la->kind == _Tpulsestyle_onevent || la->kind == _Tpulsestyle_ondetect) {
			pulsestyle_declaration();
		} else if (la->kind == _Tnoshowcancelled || la->kind == _Tshowcancelled) {
			showcancelled_declaration();
		} else if (la->kind == _TLpar || la->kind == _Tif || la->kind == _Tifnone) {
			path_declaration();
		} else if (StartOf(29)) {
			system_timing_check();
		} else SynErr(287,__FUNCTION__);
}

void Parser::pulsestyle_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pulsestyle_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _Tpulsestyle_onevent) {
			Get();
			addTerminal(); 
			list_of_path_outputs();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _Tpulsestyle_ondetect) {
			Get();
			addTerminal(); 
			list_of_path_outputs();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
		} else SynErr(288,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::showcancelled_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_showcancelled_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _Tshowcancelled) {
			Get();
			addTerminal(); 
			list_of_path_outputs();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _Tnoshowcancelled) {
			Get();
			addTerminal(); 
			list_of_path_outputs();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
		} else SynErr(289,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::path_declaration() {
		if (la->kind == _TLpar) {
			simple_or_edge_sensitive_path_declaration();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _Tif || la->kind == _Tifnone) {
			state_dependent_path_declaration();
			Expect(_TSemi,__FUNCTION__);
			addTerminal(); 
		} else SynErr(290,__FUNCTION__);
}

void Parser::system_timing_check() {
		switch (la->kind) {
		case _TSetup: {
			dlr_setup_timing_check();
			break;
		}
		case _THold: {
			dlr_hold_timing_check();
			break;
		}
		case _TSetupHold: {
			dlr_setuphold_timing_check();
			break;
		}
		case _TRecovery: {
			dlr_recovery_timing_check();
			break;
		}
		case _TRemoval: {
			dlr_removal_timing_check();
			break;
		}
		case _TRecrem: {
			dlr_recrem_timing_check();
			break;
		}
		case _TSkew: {
			dlr_skew_timing_check();
			break;
		}
		case _TTimeSkew: {
			dlr_timeskew_timing_check();
			break;
		}
		case _TFullSkew: {
			dlr_fullskew_timing_check();
			break;
		}
		case _TPeriod: {
			dlr_period_timing_check();
			break;
		}
		case _TWidth: {
			dlr_width_timing_check();
			break;
		}
		case _TNoChange: {
			dlr_nochange_timing_check();
			break;
		}
		default: SynErr(291,__FUNCTION__); break;
		}
}

void Parser::list_of_path_outputs() {
		specify_output_terminal_descriptor();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			specify_output_terminal_descriptor();
		}
}

void Parser::simple_or_edge_sensitive_path_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_simple_or_edge_sensitive_path_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _Tnegedge || la->kind == _Tposedge) {
			edge_identifier();
		}
		list_of_path_inputs();
		if (la->kind == _TPlus || la->kind == _TMinus) {
			polarity_operator();
		}
		if (la->kind == _TEqGt) {
			Get();
			addTerminal(); 
			if (la->kind == _TIdent) {
				specify_output_terminal_descriptor();
			}
		} else if (la->kind == _TStarGt) {
			Get();
			addTerminal(); 
			if (la->kind == _TIdent) {
				list_of_path_outputs();
			}
		} else SynErr(292,__FUNCTION__);
		if (la->kind == _TLpar) {
			Get();
			addTerminal(); 
			list_of_path_outputs();
			if (la->kind == _TColon) {
				Get();
				addTerminal(); 
			} else if (la->kind == _TPlusColon) {
				Get();
				addTerminal(); 
			} else if (la->kind == _TMinusColon) {
				Get();
				addTerminal(); 
			} else SynErr(293,__FUNCTION__);
			data_source_expression();
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		Expect(_TEq,__FUNCTION__);
		addTerminal(); 
		path_delay_value();
		d_stack.pop(); 
}

void Parser::state_dependent_path_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_state_dependent_path_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _Tif) {
			Get();
			addTerminal(); 
			Expect(_TLpar,__FUNCTION__);
			addTerminal(); 
			module_path_expression();
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
			simple_or_edge_sensitive_path_description();
			Expect(_TEq,__FUNCTION__);
			addTerminal(); 
			path_delay_value();
		} else if (la->kind == _Tifnone) {
			Get();
			addTerminal(); 
			simple_path_declaration();
		} else SynErr(294,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::parallel_or_full_path_description() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_parallel_or_full_path_description, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		list_of_path_inputs();
		if (la->kind == _TPlus || la->kind == _TMinus) {
			polarity_operator();
		}
		if (la->kind == _TEqGt) {
			Get();
			addTerminal(); 
			specify_output_terminal_descriptor();
		} else if (la->kind == _TStarGt) {
			Get();
			addTerminal(); 
			list_of_path_outputs();
		} else SynErr(295,__FUNCTION__);
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::list_of_path_inputs() {
		specify_input_terminal_descriptor();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			specify_input_terminal_descriptor();
		}
}

void Parser::polarity_operator() {
		if (la->kind == _TPlus) {
			Get();
			addTerminal(); 
		} else if (la->kind == _TMinus) {
			Get();
			addTerminal(); 
		} else SynErr(296,__FUNCTION__);
}

void Parser::specify_output_terminal_descriptor() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specify_output_terminal_descriptor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		output_identifier();
		if (la->kind == _TLbrack) {
			Get();
			addTerminal(); 
			constant_range_expression();
			Expect(_TRbrack,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::simple_path_declaration() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_simple_path_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		parallel_or_full_path_description();
		Expect(_TEq,__FUNCTION__);
		addTerminal(); 
		path_delay_value();
		d_stack.pop(); 
}

void Parser::path_delay_value() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_path_delay_value, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TLpar) {
			Get();
			addTerminal(); 
		}
		list_of_path_delay_expressions();
		if (la->kind == _TRpar) {
			Get();
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::specify_input_terminal_descriptor() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specify_input_terminal_descriptor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		input_identifier();
		if (la->kind == _TLbrack) {
			Get();
			addTerminal(); 
			constant_range_expression();
			Expect(_TRbrack,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::input_identifier() {
		input_or_inout_port_identifier();
}

void Parser::output_identifier() {
		output_or_inout_port_identifier();
}

void Parser::input_or_inout_port_identifier() {
		identifier();
}

void Parser::output_or_inout_port_identifier() {
		identifier();
}

void Parser::list_of_path_delay_expressions() {
		path_delay_expression();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			path_delay_expression();
		}
}

void Parser::path_delay_expression() {
		constant_mintypmax_expression();
}

void Parser::edge_identifier() {
		if (la->kind == _Tposedge) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Tnegedge) {
			Get();
			addTerminal(); 
		} else SynErr(297,__FUNCTION__);
}

void Parser::data_source_expression() {
		expression();
}

void Parser::simple_or_edge_sensitive_path_description() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_simple_or_edge_sensitive_path_description, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _Tnegedge || la->kind == _Tposedge) {
			edge_identifier();
		}
		list_of_path_inputs();
		if (la->kind == _TPlus || la->kind == _TMinus) {
			polarity_operator();
		}
		if (la->kind == _TEqGt) {
			Get();
			addTerminal(); 
			if (la->kind == _TIdent) {
				specify_output_terminal_descriptor();
			}
		} else if (la->kind == _TStarGt) {
			Get();
			addTerminal(); 
			if (la->kind == _TIdent) {
				list_of_path_outputs();
			}
		} else SynErr(298,__FUNCTION__);
		if (la->kind == _TLpar) {
			Get();
			addTerminal(); 
			list_of_path_outputs();
			if (la->kind == _TColon) {
				Get();
				addTerminal(); 
			} else if (la->kind == _TPlusColon) {
				Get();
				addTerminal(); 
			} else if (la->kind == _TMinusColon) {
				Get();
				addTerminal(); 
			} else SynErr(299,__FUNCTION__);
			data_source_expression();
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::module_path_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_path_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(30)) {
			unary_module_path_operator();
		}
		module_path_primary();
		module_path_expression_nlr();
		d_stack.pop(); 
}

void Parser::dlr_setup_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_setup_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TSetup,__FUNCTION__);
		addTerminal(); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		data_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		reference_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _TComma) {
			Get();
			addTerminal(); 
			if (la->kind == _TIdent) {
				notifier();
			}
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_hold_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_hold_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_THold,__FUNCTION__);
		addTerminal(); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		reference_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		data_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _TComma) {
			Get();
			addTerminal(); 
			if (la->kind == _TIdent) {
				notifier();
			}
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_setuphold_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_setuphold_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TSetupHold,__FUNCTION__);
		addTerminal(); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		reference_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		data_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _TComma) {
			Get();
			addTerminal(); 
			if (la->kind == _TIdent) {
				notifier();
			}
			if (la->kind == _TComma) {
				Get();
				addTerminal(); 
				if (StartOf(23)) {
					stamptime_condition();
				}
				if (la->kind == _TComma) {
					Get();
					addTerminal(); 
					if (StartOf(23)) {
						checktime_condition();
					}
					if (la->kind == _TComma) {
						Get();
						addTerminal(); 
						if (la->kind == _TIdent) {
							delayed_reference();
						}
						if (la->kind == _TComma) {
							Get();
							addTerminal(); 
							if (la->kind == _TIdent) {
								delayed_data();
							}
						}
					}
				}
			}
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_recovery_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_recovery_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TRecovery,__FUNCTION__);
		addTerminal(); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		reference_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		data_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _TComma) {
			Get();
			addTerminal(); 
			if (la->kind == _TIdent) {
				notifier();
			}
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_removal_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_removal_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TRemoval,__FUNCTION__);
		addTerminal(); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		reference_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		data_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _TComma) {
			Get();
			addTerminal(); 
			if (la->kind == _TIdent) {
				notifier();
			}
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_recrem_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_recrem_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TRecrem,__FUNCTION__);
		addTerminal(); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		reference_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		data_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _TComma) {
			Get();
			addTerminal(); 
			if (la->kind == _TIdent) {
				notifier();
			}
			if (la->kind == _TComma) {
				Get();
				addTerminal(); 
				if (StartOf(23)) {
					stamptime_condition();
				}
				if (la->kind == _TComma) {
					Get();
					addTerminal(); 
					if (StartOf(23)) {
						checktime_condition();
					}
					if (la->kind == _TComma) {
						Get();
						addTerminal(); 
						if (la->kind == _TIdent) {
							delayed_reference();
						}
						if (la->kind == _TComma) {
							Get();
							addTerminal(); 
							if (la->kind == _TIdent) {
								delayed_data();
							}
						}
					}
				}
			}
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_skew_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_skew_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TSkew,__FUNCTION__);
		addTerminal(); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		reference_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		data_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _TComma) {
			Get();
			addTerminal(); 
			if (la->kind == _TIdent) {
				notifier();
			}
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_timeskew_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_timeskew_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TTimeSkew,__FUNCTION__);
		addTerminal(); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		reference_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		data_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _TComma) {
			Get();
			addTerminal(); 
			if (la->kind == _TIdent) {
				notifier();
			}
			if (la->kind == _TComma) {
				Get();
				addTerminal(); 
				if (StartOf(23)) {
					event_based_flag();
				}
				if (la->kind == _TComma) {
					Get();
					addTerminal(); 
					if (StartOf(23)) {
						remain_active_flag();
					}
				}
			}
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_fullskew_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_fullskew_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TFullSkew,__FUNCTION__);
		addTerminal(); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		reference_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		data_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _TComma) {
			Get();
			addTerminal(); 
			if (la->kind == _TIdent) {
				notifier();
			}
			if (la->kind == _TComma) {
				Get();
				addTerminal(); 
				if (StartOf(23)) {
					event_based_flag();
				}
				if (la->kind == _TComma) {
					Get();
					addTerminal(); 
					if (StartOf(23)) {
						remain_active_flag();
					}
				}
			}
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_period_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_period_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TPeriod,__FUNCTION__);
		addTerminal(); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		controlled_reference_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _TComma) {
			Get();
			addTerminal(); 
			if (la->kind == _TIdent) {
				notifier();
			}
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_width_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_width_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TWidth,__FUNCTION__);
		addTerminal(); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		controlled_reference_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		timing_check_limit();
		if (la->kind == _TComma) {
			Get();
			addTerminal(); 
			threshold();
			if (la->kind == _TComma) {
				Get();
				addTerminal(); 
				notifier();
			}
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::dlr_nochange_timing_check() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_nochange_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_TNoChange,__FUNCTION__);
		addTerminal(); 
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		reference_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		data_event();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		start_edge_offset();
		Expect(_TComma,__FUNCTION__);
		addTerminal(); 
		end_edge_offset();
		if (la->kind == _TComma) {
			Get();
			addTerminal(); 
			if (la->kind == _TIdent) {
				notifier();
			}
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		Expect(_TSemi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::data_event() {
		timing_check_event();
}

void Parser::reference_event() {
		timing_check_event();
}

void Parser::timing_check_limit() {
		expression();
}

void Parser::notifier() {
		variable_identifier();
}

void Parser::stamptime_condition() {
		mintypmax_expression();
}

void Parser::checktime_condition() {
		mintypmax_expression();
}

void Parser::delayed_reference() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_delayed_reference, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		terminal_identifier();
		if (la->kind == _TLbrack) {
			Get();
			addTerminal(); 
			constant_mintypmax_expression();
			Expect(_TRbrack,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::delayed_data() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_delayed_data, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		terminal_identifier();
		if (la->kind == _TLbrack) {
			Get();
			addTerminal(); 
			constant_mintypmax_expression();
			Expect(_TRbrack,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::event_based_flag() {
		constant_expression();
}

void Parser::remain_active_flag() {
		constant_expression();
}

void Parser::controlled_reference_event() {
		controlled_timing_check_event();
}

void Parser::threshold() {
		constant_expression();
}

void Parser::start_edge_offset() {
		mintypmax_expression();
}

void Parser::end_edge_offset() {
		mintypmax_expression();
}

void Parser::controlled_timing_check_event() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_controlled_timing_check_event, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		timing_check_event_control();
		specify_terminal_descriptor();
		if (la->kind == _T3Amp) {
			Get();
			addTerminal(); 
			timing_check_condition();
		}
		d_stack.pop(); 
}

void Parser::timing_check_event() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_timing_check_event, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _Tedge || la->kind == _Tnegedge || la->kind == _Tposedge) {
			timing_check_event_control();
		}
		specify_terminal_descriptor();
		if (la->kind == _T3Amp) {
			Get();
			addTerminal(); 
			timing_check_condition();
		}
		d_stack.pop(); 
}

void Parser::terminal_identifier() {
		identifier();
}

void Parser::timing_check_event_control() {
		if (la->kind == _Tposedge) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Tnegedge) {
			Get();
			addTerminal(); 
		} else if (la->kind == _Tedge) {
			edge_control_specifier();
		} else SynErr(300,__FUNCTION__);
}

void Parser::specify_terminal_descriptor() {
		specify_input_or_output_terminal_descriptor();
}

void Parser::timing_check_condition() {
		scalar_timing_check_condition();
}

void Parser::edge_control_specifier() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_edge_control_specifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_Tedge,__FUNCTION__);
		addTerminal(); 
		Expect(_TLbrack,__FUNCTION__);
		addTerminal(); 
		edge_descriptor();
		while (la->kind == _TComma) {
			Get();
			addTerminal(); 
			edge_descriptor();
		}
		Expect(_TRbrack,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::specify_input_or_output_terminal_descriptor() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specify_input_or_output_terminal_descriptor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		if (la->kind == _TLbrack) {
			Get();
			addTerminal(); 
			constant_range_expression();
			Expect(_TRbrack,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::scalar_timing_check_condition() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_scalar_timing_check_condition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		if (StartOf(31)) {
			if (la->kind == _T2Eq) {
				Get();
				addTerminal(); 
				scalar_constant();
			} else if (la->kind == _T3Eq) {
				Get();
				addTerminal(); 
				scalar_constant();
			} else if (la->kind == _TBangEq) {
				Get();
				addTerminal(); 
				scalar_constant();
			} else {
				Get();
				addTerminal(); 
				scalar_constant();
			}
		}
		d_stack.pop(); 
}

void Parser::constant_expression_nlr() {
		if (StartOf(19)) {
			binary_operator();
			constant_expression();
		} else if (la->kind == _TQmark) {
			Get();
			addTerminal(); 
			constant_expression();
			Expect(_TColon,__FUNCTION__);
			addTerminal(); 
			constant_expression();
		} else SynErr(301,__FUNCTION__);
}

void Parser::width_constant_expression() {
		constant_expression();
}

void Parser::primary() {
		if (la->kind == _TIdent || la->kind == _TSysName) {
			if (la->kind == _TIdent) {
				hierarchical_identifier_range();
			} else {
				system_function_identifier();
			}
			if (la->kind == _TLpar) {
				Get();
				addTerminal(); 
				expression();
				while (la->kind == _TComma) {
					Get();
					addTerminal(); 
					expression();
				}
				Expect(_TRpar,__FUNCTION__);
				addTerminal(); 
			}
		} else if (StartOf(18)) {
			number();
		} else if (la->kind == _TString) {
			string();
		} else if (la->kind == _TLpar) {
			Get();
			addTerminal(); 
			mintypmax_expression();
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _TLbrace) {
			Get();
			addTerminal(); 
			expression();
			if (la->kind == _TLbrace || la->kind == _TComma) {
				if (la->kind == _TComma) {
					Get();
					addTerminal(); 
					expression();
					while (la->kind == _TComma) {
						Get();
						addTerminal(); 
						expression();
					}
				} else {
					Get();
					addTerminal(); 
					expression();
					while (la->kind == _TComma) {
						Get();
						addTerminal(); 
						expression();
					}
					Expect(_TRbrace,__FUNCTION__);
					addTerminal(); 
				}
			}
			Expect(_TRbrace,__FUNCTION__);
			addTerminal(); 
		} else SynErr(302,__FUNCTION__);
}

void Parser::module_path_primary() {
		if (StartOf(18)) {
			number();
		} else if (la->kind == _TIdent || la->kind == _TSysName) {
			if (la->kind == _TIdent) {
				hierarchical_identifier();
			} else {
				system_function_identifier();
			}
			if (la->kind == _TLpar) {
				Get();
				addTerminal(); 
				expression();
				while (la->kind == _TComma) {
					Get();
					addTerminal(); 
					expression();
				}
				Expect(_TRpar,__FUNCTION__);
				addTerminal(); 
			}
		} else if (la->kind == _TLpar) {
			Get();
			addTerminal(); 
			module_path_mintypmax_expression();
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _TLbrace) {
			Get();
			addTerminal(); 
			module_path_expression();
			if (la->kind == _TLbrace || la->kind == _TComma) {
				if (la->kind == _TComma) {
					Get();
					addTerminal(); 
					module_path_expression();
					while (la->kind == _TComma) {
						Get();
						addTerminal(); 
						module_path_expression();
					}
				} else {
					Get();
					addTerminal(); 
					module_path_expression();
					while (la->kind == _TComma) {
						Get();
						addTerminal(); 
						module_path_expression();
					}
					Expect(_TRbrace,__FUNCTION__);
					addTerminal(); 
				}
			}
			Expect(_TRbrace,__FUNCTION__);
			addTerminal(); 
		} else SynErr(303,__FUNCTION__);
}

void Parser::module_path_expression_nlr() {
		if (StartOf(32)) {
			if (StartOf(33)) {
				binary_module_path_operator();
				module_path_expression();
				module_path_expression_nlr();
			} else {
				Get();
				addTerminal(); 
				module_path_expression();
				Expect(_TColon,__FUNCTION__);
				addTerminal(); 
				module_path_expression();
				module_path_expression_nlr();
			}
		}
}

void Parser::module_path_mintypmax_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_path_mintypmax_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		module_path_expression();
		if (la->kind == _TColon) {
			Get();
			addTerminal(); 
			module_path_expression();
			Expect(_TColon,__FUNCTION__);
			addTerminal(); 
			module_path_expression();
		}
		d_stack.pop(); 
}

void Parser::range_expression() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_range_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		if (la->kind == _TColon || la->kind == _TPlusColon || la->kind == _TMinusColon) {
			if (la->kind == _TColon) {
				Get();
				addTerminal(); 
				lsb_constant_expression();
			} else if (la->kind == _TPlusColon) {
				Get();
				addTerminal(); 
				width_constant_expression();
			} else {
				Get();
				addTerminal(); 
				width_constant_expression();
			}
		}
		d_stack.pop(); 
}

void Parser::system_function_identifier() {
		system_name();
}

void Parser::hierarchical_identifier_range_const() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_hierarchical_identifier_range_const, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		while (la->kind == _TLbrack || la->kind == _TDot) {
			if (la->kind == _TDot) {
				Get();
				addTerminal(); 
				identifier();
				if (la->kind == _TLbrack) {
					Get();
					addTerminal(); 
					constant_range_expression();
					Expect(_TRbrack,__FUNCTION__);
					addTerminal(); 
				}
			} else {
				Get();
				addTerminal(); 
				constant_range_expression();
				Expect(_TRbrack,__FUNCTION__);
				addTerminal(); 
			}
		}
		d_stack.pop(); 
}

void Parser::parameter_value_assignment_or_delay2() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_parameter_value_assignment_or_delay2, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_THash,__FUNCTION__);
		addTerminal(); 
		if (StartOf(17)) {
			delay_value();
		}
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		if (StartOf(23)) {
			mintypmax_expression();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				mintypmax_expression();
			}
		} else if (la->kind == _TDot) {
			named_parameter_assignment();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				named_parameter_assignment();
			}
		} else SynErr(304,__FUNCTION__);
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::module_or_udp_instance() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_or_udp_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TIdent) {
			identifier();
		}
		if (la->kind == _TLbrack) {
			range();
		}
		Expect(_TLpar,__FUNCTION__);
		addTerminal(); 
		if (StartOf(34)) {
			port_connection_or_output_terminal();
			while (la->kind == _TComma) {
				Get();
				addTerminal(); 
				port_connection_or_output_terminal();
			}
		}
		Expect(_TRpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::port_connection_or_output_terminal() {
		Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_port_connection_or_output_terminal, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _TDot) {
			Get();
			addTerminal(); 
			port_identifier();
			Expect(_TLpar,__FUNCTION__);
			addTerminal(); 
			if (StartOf(23)) {
				expression();
			}
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
		} else if (StartOf(35)) {
			if (StartOf(23)) {
				expression_2();
			}
		} else SynErr(305,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::primary_2() {
		if (la->kind == _TIdent || la->kind == _TSysName) {
			if (la->kind == _TIdent) {
				hierarchical_identifier_range();
			} else {
				system_function_identifier();
			}
			if (la->kind == _TLpar || la->kind == _TLbrace) {
				if (la->kind == _TLpar) {
					Get();
					addTerminal(); 
					expression();
					while (la->kind == _TComma) {
						Get();
						addTerminal(); 
						expression();
					}
					Expect(_TRpar,__FUNCTION__);
					addTerminal(); 
				} else {
					Get();
					addTerminal(); 
					net_lvalue();
					while (la->kind == _TComma) {
						Get();
						addTerminal(); 
						net_lvalue();
					}
					Expect(_TRbrace,__FUNCTION__);
					addTerminal(); 
				}
			}
		} else if (StartOf(18)) {
			number();
		} else if (la->kind == _TString) {
			string();
		} else if (la->kind == _TLpar) {
			Get();
			addTerminal(); 
			mintypmax_expression();
			Expect(_TRpar,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _TLbrace) {
			Get();
			addTerminal(); 
			expression();
			if (la->kind == _TLbrace || la->kind == _TComma) {
				if (la->kind == _TComma) {
					Get();
					addTerminal(); 
					expression();
					while (la->kind == _TComma) {
						Get();
						addTerminal(); 
						expression();
					}
				} else {
					Get();
					addTerminal(); 
					expression();
					while (la->kind == _TComma) {
						Get();
						addTerminal(); 
						expression();
					}
					Expect(_TRbrace,__FUNCTION__);
					addTerminal(); 
				}
			}
			Expect(_TRbrace,__FUNCTION__);
			addTerminal(); 
		} else SynErr(306,__FUNCTION__);
}




// If the user declared a method Init and a mehtod Destroy they should
// be called in the contructur and the destructor respctively.
//
// The following templates are used to recognize if the user declared
// the methods Init and Destroy.

template<typename T>
struct ParserInitExistsRecognizer {
	template<typename U, void (U::*)() = &U::Init>
	struct ExistsIfInitIsDefinedMarker{};

	struct InitIsMissingType {
		char dummy1;
	};
	
	struct InitExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static InitIsMissingType is_here(...);

	// exist only if ExistsIfInitIsDefinedMarker is defined
	template<typename U>
	static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

	enum { InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType)) };
};

template<typename T>
struct ParserDestroyExistsRecognizer {
	template<typename U, void (U::*)() = &U::Destroy>
	struct ExistsIfDestroyIsDefinedMarker{};

	struct DestroyIsMissingType {
		char dummy1;
	};
	
	struct DestroyExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static DestroyIsMissingType is_here(...);

	// exist only if ExistsIfDestroyIsDefinedMarker is defined
	template<typename U>
	static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

	enum { DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType)) };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller {
	static void CallInit(T *t) {
		// nothing to do
	}
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true> {
	static void CallInit(T *t) {
		t->Init();
	}
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller {
	static void CallDestroy(T *t) {
		// nothing to do
	}
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true> {
	static void CallDestroy(T *t) {
		t->Destroy();
	}
};

void Parser::Parse() {
	d_cur = Vl::Token();
	d_next = Vl::Token();
	Get();
	Verilog05();
	Expect(0,__FUNCTION__);
}

Parser::Parser(Vl::PpLexer *scanner, Vl::Errors* err) {
	maxT = 205;

	ParserInitCaller<Parser>::CallInit(this);
	la = &d_dummy;
	minErrDist = 2;
	errDist = minErrDist;
	this->scanner = scanner;
	errors = err;
}

bool Parser::StartOf(int s) {
	const bool T = true;
	const bool x = false;

	static bool set[36][207] = {
		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,T, x,T,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,x,x,T, T,T,T,x, x,x,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,T,T, T,x,x,T, x,x,x,T, T,T,x,T, x,x,x,x, T,x,x,x, T,x,T,T, x,T,T,T, T,T,T,T, x,x,x,x, T,T,x,x, T,T,T,T, x,x,T,T, T,T,T,x, x,x,x,T, T,x,x,T, T,x,T,T, T,T,T,T, T,T,T,T, T,x,x,T, x,x,T,x, x,x,T,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,x,x,T, T,T,T,x, x,x,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,T,T, T,x,x,T, x,x,x,T, x,x,x,T, x,x,x,x, T,x,x,x, T,x,T,T, x,T,T,T, T,x,T,T, x,x,x,x, T,T,x,x, T,T,T,T, x,x,T,T, T,T,T,x, x,x,x,T, T,x,x,T, T,x,T,T, T,T,T,T, T,T,T,T, T,x,x,T, x,x,T,x, x,x,T,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,T, T,T,T,T, x,x,x,T, x,x,T,x, x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, T,x,x,x, x,x,x,T, T,T,T,T, x,x,x,T, x,x,T,x, x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,x,x,T, T,T,T,x, x,x,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,T,x, T,x,x,T, x,x,x,T, x,x,x,T, x,x,x,x, T,x,x,x, T,x,T,T, x,T,T,T, T,x,x,T, x,x,x,x, T,T,x,x, T,T,T,T, x,x,T,T, T,T,T,x, x,x,x,x, x,x,x,T, T,x,T,T, T,T,T,T, T,T,T,T, T,x,x,T, x,x,T,x, x,x,T,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,T,T,T, T,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,T,T,T, x,x,T,T, T,T,T,T, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,T,T,x, T,T,x,x, x,T,T,T, T,T,x,T, T,T,T,x, T,T,T,T, T,T,T,T, T,T,T,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,T,T,T, T,T,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,T, T,T,x,x, x,x,x},
		{x,T,T,x, T,T,x,x, x,T,T,T, T,T,x,T, T,T,T,x, T,T,T,T, T,T,T,T, T,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,T,x,x, x,x,T,x, x,x,x,x, x,x,T,x, x,x,x,x, T,x,T,x, x,x,T,T, T,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,x,x,x, x,x,x},
		{x,T,T,T, x,x,T,T, T,T,T,T, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,T, x,T,T,T, T,T,x,x, x,x,x},
		{x,T,T,T, x,x,T,T, T,T,T,T, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,T, x,T,T,T, T,T,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,T,T,T, T,T,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,T,T,T, T,T,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,T,T,T, T,T,x,x, x,x,x},
		{x,T,T,T, x,x,T,T, T,T,T,T, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,T, x,T,T,T, T,T,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,T,T,T, T,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,T, x,x,T,T, T,T,T,T, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, T,x,x,x, x,T,T,T, x,x,x,T, x,T,T,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, T,x,x,x, x,T,T,T, x,x,x,T, x,T,T,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,T,T,T, x,x,T,T, T,T,T,T, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,T,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,T, x,T,T,T, T,T,x,x, x,x,x},
		{x,T,T,T, x,x,T,T, T,T,T,T, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,T,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,T, x,T,T,T, T,T,x,x, x,x,x}
	};



	return set[s][la->kind];
}

Parser::~Parser() {
	ParserDestroyCaller<Parser>::CallDestroy(this);
}

Errors::Errors() {
	count = 0;
}

void Errors::SynErr(const QString& sourcePath, int line, int col, int n, Vl::Errors* err, const char* ctx, const QString& str ) {
	QString s;
	QString ctxStr;
	if( ctx )
		ctxStr = QString( " in %1" ).arg(ctx);
    if( n == 0 )
        s = QString("EOF expected%1").arg(ctxStr);
    else if( n < Vl::Tok_maxSystemName )
        s = QString("'%2' expected%1").arg(ctxStr).arg(Vl::tokenToString(n));
    else if( n <= Vl::Tok_Eof )
        s = QString("%2 expected%1").arg(ctxStr).arg(Vl::tokenToString(n));
    else
	switch (n) {
			case 0: s = coco_string_create(L"EOF expected"); break;
			case 1: s = coco_string_create(L"TPlus expected"); break;
			case 2: s = coco_string_create(L"TMinus expected"); break;
			case 3: s = coco_string_create(L"TBang expected"); break;
			case 4: s = coco_string_create(L"TBangEq expected"); break;
			case 5: s = coco_string_create(L"TBang2Eq expected"); break;
			case 6: s = coco_string_create(L"TTilde expected"); break;
			case 7: s = coco_string_create(L"TTildeBar expected"); break;
			case 8: s = coco_string_create(L"TTildeAmp expected"); break;
			case 9: s = coco_string_create(L"TTildeHat expected"); break;
			case 10: s = coco_string_create(L"THat expected"); break;
			case 11: s = coco_string_create(L"THatTilde expected"); break;
			case 12: s = coco_string_create(L"TSlash expected"); break;
			case 13: s = coco_string_create(L"TPercent expected"); break;
			case 14: s = coco_string_create(L"TEq expected"); break;
			case 15: s = coco_string_create(L"T2Eq expected"); break;
			case 16: s = coco_string_create(L"T3Eq expected"); break;
			case 17: s = coco_string_create(L"TAmp expected"); break;
			case 18: s = coco_string_create(L"T2Amp expected"); break;
			case 19: s = coco_string_create(L"T3Amp expected"); break;
			case 20: s = coco_string_create(L"TBar expected"); break;
			case 21: s = coco_string_create(L"T2Bar expected"); break;
			case 22: s = coco_string_create(L"TStar expected"); break;
			case 23: s = coco_string_create(L"T2Star expected"); break;
			case 24: s = coco_string_create(L"TLt expected"); break;
			case 25: s = coco_string_create(L"TLeq expected"); break;
			case 26: s = coco_string_create(L"T2Lt expected"); break;
			case 27: s = coco_string_create(L"T3Lt expected"); break;
			case 28: s = coco_string_create(L"TGt expected"); break;
			case 29: s = coco_string_create(L"TGeq expected"); break;
			case 30: s = coco_string_create(L"T2Gt expected"); break;
			case 31: s = coco_string_create(L"T3Gt expected"); break;
			case 32: s = coco_string_create(L"THash expected"); break;
			case 33: s = coco_string_create(L"TAt expected"); break;
			case 34: s = coco_string_create(L"TQmark expected"); break;
			case 35: s = coco_string_create(L"TEqGt expected"); break;
			case 36: s = coco_string_create(L"TStarGt expected"); break;
			case 37: s = coco_string_create(L"TMinusGt expected"); break;
			case 38: s = coco_string_create(L"TLpar expected"); break;
			case 39: s = coco_string_create(L"TRpar expected"); break;
			case 40: s = coco_string_create(L"TLbrack expected"); break;
			case 41: s = coco_string_create(L"TRbrack expected"); break;
			case 42: s = coco_string_create(L"TLbrace expected"); break;
			case 43: s = coco_string_create(L"TRbrace expected"); break;
			case 44: s = coco_string_create(L"TLatt expected"); break;
			case 45: s = coco_string_create(L"TRatt expected"); break;
			case 46: s = coco_string_create(L"TLcmt expected"); break;
			case 47: s = coco_string_create(L"TRcmt expected"); break;
			case 48: s = coco_string_create(L"TComma expected"); break;
			case 49: s = coco_string_create(L"TDot expected"); break;
			case 50: s = coco_string_create(L"TSemi expected"); break;
			case 51: s = coco_string_create(L"TColon expected"); break;
			case 52: s = coco_string_create(L"TPlusColon expected"); break;
			case 53: s = coco_string_create(L"TMinusColon expected"); break;
			case 54: s = coco_string_create(L"Talways expected"); break;
			case 55: s = coco_string_create(L"Tand expected"); break;
			case 56: s = coco_string_create(L"Tassign expected"); break;
			case 57: s = coco_string_create(L"Tautomatic expected"); break;
			case 58: s = coco_string_create(L"Tbegin expected"); break;
			case 59: s = coco_string_create(L"Tbuf expected"); break;
			case 60: s = coco_string_create(L"Tbufif0 expected"); break;
			case 61: s = coco_string_create(L"Tbufif1 expected"); break;
			case 62: s = coco_string_create(L"Tcase expected"); break;
			case 63: s = coco_string_create(L"Tcasex expected"); break;
			case 64: s = coco_string_create(L"Tcasez expected"); break;
			case 65: s = coco_string_create(L"Tcell expected"); break;
			case 66: s = coco_string_create(L"Tcmos expected"); break;
			case 67: s = coco_string_create(L"Tconfig expected"); break;
			case 68: s = coco_string_create(L"Tdeassign expected"); break;
			case 69: s = coco_string_create(L"Tdefault expected"); break;
			case 70: s = coco_string_create(L"Tdefparam expected"); break;
			case 71: s = coco_string_create(L"Tdesign expected"); break;
			case 72: s = coco_string_create(L"Tdisable expected"); break;
			case 73: s = coco_string_create(L"Tedge expected"); break;
			case 74: s = coco_string_create(L"Telse expected"); break;
			case 75: s = coco_string_create(L"Tend expected"); break;
			case 76: s = coco_string_create(L"Tendcase expected"); break;
			case 77: s = coco_string_create(L"Tendconfig expected"); break;
			case 78: s = coco_string_create(L"Tendfunction expected"); break;
			case 79: s = coco_string_create(L"Tendgenerate expected"); break;
			case 80: s = coco_string_create(L"Tendmodule expected"); break;
			case 81: s = coco_string_create(L"Tendprimitive expected"); break;
			case 82: s = coco_string_create(L"Tendspecify expected"); break;
			case 83: s = coco_string_create(L"Tendtable expected"); break;
			case 84: s = coco_string_create(L"Tendtask expected"); break;
			case 85: s = coco_string_create(L"Tevent expected"); break;
			case 86: s = coco_string_create(L"Tfor expected"); break;
			case 87: s = coco_string_create(L"Tforce expected"); break;
			case 88: s = coco_string_create(L"Tforever expected"); break;
			case 89: s = coco_string_create(L"Tfork expected"); break;
			case 90: s = coco_string_create(L"Tfunction expected"); break;
			case 91: s = coco_string_create(L"Tgenerate expected"); break;
			case 92: s = coco_string_create(L"Tgenvar expected"); break;
			case 93: s = coco_string_create(L"Thighz0 expected"); break;
			case 94: s = coco_string_create(L"Thighz1 expected"); break;
			case 95: s = coco_string_create(L"Tif expected"); break;
			case 96: s = coco_string_create(L"Tifnone expected"); break;
			case 97: s = coco_string_create(L"Tincdir expected"); break;
			case 98: s = coco_string_create(L"Tinclude expected"); break;
			case 99: s = coco_string_create(L"Tinitial expected"); break;
			case 100: s = coco_string_create(L"Tinout expected"); break;
			case 101: s = coco_string_create(L"Tinput expected"); break;
			case 102: s = coco_string_create(L"Tinstance expected"); break;
			case 103: s = coco_string_create(L"Tinteger expected"); break;
			case 104: s = coco_string_create(L"Tjoin expected"); break;
			case 105: s = coco_string_create(L"Tlarge expected"); break;
			case 106: s = coco_string_create(L"Tliblist expected"); break;
			case 107: s = coco_string_create(L"Tlibrary expected"); break;
			case 108: s = coco_string_create(L"Tlocalparam expected"); break;
			case 109: s = coco_string_create(L"Tmacromodule expected"); break;
			case 110: s = coco_string_create(L"Tmedium expected"); break;
			case 111: s = coco_string_create(L"Tmodule expected"); break;
			case 112: s = coco_string_create(L"Tnand expected"); break;
			case 113: s = coco_string_create(L"Tnegedge expected"); break;
			case 114: s = coco_string_create(L"Tnmos expected"); break;
			case 115: s = coco_string_create(L"Tnor expected"); break;
			case 116: s = coco_string_create(L"Tnoshowcancelled expected"); break;
			case 117: s = coco_string_create(L"Tnot expected"); break;
			case 118: s = coco_string_create(L"Tnotif0 expected"); break;
			case 119: s = coco_string_create(L"Tnotif1 expected"); break;
			case 120: s = coco_string_create(L"Tor expected"); break;
			case 121: s = coco_string_create(L"Toutput expected"); break;
			case 122: s = coco_string_create(L"Tparameter expected"); break;
			case 123: s = coco_string_create(L"Tpmos expected"); break;
			case 124: s = coco_string_create(L"Tposedge expected"); break;
			case 125: s = coco_string_create(L"Tprimitive expected"); break;
			case 126: s = coco_string_create(L"Tpull0 expected"); break;
			case 127: s = coco_string_create(L"Tpull1 expected"); break;
			case 128: s = coco_string_create(L"Tpulldown expected"); break;
			case 129: s = coco_string_create(L"Tpullup expected"); break;
			case 130: s = coco_string_create(L"Tpulsestyle_onevent expected"); break;
			case 131: s = coco_string_create(L"Tpulsestyle_ondetect expected"); break;
			case 132: s = coco_string_create(L"Trcmos expected"); break;
			case 133: s = coco_string_create(L"Treal expected"); break;
			case 134: s = coco_string_create(L"Trealtime expected"); break;
			case 135: s = coco_string_create(L"Treg expected"); break;
			case 136: s = coco_string_create(L"Trelease expected"); break;
			case 137: s = coco_string_create(L"Trepeat expected"); break;
			case 138: s = coco_string_create(L"Trnmos expected"); break;
			case 139: s = coco_string_create(L"Trpmos expected"); break;
			case 140: s = coco_string_create(L"Trtran expected"); break;
			case 141: s = coco_string_create(L"Trtranif0 expected"); break;
			case 142: s = coco_string_create(L"Trtranif1 expected"); break;
			case 143: s = coco_string_create(L"Tscalared expected"); break;
			case 144: s = coco_string_create(L"Tshowcancelled expected"); break;
			case 145: s = coco_string_create(L"Tsigned expected"); break;
			case 146: s = coco_string_create(L"Tsmall expected"); break;
			case 147: s = coco_string_create(L"Tspecify expected"); break;
			case 148: s = coco_string_create(L"Tspecparam expected"); break;
			case 149: s = coco_string_create(L"Tstrong0 expected"); break;
			case 150: s = coco_string_create(L"Tstrong1 expected"); break;
			case 151: s = coco_string_create(L"Tsupply0 expected"); break;
			case 152: s = coco_string_create(L"Tsupply1 expected"); break;
			case 153: s = coco_string_create(L"Ttable expected"); break;
			case 154: s = coco_string_create(L"Ttask expected"); break;
			case 155: s = coco_string_create(L"Ttime expected"); break;
			case 156: s = coco_string_create(L"Ttran expected"); break;
			case 157: s = coco_string_create(L"Ttranif0 expected"); break;
			case 158: s = coco_string_create(L"Ttranif1 expected"); break;
			case 159: s = coco_string_create(L"Ttri expected"); break;
			case 160: s = coco_string_create(L"Ttri0 expected"); break;
			case 161: s = coco_string_create(L"Ttri1 expected"); break;
			case 162: s = coco_string_create(L"Ttriand expected"); break;
			case 163: s = coco_string_create(L"Ttrior expected"); break;
			case 164: s = coco_string_create(L"Ttrireg expected"); break;
			case 165: s = coco_string_create(L"Tunsigned expected"); break;
			case 166: s = coco_string_create(L"Tuse expected"); break;
			case 167: s = coco_string_create(L"Tuwire expected"); break;
			case 168: s = coco_string_create(L"Tvectored expected"); break;
			case 169: s = coco_string_create(L"Twait expected"); break;
			case 170: s = coco_string_create(L"Twand expected"); break;
			case 171: s = coco_string_create(L"Tweak0 expected"); break;
			case 172: s = coco_string_create(L"Tweak1 expected"); break;
			case 173: s = coco_string_create(L"Twhile expected"); break;
			case 174: s = coco_string_create(L"Twire expected"); break;
			case 175: s = coco_string_create(L"Twor expected"); break;
			case 176: s = coco_string_create(L"Txnor expected"); break;
			case 177: s = coco_string_create(L"Txor expected"); break;
			case 178: s = coco_string_create(L"TmaxKeyword expected"); break;
			case 179: s = coco_string_create(L"TPathPulse expected"); break;
			case 180: s = coco_string_create(L"TSetup expected"); break;
			case 181: s = coco_string_create(L"THold expected"); break;
			case 182: s = coco_string_create(L"TSetupHold expected"); break;
			case 183: s = coco_string_create(L"TRecovery expected"); break;
			case 184: s = coco_string_create(L"TRemoval expected"); break;
			case 185: s = coco_string_create(L"TRecrem expected"); break;
			case 186: s = coco_string_create(L"TSkew expected"); break;
			case 187: s = coco_string_create(L"TTimeSkew expected"); break;
			case 188: s = coco_string_create(L"TFullSkew expected"); break;
			case 189: s = coco_string_create(L"TPeriod expected"); break;
			case 190: s = coco_string_create(L"TWidth expected"); break;
			case 191: s = coco_string_create(L"TNoChange expected"); break;
			case 192: s = coco_string_create(L"TmaxSystemName expected"); break;
			case 193: s = coco_string_create(L"TString expected"); break;
			case 194: s = coco_string_create(L"TIdent expected"); break;
			case 195: s = coco_string_create(L"TSysName expected"); break;
			case 196: s = coco_string_create(L"TCoDi expected"); break;
			case 197: s = coco_string_create(L"TRealnum expected"); break;
			case 198: s = coco_string_create(L"TNatural expected"); break;
			case 199: s = coco_string_create(L"TSizedBased expected"); break;
			case 200: s = coco_string_create(L"TBasedInt expected"); break;
			case 201: s = coco_string_create(L"TBaseFormat expected"); break;
			case 202: s = coco_string_create(L"TBaseValue expected"); break;
			case 203: s = coco_string_create(L"TAttribute expected"); break;
			case 204: s = coco_string_create(L"TMacroUsage expected"); break;
			case 205: s = coco_string_create(L"??? expected"); break;
			case 206: s = coco_string_create(L"invalid unary_operator"); break;
			case 207: s = coco_string_create(L"invalid binary_operator"); break;
			case 208: s = coco_string_create(L"invalid unary_module_path_operator"); break;
			case 209: s = coco_string_create(L"invalid binary_module_path_operator"); break;
			case 210: s = coco_string_create(L"invalid udp_declaration"); break;
			case 211: s = coco_string_create(L"invalid file_path_spec"); break;
			case 212: s = coco_string_create(L"invalid module_keyword"); break;
			case 213: s = coco_string_create(L"invalid module_item"); break;
			case 214: s = coco_string_create(L"invalid parameter_declaration"); break;
			case 215: s = coco_string_create(L"invalid port"); break;
			case 216: s = coco_string_create(L"invalid port_declaration"); break;
			case 217: s = coco_string_create(L"invalid port_expression"); break;
			case 218: s = coco_string_create(L"invalid output_declaration"); break;
			case 219: s = coco_string_create(L"invalid non_port_module_item"); break;
			case 220: s = coco_string_create(L"invalid module_or_generate_item"); break;
			case 221: s = coco_string_create(L"invalid module_or_generate_item_declaration"); break;
			case 222: s = coco_string_create(L"invalid local_parameter_declaration"); break;
			case 223: s = coco_string_create(L"invalid gate_instantiation"); break;
			case 224: s = coco_string_create(L"invalid loop_generate_construct"); break;
			case 225: s = coco_string_create(L"invalid conditional_generate_construct"); break;
			case 226: s = coco_string_create(L"invalid net_declaration"); break;
			case 227: s = coco_string_create(L"invalid config_rule_statement"); break;
			case 228: s = coco_string_create(L"invalid config_rule_statement"); break;
			case 229: s = coco_string_create(L"invalid parameter_type"); break;
			case 230: s = coco_string_create(L"invalid net_type"); break;
			case 231: s = coco_string_create(L"invalid output_variable_type"); break;
			case 232: s = coco_string_create(L"invalid drive_strength"); break;
			case 233: s = coco_string_create(L"invalid drive_strength"); break;
			case 234: s = coco_string_create(L"invalid charge_strength"); break;
			case 235: s = coco_string_create(L"invalid real_type"); break;
			case 236: s = coco_string_create(L"invalid variable_type"); break;
			case 237: s = coco_string_create(L"invalid strength0"); break;
			case 238: s = coco_string_create(L"invalid strength1"); break;
			case 239: s = coco_string_create(L"invalid delay_value"); break;
			case 240: s = coco_string_create(L"invalid expression_nlr"); break;
			case 241: s = coco_string_create(L"invalid specparam_assignment"); break;
			case 242: s = coco_string_create(L"invalid function_range_or_type"); break;
			case 243: s = coco_string_create(L"invalid function_item_declaration"); break;
			case 244: s = coco_string_create(L"invalid block_item_declaration"); break;
			case 245: s = coco_string_create(L"invalid tf_input_declaration"); break;
			case 246: s = coco_string_create(L"invalid task_item_declaration"); break;
			case 247: s = coco_string_create(L"invalid tf_output_declaration"); break;
			case 248: s = coco_string_create(L"invalid tf_inout_declaration"); break;
			case 249: s = coco_string_create(L"invalid task_port_item"); break;
			case 250: s = coco_string_create(L"invalid task_port_type"); break;
			case 251: s = coco_string_create(L"invalid cmos_switchtype"); break;
			case 252: s = coco_string_create(L"invalid enable_gatetype"); break;
			case 253: s = coco_string_create(L"invalid mos_switchtype"); break;
			case 254: s = coco_string_create(L"invalid n_input_gatetype"); break;
			case 255: s = coco_string_create(L"invalid n_output_gatetype"); break;
			case 256: s = coco_string_create(L"invalid pass_en_switchtype"); break;
			case 257: s = coco_string_create(L"invalid pass_switchtype"); break;
			case 258: s = coco_string_create(L"invalid pulldown_strength"); break;
			case 259: s = coco_string_create(L"invalid pulldown_strength"); break;
			case 260: s = coco_string_create(L"invalid pullup_strength"); break;
			case 261: s = coco_string_create(L"invalid pullup_strength"); break;
			case 262: s = coco_string_create(L"invalid net_lvalue"); break;
			case 263: s = coco_string_create(L"invalid constant_primary"); break;
			case 264: s = coco_string_create(L"invalid generate_block_or_null"); break;
			case 265: s = coco_string_create(L"invalid case_generate_item"); break;
			case 266: s = coco_string_create(L"invalid udp_port_declaration"); break;
			case 267: s = coco_string_create(L"invalid sequential_or_combinatorial_entry"); break;
			case 268: s = coco_string_create(L"invalid sequential_or_combinatorial_entry"); break;
			case 269: s = coco_string_create(L"invalid level_or_edge_symbol"); break;
			case 270: s = coco_string_create(L"invalid level_symbol"); break;
			case 271: s = coco_string_create(L"invalid number"); break;
			case 272: s = coco_string_create(L"invalid number"); break;
			case 273: s = coco_string_create(L"invalid number"); break;
			case 274: s = coco_string_create(L"invalid edge_descriptor"); break;
			case 275: s = coco_string_create(L"invalid statement"); break;
			case 276: s = coco_string_create(L"invalid procedural_continuous_assignments"); break;
			case 277: s = coco_string_create(L"invalid variable_lvalue"); break;
			case 278: s = coco_string_create(L"invalid variable_or_net_lvalue"); break;
			case 279: s = coco_string_create(L"invalid delay_or_event_control"); break;
			case 280: s = coco_string_create(L"invalid case_statement"); break;
			case 281: s = coco_string_create(L"invalid loop_statement"); break;
			case 282: s = coco_string_create(L"invalid event_control"); break;
			case 283: s = coco_string_create(L"invalid event_control"); break;
			case 284: s = coco_string_create(L"invalid event_expression"); break;
			case 285: s = coco_string_create(L"invalid procedural_timing_control"); break;
			case 286: s = coco_string_create(L"invalid case_item"); break;
			case 287: s = coco_string_create(L"invalid specify_item"); break;
			case 288: s = coco_string_create(L"invalid pulsestyle_declaration"); break;
			case 289: s = coco_string_create(L"invalid showcancelled_declaration"); break;
			case 290: s = coco_string_create(L"invalid path_declaration"); break;
			case 291: s = coco_string_create(L"invalid system_timing_check"); break;
			case 292: s = coco_string_create(L"invalid simple_or_edge_sensitive_path_declaration"); break;
			case 293: s = coco_string_create(L"invalid simple_or_edge_sensitive_path_declaration"); break;
			case 294: s = coco_string_create(L"invalid state_dependent_path_declaration"); break;
			case 295: s = coco_string_create(L"invalid parallel_or_full_path_description"); break;
			case 296: s = coco_string_create(L"invalid polarity_operator"); break;
			case 297: s = coco_string_create(L"invalid edge_identifier"); break;
			case 298: s = coco_string_create(L"invalid simple_or_edge_sensitive_path_description"); break;
			case 299: s = coco_string_create(L"invalid simple_or_edge_sensitive_path_description"); break;
			case 300: s = coco_string_create(L"invalid timing_check_event_control"); break;
			case 301: s = coco_string_create(L"invalid constant_expression_nlr"); break;
			case 302: s = coco_string_create(L"invalid primary"); break;
			case 303: s = coco_string_create(L"invalid module_path_primary"); break;
			case 304: s = coco_string_create(L"invalid parameter_value_assignment_or_delay2"); break;
			case 305: s = coco_string_create(L"invalid port_connection_or_output_terminal"); break;
			case 306: s = coco_string_create(L"invalid primary_2"); break;

		default:
		{
			s = QString( "generic error %1").arg(n);
		}
		break;
	}
    if( !str.isEmpty() )
        s = QString("%1 %2").arg(s).arg(str);
	if( err )
		err->error(Vl::Errors::Syntax, sourcePath, line, col, s);
	else
		qCritical() << "Error Parser" << line << col << s;
	//count++;
}

void Errors::Error(int line, int col, const char *s) {
	printf("-- line %d col %d: %s\n", line, col, s);
	count++;
}

void Errors::Warning(int line, int col, const char *s) {
	printf("-- line %d col %d: %s\n", line, col, s);
}

void Errors::Warning(const char *s) {
	printf("%s\n", s);
}

void Errors::Exception(const char* s) {
	printf("%s", s); 
	exit(1);
}

} // namespace

