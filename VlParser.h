

// This file was automatically generated by Coco/R; don't modify it.
#if !defined(Vl_COCO_PARSER_H__)
#define Vl_COCO_PARSER_H__

#include <QStack>
#include <Verilog/VlSynTree.h>


#include <Verilog/VlPpLexer.h>

namespace Vl {



class Parser {
private:
	enum {
		_EOF=0,
		_T_Literals_=1,
		_T_Bang=2,
		_T_BangEq=3,
		_T_Bang2Eq=4,
		_T_Hash=5,
		_T_2Hash=6,
		_T_2HashLbrackStarRbrack=7,
		_T_2HashLbrackPlusRbrack=8,
		_T_HashMinusHash=9,
		_T_HashEqHash=10,
		_T_Dlr=11,
		_T_Percent=12,
		_T_Amp=13,
		_T_2Amp=14,
		_T_3Amp=15,
		_T_Lpar=16,
		_T_Latt=17,
		_T_LparStarRpar=18,
		_T_Rpar=19,
		_T_Star=20,
		_T_Ratt=21,
		_T_2Star=22,
		_T_Rcmt=23,
		_T_StarGt=24,
		_T_Plus=25,
		_T_PlusColon=26,
		_T_Comma=27,
		_T_Minus=28,
		_T_MinusColon=29,
		_T_MinusGt=30,
		_T_Dot=31,
		_T_2Dot=32,
		_T_3Dot=33,
		_T_Slash=34,
		_T_Lcmt=35,
		_T_2Slash=36,
		_T_Colon=37,
		_T_ColonSlash=38,
		_T_ColonEq=39,
		_T_Semi=40,
		_T_Lt=41,
		_T_2Lt=42,
		_T_3Lt=43,
		_T_Leq=44,
		_T_Eq=45,
		_T_2Eq=46,
		_T_3Eq=47,
		_T_EqGt=48,
		_T_Gt=49,
		_T_Geq=50,
		_T_2Gt=51,
		_T_3Gt=52,
		_T_Qmark=53,
		_T_At=54,
		_T_Lbrack=55,
		_T_LbrackStar=56,
		_T_LbrackStarRbrack=57,
		_T_LbrackPlusRbrack=58,
		_T_LbrackMinusGt=59,
		_T_LbrackEq=60,
		_T_Rbrack=61,
		_T_Hat=62,
		_T_HatTilde=63,
		_T_Lbrace=64,
		_T_Bar=65,
		_T_BarMinusGt=66,
		_T_BarEqGt=67,
		_T_2Bar=68,
		_T_Rbrace=69,
		_T_Tilde=70,
		_T_TildeAmp=71,
		_T_TildeHat=72,
		_T_TildeBar=73,
		_T_Keywords_=74,
		_T_dlr_fullskew=75,
		_T_dlr_hold=76,
		_T_dlr_nochange=77,
		_T_dlr_period=78,
		_T_dlr_recovery=79,
		_T_dlr_recrem=80,
		_T_dlr_removal=81,
		_T_dlr_setup=82,
		_T_dlr_setuphold=83,
		_T_dlr_skew=84,
		_T_dlr_timeskew=85,
		_T_dlr_width=86,
		_T_PATHPULSE_dlr=87,
		_T_accept_on=88,
		_T_always=89,
		_T_and=90,
		_T_assert=91,
		_T_assign=92,
		_T_assume=93,
		_T_automatic=94,
		_T_begin=95,
		_T_buf=96,
		_T_bufif0=97,
		_T_bufif1=98,
		_T_case=99,
		_T_casex=100,
		_T_casez=101,
		_T_cell=102,
		_T_cmos=103,
		_T_config=104,
		_T_cover=105,
		_T_deassign=106,
		_T_default=107,
		_T_defparam=108,
		_T_design=109,
		_T_disable=110,
		_T_dist=111,
		_T_edge=112,
		_T_else=113,
		_T_end=114,
		_T_endcase=115,
		_T_endconfig=116,
		_T_endfunction=117,
		_T_endgenerate=118,
		_T_endmodule=119,
		_T_endprimitive=120,
		_T_endspecify=121,
		_T_endtable=122,
		_T_endtask=123,
		_T_event=124,
		_T_eventually=125,
		_T_final=126,
		_T_for=127,
		_T_force=128,
		_T_forever=129,
		_T_fork=130,
		_T_function=131,
		_T_generate=132,
		_T_genvar=133,
		_T_highz0=134,
		_T_highz1=135,
		_T_if=136,
		_T_iff=137,
		_T_ifnone=138,
		_T_implies=139,
		_T_incdir=140,
		_T_include=141,
		_T_initial=142,
		_T_inout=143,
		_T_input=144,
		_T_instance=145,
		_T_integer=146,
		_T_intersect=147,
		_T_join=148,
		_T_large=149,
		_T_liblist=150,
		_T_library=151,
		_T_localparam=152,
		_T_logic=153,
		_T_macromodule=154,
		_T_medium=155,
		_T_module=156,
		_T_nand=157,
		_T_negedge=158,
		_T_nexttime=159,
		_T_nmos=160,
		_T_nor=161,
		_T_noshowcancelled=162,
		_T_not=163,
		_T_notif0=164,
		_T_notif1=165,
		_T_or=166,
		_T_output=167,
		_T_parameter=168,
		_T_pmos=169,
		_T_posedge=170,
		_T_primitive=171,
		_T_property=172,
		_T_pull0=173,
		_T_pull1=174,
		_T_pulldown=175,
		_T_pullup=176,
		_T_pulsestyle_ondetect=177,
		_T_pulsestyle_onevent=178,
		_T_rcmos=179,
		_T_real=180,
		_T_realtime=181,
		_T_reg=182,
		_T_reject_on=183,
		_T_release=184,
		_T_repeat=185,
		_T_restrict=186,
		_T_rnmos=187,
		_T_rpmos=188,
		_T_rtran=189,
		_T_rtranif0=190,
		_T_rtranif1=191,
		_T_s_always=192,
		_T_s_eventually=193,
		_T_s_nexttime=194,
		_T_s_until=195,
		_T_s_until_with=196,
		_T_scalared=197,
		_T_sequence=198,
		_T_showcancelled=199,
		_T_signed=200,
		_T_small=201,
		_T_specify=202,
		_T_specparam=203,
		_T_strong=204,
		_T_strong0=205,
		_T_strong1=206,
		_T_supply0=207,
		_T_supply1=208,
		_T_sync_accept_on=209,
		_T_sync_reject_on=210,
		_T_table=211,
		_T_task=212,
		_T_throughout=213,
		_T_time=214,
		_T_tran=215,
		_T_tranif0=216,
		_T_tranif1=217,
		_T_tri=218,
		_T_tri0=219,
		_T_tri1=220,
		_T_triand=221,
		_T_trior=222,
		_T_trireg=223,
		_T_until=224,
		_T_until_with=225,
		_T_use=226,
		_T_uwire=227,
		_T_vectored=228,
		_T_wait=229,
		_T_wand=230,
		_T_weak=231,
		_T_weak0=232,
		_T_weak1=233,
		_T_while=234,
		_T_wire=235,
		_T_within=236,
		_T_wor=237,
		_T_xnor=238,
		_T_xor=239,
		_T_Specials_=240,
		_T_Attribute=241,
		_T_Comment=242,
		_T_MacroUsage=243,
		_T_Section=244,
		_T_SectionEnd=245,
		_T_CoDi=246,
		_T_LineCont=247,
		_T_Realnum=248,
		_T_Natural=249,
		_T_SizedBased=250,
		_T_BasedInt=251,
		_T_BaseFormat=252,
		_T_BaseValue=253,
		_T_SysName=254,
		_T_Ident=255,
		_T_Str=256,
		_T_Eof=257,
		_T_MaxToken_=258
	};
	int maxT;

	int errDist;
	int minErrDist;

	void SynErr(int n, const char* ctx = 0);
	void Get();
	void Expect(int n, const char* ctx = 0);
	bool StartOf(int s);
	void ExpectWeak(int n, int follow);
	bool WeakSeparator(int n, int syFol, int repFol);
    void SynErr(const QString& sourcePath, int line, int col, int n, Vl::Errors* err, const char* ctx, const QString& = QString() );

public:
	Vl::PpLexer *scanner;
	Vl::Errors  *errors;

	Vl::Token d_cur;
	Vl::Token d_next;
	struct TokDummy
	{
		int kind;
	};
	TokDummy d_dummy;
	TokDummy *la;			// lookahead token
	QList<Vl::Token> d_sections;
	
	int peek( quint8 la = 1 );

    void RunParser()
    {
        d_stack.push(&d_root);
        Parse();
        d_stack.pop();
    }
    
Vl::SynTree d_root;
	QStack<Vl::SynTree*> d_stack;
	void addTerminal() {
		Vl::SynTree* n = new Vl::SynTree( d_cur ); d_stack.top()->d_children.append(n);
	}



	Parser(Vl::PpLexer *scanner,Vl::Errors*);
	~Parser();
	void SemErr(const char* msg);

	void Verilog();
	void module_declaration();
	void udp_declaration();
	void config_declaration();
	void library_declaration();
	void include_statement();
	void library_identifier();
	void file_path_spec();
	void string();
	void file_path_glyph_();
	void identifier();
	void module_keyword();
	void module_identifier();
	void module_parameter_port_list();
	void list_of_ports();
	void list_of_port_declarations();
	void port_declaration();
	void non_port_module_item();
	void parameter_declaration();
	void port();
	void port_expression();
	void port_identifier();
	void port_reference();
	void constant_range_expression();
	void inout_declaration();
	void input_declaration();
	void output_declaration();
	void module_or_generate_item();
	void module_or_generate_item_declaration();
	void local_parameter_declaration();
	void parameter_override();
	void continuous_assign();
	void gate_instantiation();
	void block_identifier();
	void concurrent_assertion_statement();
	void module_or_udp_instantiation_();
	void initial_construct();
	void always_construct();
	void loop_generate_construct();
	void conditional_generate_construct();
	void net_declaration();
	void reg_declaration();
	void integer_declaration();
	void real_declaration();
	void time_declaration();
	void realtime_declaration();
	void event_declaration();
	void genvar_declaration();
	void task_declaration();
	void function_declaration();
	void generate_region();
	void specify_block();
	void specparam_declaration();
	void list_of_defparam_assignments();
	void config_identifier();
	void design_statement();
	void config_rule_statement();
	void cell_identifier();
	void default_clause();
	void liblist_clause();
	void inst_clause();
	void use_clause();
	void cell_clause();
	void inst_name();
	void topmodule_identifier();
	void instance_identifier();
	void range();
	void list_of_param_assignments();
	void parameter_type();
	void list_of_specparam_assignments();
	void net_type();
	void list_of_port_identifiers();
	void reg_();
	void list_of_variable_port_identifiers();
	void output_variable_type();
	void list_of_event_identifiers();
	void list_of_variable_identifiers();
	void drive_strength();
	void delay3();
	void list_of_net_identifiers_of_decl_assignments_();
	void charge_strength();
	void net_identifier();
	void dimension();
	void expression();
	void list_of_real_identifiers();
	void real_type();
	void real_identifier();
	void constant_expression();
	void variable_type();
	void variable_identifier();
	void strength0();
	void strength1();
	void delay_value();
	void mintypmax_expression();
	void delay2();
	void unsigned_number();
	void real_number();
	void defparam_assignment();
	void event_identifier();
	void param_assignment();
	void specparam_assignment();
	void hierarchical_parameter_identifier();
	void constant_mintypmax_expression();
	void parameter_identifier();
	void specparam_identifier();
	void pulse_control_specparam();
	void reject_limit_value();
	void error_limit_value();
	void limit_value();
	void dimension_constant_expression();
	void msb_constant_expression();
	void lsb_constant_expression();
	void function_range_or_type();
	void function_identifier();
	void function_port_list();
	void block_item_declaration();
	void tf_input_declaration();
	void function_statement();
	void task_identifier();
	void task_port_list();
	void task_item_declaration();
	void statement_or_null();
	void tf_output_declaration();
	void tf_inout_declaration();
	void task_port_item();
	void task_port_type();
	void list_of_block_variable_identifiers();
	void list_of_block_real_identifiers();
	void block_variable_type();
	void block_real_type();
	void cmos_switchtype();
	void cmos_switch_instance();
	void enable_gatetype();
	void enable_gate_instance();
	void mos_switchtype();
	void mos_switch_instance();
	void n_input_gatetype();
	void n_input_gate_instance();
	void n_output_gatetype();
	void n_output_gate_instance();
	void pass_en_switchtype();
	void pass_enable_switch_instance();
	void pass_switchtype();
	void pass_switch_instance();
	void pulldown_strength();
	void pull_gate_instance();
	void pullup_strength();
	void name_of_gate_instance();
	void output_terminal();
	void input_terminal();
	void ncontrol_terminal();
	void pcontrol_terminal();
	void enable_terminal();
	void inout_terminal();
	void gate_instance_identifier();
	void net_lvalue();
	void named_parameter_assignment();
	void parameter_value_assignment_or_delay2_();
	void module_or_udp_instance_();
	void port_connection_or_output_terminal_();
	void list_of_genvar_identifiers();
	void genvar_identifier();
	void genvar_initialization();
	void genvar_expression();
	void genvar_iteration();
	void generate_block();
	void genvar_primary();
	void genvar_expression_nlr_();
	void unary_operator();
	void binary_operator();
	void primary();
	void if_generate_construct();
	void case_generate_construct();
	void generate_block_or_null();
	void case_generate_item();
	void generate_block_identifier();
	void udp_identifier();
	void udp_port_list();
	void udp_declaration_port_list();
	void udp_port_declaration();
	void udp_body();
	void output_port_identifier();
	void input_port_identifier();
	void udp_output_declaration();
	void udp_input_declaration();
	void udp_reg_declaration();
	void udp_initial_statement();
	void udp_body_entry_();
	void entry_symbol_();
	void number();
	void init_val();
	void list_of_net_assignments();
	void net_assignment();
	void statement();
	void assignment_or_task_enable_();
	void variable_lvalue();
	void delay_or_event_control();
	void procedural_continuous_assignments();
	void assignment_();
	void lvalue_();
	void variable_assignment();
	void par_block();
	void seq_block();
	void case_statement();
	void conditional_statement();
	void disable_statement();
	void event_trigger();
	void loop_statement();
	void procedural_timing_control_statement();
	void system_task_enable();
	void wait_statement();
	void procedural_assertion_statement();
	void delay_control();
	void event_control();
	void hierarchical_identifier();
	void hierarchical_event_identifier();
	void event_expression();
	void event_expression_nlr_();
	void procedural_timing_control();
	void case_item();
	void system_task_identifier();
	void specify_item();
	void pulsestyle_declaration();
	void showcancelled_declaration();
	void path_declaration();
	void system_timing_check();
	void list_of_path_outputs();
	void path_description_();
	void path_delay_value();
	void state_dependent_path_declaration();
	void simple_path_declaration();
	void edge_identifier();
	void list_of_path_inouts_();
	void polarity_operator();
	void data_source_expression();
	void specify_terminal_descriptor();
	void specify_output_terminal_descriptor();
	void output_identifier();
	void list_of_path_delay_expressions();
	void path_delay_expression();
	void module_path_expression();
	void dlr_setup_timing_check();
	void dlr_hold_timing_check();
	void dlr_setuphold_timing_check();
	void dlr_recovery_timing_check();
	void dlr_removal_timing_check();
	void dlr_recrem_timing_check();
	void dlr_skew_timing_check();
	void dlr_timeskew_timing_check();
	void dlr_fullskew_timing_check();
	void dlr_period_timing_check();
	void dlr_width_timing_check();
	void dlr_nochange_timing_check();
	void data_event();
	void reference_event();
	void timing_check_limit();
	void notifier();
	void stamptime_condition();
	void checktime_condition();
	void delayed_reference();
	void delayed_data();
	void event_based_flag();
	void remain_active_flag();
	void controlled_reference_event();
	void threshold();
	void start_edge_offset();
	void end_edge_offset();
	void controlled_timing_check_event();
	void timing_check_event();
	void terminal_identifier();
	void timing_check_event_control();
	void timing_check_condition();
	void edge_control_specifier();
	void edge_descriptor();
	void scalar_timing_check_condition();
	void scalar_constant();
	void single_or_multiple_concatenation_();
	void mod_path_single_or_multi_concat_();
	void system_function_call();
	void system_function_identifier();
	void range_expression();
	void expression_nlr_();
	void expression2();
	void expression3();
	void module_path_primary();
	void module_path_expression_nlr_();
	void unary_module_path_operator();
	void binary_module_path_operator();
	void module_path_mintypmax_expression();
	void rvalue_or_function_call_();
	void hierarchical_net_identifier();
	void hierarchical_variable_identifier();
	void system_identifier_();
	void assert_statement_();
	void property_spec();
	void action_block();
	void assume_statement_();
	void cover_statement_();
	void cover_sequence_statement();
	void clocking_event();
	void expression_or_dist();
	void sequence_expr();
	void restrict_property_statement();
	void immediate_assertion_statement_();
	void property_expr();
	void dist_list();
	void dist_item();
	void value_range();
	void dist_weight();
	void property_expr_nlr_();
	void property_case_item();
	void cycle_delay_const_range_expression();
	void constant_range();
	void cycle_delay_range();
	void sequence_expr_nlr_();
	void boolean_abbrev();
	void consecutive_repetition();
	void non_consecutive_repetition();
	void goto_repetition();
	void const_or_range_expression();

	void Parse();

}; // end Parser

} // namespace


#endif

